

#include <X11/copyright.h>

/*
 * Copyright 1989    Institute of Systems Science (ISS),
 *		     National University of Singapore , Singapore
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of ISS not be used 
 * in advertising or publicity pertaining to distribution of the software 
 * without specific, written prior permission. ISS makes no representations
 * about the suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 *
 *
 * ISS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * ISS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
 * CONTACT:      HU XIAN XIANG,
 * 		 INSTIUTE OF SYSTEMS SCIENCE, 
 *               NATIONAL UNIVERSITY OF SINGAPORE, 	
 *               REPUBLIC OF SINGAPORE  0511
 * FAX:          (65)7782571
 * TELEX:        ISSNUS RS 39988
 * BITNET:       ISSMLX@NUSVM 
*/

/* Filename: mlinput.c   15, Nov 1989, By Hu Xian Xiang */

#include <X11/X.h>
#include <X11/Xos.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>
#include <X11/cursorfont.h>
#include <X11/Xutil.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Command.h>
#include <Xw/Xw.h>
#include <Xw/Form.h>
#include <Xw/PButton.h>
#include <Xw/WorkSpace.h>

#include "cursor.h"
#include "atoms.h"
#include "mlinput.h"
#include "extern.h"

main(argc, argv)
int argc;
char **argv;
{
	static	Arg args[3];
	Widget	tmp1,tmp2;
	XEvent	event;
	int	i;

	TblAddr = malloc(63000);
	initconf();
	toplevel = XtInitialize( "input", "Input", NULL, 0, &argc, argv);
	CurDpy = XtDisplay(toplevel);

	frame = XtCreateManagedWidget( "frame", XwformWidgetClass, toplevel,
					NULL,0);
	XtAddEventHandler(frame,KeyReleaseMask,0,HandleKeyPress,NULL);

	hanzi_code = XInternAtom(CurDpy,hancode1, False);
	hanzi_type = XInternAtom(CurDpy,hancode2, False);

	lings_w = LingBoxes();
	tmp1 =  CreateWindow("dialog",2,Y1,20, W1,0,RedrawDialog);
	tmp2 =  CreateWindow("prompt",0,Y3,20,WID,0,RedrawPrompt);
	XtRealizeWidget(toplevel);

	XtSetArg(args[0], XtNfont,	&font);
	XtSetArg(args[1], XtNforeground,&fg);
	XtSetArg(args[2], XtNbackground,&bg);
	XtGetValues(lings_w, args, 3);
	GetASCIIGC(font);

	CreateKeys();
	dialogwin = XtWindow(tmp1);
	promptwin = XtWindow(tmp2);
	CurWin	  = XtWindow(toplevel);
	root	  = DefaultRootWindow(CurDpy);

	SetSize(lings_w,Y1);
	XDefineCursor(CurDpy,CurWin, XCreateMLC_Cursor());
	XSelectInput(CurDpy,root,PropertyChangeMask);
	
	while(1) {		/*	XtMainLoop();	 */
		XtNextEvent(&event);
		if (event.type == PropertyNotify)
			if (event.xproperty.window == root  &&
			    event.xproperty.atom   == hanzi_code){
				MapInput(event);
				continue;
			}
		XtDispatchEvent(&event);
	}
}

/************************************************
 * Creat input window special mouse cursor 	*
 * The shape is defined in cursor.h		*
 * which is generated by bitmap command. 	*
 * MLXTERM also uses this cursor.		*
 * Please see function "make_hanzi_cursor"  in	*
 * misc.c of MLXTERM source code.		*
 ************************************************/

XCreateMLC_Cursor( )
{
	Cursor c;
	XColor real_color;
	Pixmap source,mask;
	Colormap   def_cm; 
	int	iscolor,screen;

	source = XCreateBitmapFromData(CurDpy,XtWindow(toplevel),
			tmp1_bits,tmp1_width,tmp1_height);
	mask = NULL;
	if (source==NULL ) {
		printf("Make hanzi mouse cursor unsuccessful.\n");
		return(XCreateFontCursor( XtDisplay(toplevel), XC_heart)); 
	}

	screen = DefaultScreen(CurDpy);
	def_cm = DefaultColormap(CurDpy, screen);
	if (DisplayCells(CurDpy, screen) > 2)
		iscolor = 1;
	else
		iscolor = 0;

	if (iscolor) {
		XAllocNamedColor (CurDpy, def_cm, "blue", &bg1, &real_color);
		XAllocNamedColor (CurDpy, def_cm, "white",&fg1, &real_color);
	} else {
		XAllocNamedColor (CurDpy, def_cm, "black",&bg1, &real_color);
		XAllocNamedColor (CurDpy, def_cm, "white",&fg1, &real_color);
	}
	c = XCreatePixmapCursor(CurDpy,source,mask,
		&bg1,&fg1,tmp1_width/2,tmp1_height/2);
	return(c);
}
	

/* 	Set new font  for a language */
set_a_GC(fontname)
char	*fontname;
{
	XFontStruct  *tmpfont;
	XGCValues	gcv;
	unsigned long	gcm;

	if (!strlen(fontname)) return;
	tmpfont= XLoadQueryFont(CurDpy,fontname);
	if ( tmpfont== NULL ){
		fprintf(stderr,"Cannot open font: %s.\n",fontname);
		return;
	}
	gcm = 0;
	gcm |= GCFont;
	gcm |= GCForeground;
	gcm |= GCBackground;
	gcv.font = tmpfont->fid;
	gcv.foreground = fg;
	gcv.background = bg;
	normalGC = XtGetGC(fontbut,gcm,&gcv);
/*	printf("Openning... %s GC \n",fontname); 	*/
}

GetASCIIGC(font)
XFontStruct	*font;
{
	XFontStruct  *tmpfont_struct;
	XGCValues	gcv;
	unsigned long	gcm;

	tmpfont_struct = font;
	if ( tmpfont_struct == NULL )
		tmpfont_struct = (XFontStruct *)XtDefaultFont;

	char_width =  tmpfont_struct->max_bounds.rbearing-
	    tmpfont_struct->min_bounds.lbearing;
	char_height=  tmpfont_struct->max_bounds.ascent +
	    tmpfont_struct->max_bounds.descent;
	gcv.font = tmpfont_struct->fid;
	gcv.foreground = fg;
	gcv.background = bg;
	gcm = 0;
	gcm |= GCFont;
	gcm |= GCForeground;
	gcm |= GCBackground;
	asciiGC  = XtGetGC(fontbut,gcm,&gcv);
}

Widget	LingBoxes()
{
	short	int i,j,width0;
	Widget	tmp;
	Arg args[8],arg[1];

	XtSetArg(args[0], XtNxRefWidget, frame);
	XtSetArg(args[1], XtNyRefWidget, frame);
	XtSetArg(args[2], XtNxAddWidth , True);
	XtSetArg(args[3], XtNxOffset,    8);
	XtSetArg(args[4], XtNyAddHeight, True);
	XtSetArg(args[5], XtNyOffset,    2);
	XtSetArg(args[6], XtNxAttachRight,True);
	XtSetArg(args[7], XtNborderWidth,1);
	tmp = CreateButton(args,XtNumber(args),"Quit", DoQuit);
	XtSetArg(args[0], XtNxRefWidget, tmp );
	tmp = CreateButton(args,XtNumber(args),"Hide", DoHide);
	XtSetArg(args[0], XtNxRefWidget, tmp );
	tmp = CreateButton(args,XtNumber(args),"Help", DoHelp);
	XtSetArg(args[3], XtNxOffset,    20);
	for (i=0, width0 = 150; i<ML_MAX; i++){
		XtSetArg(args[0], XtNxRefWidget, tmp );
		tmp = CreateButton(args,XtNumber(args),
				record[i].name, language,i);
		XtSetArg(args[3], XtNxOffset,5);
	}
	fontbut = tmp;
	return(tmp);
}

CreateKeys()
{
	int i;
	Widget	tmp;
	Arg args[8];
	XFontStruct	*font;

	XtSetArg(args[1], XtNyRefWidget, frame);
	XtSetArg(args[2], XtNxAddWidth , True);
	XtSetArg(args[3], XtNxOffset,    3);
	XtSetArg(args[4], XtNyAddHeight, True);
	XtSetArg(args[5], XtNyOffset,    Y2);
	XtSetArg(args[6], XtNxAttachRight,True);
	font= XLoadQueryFont(CurDpy,"6x10");
	XtSetArg(args[7], XtNfont, font);
	tmp = frame;
	for (i=0; i<(fkeyno+2); i++){
		XtSetArg(args[0], XtNxRefWidget,tmp);
		tmp = Funwidget[i]=CreateButton(args,XtNumber(args),
						FKEY[i], Choice,i);
		XtSetArg(args[4], XtNyAddHeight,False);
	}
}

Widget	CreateButton(args,argn, name, function,x)
Arg *args;
int  argn;
char *name;
XtCallbackProc function;
int	x;
{
	Widget	button;
	static	XtCallbackRec	callbk[1];
	static	Arg arg[]={
		{XtNcallback,(XtArgVal) callbk}
	};

	callbk[0].callback = function;
	callbk[0].closure = (addr_t) x;

	button = XtCreateManagedWidget(name, commandWidgetClass, 
					frame, args, argn);
	XtAddEventHandler(button,ButtonReleaseMask,0,function,x);
	return(button);
}

Widget	CreateWindow(name,x,y,height,width,border,function)
int	x,y,height,width,border;
char	*name;
XtCallbackProc function;
{
	Arg	args[10];

	XtSetArg(args[0], XtNxRefWidget, frame);
	XtSetArg(args[1], XtNyRefWidget, frame);
	XtSetArg(args[2], XtNxOffset,    x    );
	XtSetArg(args[3], XtNyOffset,    y    );
	XtSetArg(args[4], XtNxAddWidth , True );
	XtSetArg(args[5], XtNyAddHeight, True );
	XtSetArg(args[6], XtNxAttachRight,True);
	XtSetArg(args[7], XtNwidth,      width);
	XtSetArg(args[8], XtNheight,    height);
	XtSetArg(args[9], XtNborderWidth,border);

	fontbut= XtCreateManagedWidget(name, XwworkSpaceWidgetClass,
					frame,args,XtNumber(args));
	XtAddEventHandler(fontbut,ExposureMask,0,function,NULL);
	return(fontbut);
}

setlabel(i,label)
int	i;
char	*label;
{
	Arg	arg[1];
	char	tmp[8];
	int	j;

	for (j=0;*label;) tmp[j++] = *label++;
	tmp[j] = 0;

	XtSetArg(arg[0], XtNlabel,tmp);
	XtSetValues(Funwidget[i], arg, 1);
}

SetSize(w,y)
Widget	w;
Dimension y;
{
	Arg	args[3];
	Dimension i,x;

	XtSetArg(args[0], XtNx,&x ); 
	XtSetArg(args[1], XtNwidth,&i); 
	XtGetValues(w, args, 2);
	i += x;
	i += 8;
	
	XtSetArg(args[0], XtNwidth, i); 
	XtSetArg(args[1], XtNheight,y);
	XtSetValues(toplevel, args, 2);
}


/****************************************
*	initconf():			*
*	Open mlconfig file which is the *
*	configuration of multilingual   *
*	environment built up by tool	*
*	'builder'.			*
*****************************************/
initconf()
{
	int	file,i;
	char	*p;

	file = open("mlconfig",0);
	if (file<0) {
		if ( chdir(getenv("MLDIR") ) ) {
			fprintf(stderr,"Cannot access \$MLDIR.\n");
			exit(0);
		}
		file = open("mlconfig",0);
		if (file<0) {
			fprintf(stderr,"Cannot Open ML configuration file\n");
			chdir(getenv("PWD") );
			exit(0);
		}
	}
	for (i=0;1;){
		if (read(file,&record[i],REC_LEN)!=REC_LEN) break;
		if (record[i].code&0x80) i++;
	}
	ML_MAX = i;
	close(file);
}
/****************************************
*	After select language some	*
*	initianization should be done.	*
*	set_a_GC, Open keyboard mapping	*
*****************************************/

language(w,i)
Widget w;
int	i;
{
	char	class;
	static	Widget last_w;
	Arg	arg[2];

	if (current == i) return;
	current = i;
	class = record[i].class;
	set_a_GC(record[i].nor_font);	/* Open a GC*/
	keymap = open(record[i].keybd,O_RDONLY); /* open layout */
	if (keymap <1)
		fprintf(stderr,"Warning: Keyboard does not exist.\n");
	DestroyMethod();

	if (last_w) {
		XtSetArg(arg[0], XtNbackground ,bg);
		XtSetArg(arg[1], XtNforeground ,fg);
		XtSetValues(last_w, arg, 2);
	}
	XtSetArg(arg[0], XtNbackground ,bg1.pixel);
	XtSetArg(arg[1], XtNforeground ,fg1.pixel);
	XtSetValues(w, arg, 2);
	last_w = w;

	switch(class){
	case	'L':
		map_len = read(keymap,mapbuf,256);
		CODE[0] = 0x81;
		CODE[1] = 0x80;		/* Default */
		break;
	case	'S':
		map_len = read(keymap,mapbuf,256);
		CODE[0] = 0x82;
		CODE[1] = record[i].code;
		break;
	case	'B':
		CODE[0] = record[i].code;
		input_method();
		break;
	default:
		fprintf(stderr,"Configuration Error! CLASS is %c.\n",class);
		exit(0);
	}
	close(keymap);
	hcc = 0;
	drawcode(' ',0);
	cls_prompt(0);
	save_hanzi[0] = 0;
	save_dialog[0] = 0;
	last_in_w = 0;
}

DoQuit()
{
	exit();
}

input_method()
{
	int	i;
	Arg	args[8];
	Widget	tmp;

	for (i=0;1;)
		if (read(keymap,Inmethod[i],2*METHOD)!=2*METHOD) break;
		else i++;
	MethodNum = i;

	XtSetArg(args[1], XtNyRefWidget, frame);
	XtSetArg(args[2], XtNxAddWidth , True);
	XtSetArg(args[3], XtNyAddHeight, True);
	XtSetArg(args[4], XtNyOffset, Y1);
	XtSetArg(args[5], XtNxOffset, W1+8);
	XtSetArg(args[6], XtNxAttachRight,True);
	XtSetArg(args[7], XtNfont, font);
	tmp = frame;
	for(i=0;i<MethodNum;){
		XtSetArg(args[0], XtNxRefWidget,tmp);
		if (!strcmp("standard", &Inmethod[i][METHOD]) )
			tmp = Method[i++]=CreateButton(args,
				  XtNumber(args),Inmethod[i],Input,100);
		else
			if (!strcmp("common", &Inmethod[i][METHOD]) )
				tmp = Method[i++]=CreateButton(args,
				  XtNumber(args),Inmethod[i],DoCommon);
			else
				tmp = Method[i++]=CreateButton(args,
				  XtNumber(args),Inmethod[i],Input,i);
		XtSetArg(args[3], XtNyAddHeight,False);
		XtSetArg(args[5], XtNxOffset, 10);
	}
	XtSetArg(args[0], XtNwidth, WID);
	XtSetArg(args[1], XtNheight,Y2);
	XtSetValues(toplevel, args, 2);
}

DoHelp()
{
	static	int	helpf;
	int	cnt,flag;
	static	char	*buf,*start;

	if (helpf<2 ){
		helpf = open(help,O_RDONLY);
		start= malloc(2560);
	}
	if (helpf<2){
		fprintf(stderr,"Sorry, no Help file.\n");
		return;
	}
	for (cnt=flag=1,buf=start; cnt && flag<25;){
		cnt = read(helpf,buf,1);
		if (*buf++ ==0xa) flag++;
	}
	*buf =0;
	fprintf(stderr,"%s", start);
	if (cnt){
		fprintf(stderr,"\n#### Select HELP box for more ...####\n");
		return;
	}
	fprintf(stderr,"\n#### END ####\n");
	close(helpf);
	free(start);
	helpf= 0;
}

DoHide()
{
	XUnmapWindow(CurDpy,CurWin);
}

/****************************************
 *  All input methods are here.		*
 *  The Input-Table is set up by 	*
 *  user himself.			*
 ****************************************/

extern	char	HiFreq[], HiF_name[];
DoCommon(w)
Widget	w;
{
	int	i;

	flag = 2;
	drawcode(' ',0);
	save_hanzi[0] = 0;
	Drawstr(HiF_name,0);
	i = open(char_f,O_RDONLY);
	n = read(i,hzbuf,1200);
	close(i);
	m = 0;
	Hifreq_flg = 1;
	drawbuf();
	Input(w,101);
}

Input(w,num)
Widget	w;
int    	num;
{
	Arg	arg[2];

	if (last_in_w) {
		XtSetArg(arg[0], XtNbackground ,bg);
		XtSetArg(arg[1], XtNforeground ,fg);
		XtSetValues(last_in_w, arg, 2);
	}
	XtSetArg(arg[0], XtNbackground ,bg1.pixel);
	XtSetArg(arg[1], XtNforeground ,fg1.pixel);
	XtSetValues(w, arg, 2);
	last_in_w = w;

	XtSetArg(arg[0], XtNwidth, WID);
	XtSetArg(arg[1], XtNheight,HIG);
	XtSetValues(toplevel, arg, 2);

	if (num==101) 
		return;	/* Most common used characters */

	hcc = 0;
	drawcode(' ',0);
	cls_prompt(0);
	save_hanzi[0] = 0;
	save_dialog[0] = 0;

	if (num==100){
		XtSetArg(arg[0], XtNwidth, WID);
		XtSetArg(arg[1], XtNheight,Y2);
		XtSetValues(toplevel, arg, 2);
		flag =1;	/* standard code input */
	} else{
		flag =2;
		n = m = 0;
		drawbuf();
		SelectTab( &Inmethod[num][METHOD] );
	}
}

DestroyMethod()
{
	int i;

	for (i=0; i<MethodNum; i++)
		XtDestroyWidget(Method[i]);
	MethodNum = 0;
	flag = 0;	/* Didn't select input method yet. */
	drawcode(' ',hcc=0);
	cls_prompt(0);
	SetSize(lings_w,Y1);
}

Choice(w,data,cipher)
Widget	w;
int	data;
XEvent	*cipher;
{
	int 	i;
	register int	rtnnumber;

	if (record[current].class!='B')
		return;
	i = data;
	switch (i) {
	case	0:
		retrieve('>');
		return;
	case	1:
		retrieve('<');
		return;
	case	2:
		rtnnumber = retrieve(' ');
		break;
	default:
		i -= 2;
		i |= 0x80;
		rtnnumber = retrieve(i);
	}
	if (rtnnumber==2){
		CODE[1]= hzcode[0];
		CODE[2]= hzcode[1];
		drawcode(' ',hcc=0);
		SendMLCode();
	}
}

HandleKeyPress(widg,closure,event)
Widget	widg;
caddr_t closure;
XKeyPressedEvent  *event;
{
	char	strbuf[2],externcode;
	int	rtnnumber,nbyte;
	KeySym	keycode;
	static  XComposeStatus	compose_status = {
		NULL,0				};

	nbyte = XLookupString(event,strbuf,2,&keycode,&compose_status);
	externcode = 0;
	if (IsFunctionKey(keycode) || IsMiscFunctionKey(keycode))
		externcode = FKeyValue(keycode) | 0x80;
	else if(nbyte >0)
		externcode = strbuf[0];
	if (!externcode) return;
	if (record[current].class=='B')
		MapTo2Bytes(externcode);
	else	MapToLocal(externcode);
	return;
}

MapTo2Bytes(c)
char	c;
{
	int	rtn_no;

	switch (flag) {
	case	1:
		rtn_no = standard(c);
		break;
	case	2:
		rtn_no = retrieve(c);
		break;
	default:	/* case 0: */
		return;
	}
	if (rtn_no==2){
		CODE[1]= hzcode[0];
		CODE[2]= hzcode[1];
		drawcode(' ',hcc=0);
		SendMLCode(); 
	}
}

MapToLocal(ch)
char	ch;
{
	int	i;

	if (map_len>0)
		for (i=0;i<map_len ;i++)
			if (mapbuf[i++]==ch){
				ch = mapbuf[i];
				if (ch&0x80) CODE[1] = 0x81;
				break;
			}
	CODE[2] = ch | 0x80;
	SendMLCode(); 
}

RedrawDialog(widg,closure,event)
Widget	widg;
caddr_t closure;
XExposeEvent  *event;
{
	register  int	i;
	char	c,save[8];

	XClearWindow(CurDpy,dialogwin);
	for(i=0; save[i]=save_dialog[i] ; i++);
	for(i=0; c = save[i] ; i++)
		drawchar(c,i);
}

RedrawPrompt(widg,closure,event)
Widget	widg;
caddr_t closure;
XExposeEvent  *event;
{
	Drawstr(save_hanzi,0);
}

SendMLCode()
{
	ML_code  pass_data;

	pass_data.code[0]= CODE[0];
	pass_data.code[1]= CODE[1];
	pass_data.code[2]= CODE[2];
	pass_data.flag= (Window) 0; 
	XChangeProperty(CurDpy,root, hanzi_code, hanzi_type,8,PropModeReplace,
		(unsigned char *) &pass_data, sizeof(ML_code) );
}

MapInput(event)
XEvent	event;
{
	int	format,i,j;
	Atom	type;
	ML_code	*retdata;

	if (XGetWindowProperty(CurDpy,root, hanzi_code,0L,2L,
				 0,hanzi_type, &type,&format,&i,&j,&retdata)
		== Success && type == hanzi_type){
		if (retdata->flag)
			XMapWindow(CurDpy,CurWin);
	}
}


FKeyValue(keycode)
{
	switch (keycode) {
	case XK_F1:
		return(1);
	case XK_F2:
		return(2);
	case XK_F3:
		return(3);
	case XK_F4:
		return(4);
	case XK_F5:
		return(5);
	case XK_F6:
		return(6);
	case XK_F7:
		return(7);
	case XK_F8:
		return(8);
	case XK_F9:
		return(9);
	case XK_F10:
		return(10);
	case XK_F11:
		return(11-1);
	case XK_F12:
		return(12-1);
	case XK_F13:
		return(13-1);
	case XK_F14:
		return(14-1);
	case XK_F15:
		return(15-1);
	case XK_F16:
		return(16-1);
	case XK_F17:
		return(17-1);
	case XK_F18:
		return(18-1);
	case XK_F19:
		return(19-1);
	case XK_F20:
		return(20-1);
	default:
		return(0);
	}
}

