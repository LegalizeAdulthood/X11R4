	Ｗｎｎ  Ｖ４ について

Ｗｎｎのバージョン４について、バージョン３からの変更点を中心にまとめて
おきます。変更点は、主に、次の３つの領域に分けられます。

(1) 変換  
(2) 辞書  
(3) ライブラリ  

(1) 変換アルゴリズムの改良は、今回のバージョン・アップの中心課題でした。
これまで、Ｗｎｎでは、接頭語、接尾語、助数詞などに対する処理があまいこ
とが指摘されてきました。これを解決するために、今回のバージョンでは、大
文節という概念を導入し、接頭語、接尾語、助数詞などを、本体となる文節と
合わせて一つの大文節とみなして変換を行ないます。これについては、後で詳
しく述べます。

(2) 辞書に関しては、以下の点について変更されました。
    ●辞書の読みに、2 バイトコードを許す。 
    ●自立語の品詞の種類を増やす。
    ●ユーザ・形式、システム・形式の間の差違を、単語登録可能かどうか
の点だけに留める。(それに伴い、名前も、登録可能形式、固定形式とする。)
    ●辞書ファイル、頻度ファイルにパスワードを設ける事により、辞書、頻
度の更新が可能な人を制限する。それにより、辞書の大きさを問題にしなけれ
ば、登録可能形式のみを用いて辞書の管理を行なえるようにする。
    ●atou, atos, utoa, stoa というコマンドを、atod (テキスト to 辞書)、
dtoa (辞書 to テキスト) にまとめ、登録可能形式、固定形式の選択を、オプシ
ョンで行なう。
    ●変換方式の変更に伴う変更を、付属語ファイルにくわえる。
    ●付属語ファイルをクライアント毎に指定することを可能にする。    
    ●辞書の upload, download の機能を加える。

(3) 今までのライブラリは、サーバ内でクライアントの変換の状態を記憶し
ていたので、「連文節変換をする」、「ある文節の次候補を取る」、「文節の
区切りを切り直して変換を行なう」、「頻度の更新を行なう」といったプリミ
ティブで編集を行なってきました。しかし、これは、変換の流れを一つ固定し
ているため拡張性に乏しいと思われます。実際に、幾つかのアプリケーション
では、ここで提供している以外の操作を行なうために、このプリミティブの上
に新しいライブラリを独自に作って、それを用いています。しかし、ここで提
供しているプリミティブが一つの変換の流れを仮定した比較的高機能なもので
ある以上、どうしても無理が生じてきます。実際、頻度の更新が正確に行なわ
れないなどの障害が出てきています。

そこで、
  ●これらの操作を、よりプリミティブな操作である、「読みとなる文字列に
対して連文節変換を行ない第一候補を返す」、「読みとなる文字列に対して単
文節変換を行ない第一候補を返す」、「読みとなる文字列に対して単文節変換
を行ない全ての候補を返す」、「ある辞書エントリの頻度値をある値にセット
する」といった操作に分け、低レベル・ライブラリとして提供する。
  ●より高機能な操作は、高レベル・ライブラリとして、低レベル・ライブラ
リを用いて構成し、Ｃライブラリの形で提供する。そのライブラリと異なる操
作を行ないたい場合は、低レベル・ライブラリを用いて自分でライブラリを作
ることを可能にする。
という方針で、ライブラリを設計することにしました。

  また、変換に用いる辞書セット、付属語辞書、パラメーターなどの設定は、
クライアントごとに持つのではなく、サーバ内に「環境」というものを設け、
それに対して設定を行なうことにより、一つのクライアントが複数の環境を用
いたり、一つの環境を複数のクライアントが用いたりすることを可能にしまし
た。

  これらの変更により、サーバ内に、クライアントの変換の状態、辞書の状
態などを持つ必要がなくなり、サーバがステートレスになりました。

変換アルゴリズムの変更にともない、ライブラリの返す情報の構造は、V3 と
かなり異なっています。その点を含めて、低レベル、高レベル・ライブラリを
用いる時の注意点について、後にふれます。


１．変換アルゴリズム

V4 の変換アルゴリズムは、V3 の場合と同じく、文字列の最後から前に向かっ
て文節を切り出す作業が基本となります。その際、V3 では、文節の定義とし
て

	文節 := 自立語一つ + 付属語連鎖
	付属語連鎖 := 付属語*
	(ただし、自立語と付属語、付属語と付属語は接続条件を満たし、
	文節内で最後の語は、ある特定の品詞の集合(文節の最後に
	来ることのできる品詞の集合)に属している。)


という定義をもちいていました。ここで、自立語は、辞書ファイルのエントリで
あり、それぞれの自立語は、読み、自分の品詞、変換後文字列、それに頻度を
持っています。また、付属語は、付属語ファイルのエントリであり、読み、自
分の品詞、それに前にこれる品詞の集合(前端ベクトルと呼ばれる)を持ってい
ます。付属語どうしの接続関係、および、付属語と自立語の接続関係は、この
接続ベクトルによってチェックされます。付属語が漢字を持っていないことに
注意して下さい。付属語が漢字を持っていないことにより、付属語連鎖がどの
ような品詞の付属語から構成されているかという情報を持たなくていいので、
簡易で、高速な変換アルゴリズムを実現することができるのです。

  この解析では、接頭接尾語の処理、助数詞の処理は行なっていません。これ
らの語は、自立語として一文節を構成することにより処理されています。しか
し、接頭接尾語をこのように一文節として取り扱っていたのでは、誤変換が多
くなることは避けられません。例えば、人名につく接尾語「さん」より「三」
の方が評価値が高い時に、「こばやしさん」を変換すると「小林三」となると
いった誤変換が現れます。もし、「小林」が人名で、人名には「三」より「さ
ん」が優先的に付くという情報があれば、この種の誤変換は少なくすることが
可能だと考えられます。このような誤変換を少なくするには、文節の定義を拡
張するか、あるいは現在の方法を少し拡張し、文節間のつながり具合を見る方
法をとることが考えらます。Wnn Ver.4で採用した方法は、両者の折中案と言
えるものです。

  Wnn Ver.4では、「大文節」と「小文節」と呼ばれる、二つのレベルの文節
を考えます。「小文節」の定義は、Ver.3における「文節」の定義と同等であ
り、「大文節」は、小文節の列で、接続条件を満たすものと定義されます。

ここで、自立語、付属語と呼ばれているものは、我々が直感的に自立語、付属語
として理解して来たものと異なります。しかし、ここではこれらの名前を
流用する事にします。

	語 	:= 自立語 | 付属語
	小文節 	:= 自立語 + 付属語連鎖    
	大文節 	:= 小文節*              
	付属語連鎖 := 付属語*

(ただし、小文節内で、自立語と付属語、付属語と付属語は接続条件を満たし、
小文節内で最後の語は、後ろの小文節の自立語と接続条件を満たす。最後の小文
節の最後の語は、ある特定の品詞の集合(大文節の最後に来ることのできる品
詞の集合)に属している。最初の小文節の自立語は、ある特定の品詞の集合に属
している。)


(例) 小文節、大文節の例

第  ２  回の 			小 文節は
--  --  ---- 			-- ------
小  小   小  			小  小    
------------			---------
    大				    大	


	   約    １２３     グラムぐらいの	
	   --    ------     --------------
	   |	    |	     	|	
	   |        |      小(助数詞+付属語)
	  小        |     
	(接頭数詞) 小(数詞列)
	         
		
		お 食べ    下さい
		-- ----    ------
		小  小 	     小 
		------	   ------
		  大	     大

小文節同士の接続条件は、上で述べたように、後の小文節の自立語と前の小文節
の最後の語の間の接続条件として与えます。この情報は、それぞれの自立語毎に
持っていては情報量が大き過ぎるので、自立語品詞ごとに品詞の前端ベクトル
として持つものとします。自立語品詞の前端ベクトルは、辞書ではなく、付属語
ファイルに与えます。これらは、それぞれの辞書に固有なものではなく、付属
語間の接続情報と共に指定されるべきものだからです。この意味で、付属語ファ
イルという名前は不適切で、接続情報ファイルとでも名前を変えるべきかもし
れませんが、「付属語ファイル」のほうが馴染みがあって、付属語ファイルを
指定するライブラリ関数名でも、set_fuzoku という名前がわかりやすいので、
この名前を引続き使うものとします。辞書の持つ情報については、基本的に 
Ver 3 と変わっていません。

どれが小文節になるかは、付属語ファイルによります。上に挙げた例は、現在
使っている付属語ファイルによるものです。最後の例に対して、一つの大文節
になって欲しいと要望する人もいるでしょう。これからも、自然で正確な変換
を目指して、付属語ファイルの内容は書き換えられていくでしょう。

  今までの「文節」に当たるものは、この「大文節」です。この定義に従って
大文節を切り出した後は、基本的には、Ver.3 と同様な操作を行ないます。す
なわち、大文節を n 個切り出してきて、それらの評価値の和が最大なものの
最後の大文節を確定するという動作を、文字列の前端に来るまで繰り返すので
す。今まで文節の評価値を計算していたところが、「大文節」の評価値を計算
することになるのですが、パラメータの数は、Ｖｅｒ.3 よりずっと多くなり、
パラメータの定め方が結構大変で、四苦八苦しています。しかし、パラメータ
の定め方いかんで、かなり良い変換が得られそうです。

あと、変換に関して、細かい点が色々変わっていますが、そのなかでも
数字に対する変換が、面白いです。

たとえば、「2456」を変換すると、2456 が返ってきて、次候補として、

	2456  ２４５６  二四五六  二千四百五十六  ２，４５６
	2、456  弐阡四陌伍拾六

が返ってきます。ここで、二千四百五十六 を選択すると、次に 123 などの数
字を変換した時に、百二十三 が返ってくるという具合に、どの形式で以前選
択されたかを内部的に記憶しています。また、アスキ文字も、a を変換したら 
ａ も返ってくるという具合に、半角、全角間の変換をサポートしています。

(以前選択された値のセットは、頻度値の設定のライブラリで行ないます。)


２．辞書

  今までは、辞書に、読みとして許される文字の字種がかなり制限されていま
した。一方で、読みに任意の２バイトコードを許すようにすれば、漢字仮名変
換の可能性が出てきます。漢字仮名変換は、音声合成と組み合わせれば、文章
の「自動読みあげ」に応用できます。また、フリガナをつけたり、索引などを
読みの順にソートしたり、一度変換したものを再変換したり、あるいは、実際
に存在する文章からバッチ式に頻度を集めたり、応用範囲の広い技術です。
  Ver.4 では、読みを ２ バイトで扱っています。よって、読みの部分と漢字
の部分をひっくり返した辞書を作ることによって、漢字仮名変換を行なうこと
ができます。実際に漢字仮名変換に使ってみた結果では、かなりの正確さでで
変換されました。

  自立語品詞の種類は、今まで 32 個に制限されていましたが、これは、256 
まで拡張されました。それに加えて、複合品詞をほぼ無制限に定義することが
できます。自立語の品詞は、サーバが用いるだけではなく、辞書を作る時、
辞書をテキストに戻す時、あるいは、クライアントの単語登録の時など、色々
なプログラムで共有する情報です。付属語ファイルを書くためには、新しい自
立語品詞が必要になることが多々あるでしょう。かといって、勝手に書き換え
られては困るものです。ユーザごとに持てるようにすればいいかも知れませ
んが、辞書を用いる時に、異なる品詞情報を元に作られた辞書を混ぜて使うこ
とはできないため、かえって混乱をきたすことになります。そこで、「品詞ファ
イル」を一つだけ用意して、そのファイルに対しては、エントリの追加は認
めるが、削除、並べ変えは認めないことにしました。品詞ファイルは、以下の
ように、品詞、複合品詞の情報を書き並べた単純な構造をしています。

....
....
名詞		
人名		
地名		
人地名/人名:地名	;人名, 地名
....
....


jserver を複数動かす事、あるいは、辞書や付属語ファイルを異なるサイト間
で勝手に書き換えていくことを考えると、品詞ファイルの管理は、一つの課題
となってきそうです。なお、品詞ファイルの情報はコネクションを張った時に、
jserver からクライアントプログラムへダウン・ロードされてくるので、クラ
イアントプログラムから品詞ファイルが直接見える必要はありません。クライ
アント・プログラムからこの情報にアクセスするライブラリが存在します。

  今までは、ユーザ形式、システム形式の２種類の辞書を用いていました。
前者は、単語登録可能だけど、頻度ファイルを外部に持つことができない形式
で、後者は、単語登録はできないけれど、頻度ファイルを外部に持つことがで
き、同じ語数の場合、辞書を小さく作ることができる形式でした。しかし、ユー
ザー形式の辞書が頻度ファイルを外部に持つことを可能にするのは技術的に決
して難しい問題ではなく、そうすることにより、辞書の大きさが比較的問題に
ならないサイトでは、辞書の形式としては１種類で済むようになります。そこ
で、Ver.4 では、今までユーザ形式の辞書と呼ばれていたものに対して、頻
度ファイルを外部に持つことを許しました。

  こうなると、ユーザ形式、システム形式という名前は不適切です。そこで、
今までユーザ形式と呼ばれていたものは登録可能形式、システム形式と呼ば
れていたものは固定形式と名前を改めました。ユーザ形式の辞書が広く使わ
れることを考え、辞書の内部形式も、辞書を引くのが早くなるような変更を加
えてあります。また、今まで存在した語数などに対する制限はほとんどありません。
ただ、漢字文字列が(外部UJISで)255バイト以内という制限は残っています。

辞書の大きさは、今までとほとんど変わっていないと思います。

辞書	kihon_1  語数 		59,717
	
	テキスト形式		1,567,388
	旧ユーザ形式		1,783,214
	旧システム形式		  956,294
	登録可能形式		1,735,680
	固定形式		1,190,742


  登録可能形式の辞書を皆で共有することにより、辞書の内容に「バグ」があっ
た時に、動的にバグを修正することができます。今までだと、一旦テキスト形
式に直して、バグを直して、それを再びインストールするという手続きを踏ま
なくてはならず、面倒なばかりか、それをすると、今まで個人が持っていた頻
度ファイルがすべて使えなくなるという非常に不便な状態にあったわけです。

  ただ、辞書の品質を保つためには、誰でも単語の登録、削除が行なえるので
は問題があります。そこで、辞書にパスワードをつけることにしました。これ
によって、辞書のメンテナンスをする以外の人が、間違って、あるいは悪意的
に辞書を書き換えるということを防ぐことができます。このパスワードは、辞
書を書き換えるのを防ぐだけで、辞書を変換に用いることを制限するものでは
ありません。
  もちろん、個々のユーザが自分の辞書にパスワードをつけて用いることも
可能です。その時、辞書を使う度にパスワードを打ち込むのではやっていられ
ません。そこで、高レベル・ライブラリでは、初期化ファイルの辞書指定のと
ころでパスワードの入っているファイル名を指定することにより、ライブラリ
がそのファイルを読んで、パスワードをサーバに送るようになっています。
後は、UNIX ファイルシステムの read permission でパスワードの入ったファ
イルを保護すれば良いのです。辞書と同様に、頻度ファイルもパスワードを付
けられるようになっています。

  Ｗｎｎでは、頻度ファイルの他に、辞書の内部にも、頻度情報を一組持って
います。この頻度情報は、旧バージョンでは、ユーザ形式辞書では頻度として、
システム形式辞書では、頻度ファイルを作る時の初期値として用いられていま
した。すなわち、新しく頻度ファイルを作った時には、辞書内の頻度部分の内
容をコピーして、頻度の初期値としていました。しかし、これでは、後で頻度
を集めてテキスト形式の辞書に戻そうとした時に、頻度値の集計が難しくなり
ます。また、頻度値として、もともとの値と自分が使った値と別々に見たいと
いう要求もあるでしょう。そこで、Ver.4 では、頻度ファイルを新しく作った
時には、すべての項目の頻度値が ０ であるような頻度ファイルを作り、頻度
値として、辞書内の頻度値と頻度ファイルの頻度値を足したものを用いること
にします。
  自分一人しか使わない辞書の場合、頻度ファイルを辞書の外部に作るのは無
駄です。また、複数の人で同じ頻度を用いる場合にも、頻度は辞書内にあった
方がいいでしょう。そういうわけで、頻度ファイルを指定せずに辞書を用いる
と、辞書内の頻度を用い、それを更新していきます。ですから、pubdic など
で集計した頻度を、元となる頻度として反映する場合に、個々のユーザの頻度
ファイルを作り直さなくても、辞書内頻度を新しい値にセットし直してやれば、
いいことになります。一つの辞書に対して、辞書外に頻度ファイルを作って使
用するという使用法と、辞書内の頻度を用いるという使用法を併用するのは、
一般には望ましい使い方ではありません。そのようなことを防ぐために、辞書
の頻度部分にもパスワードをつけることが可能になっています。それによって、
(パスワードが一致しない場合、)頻度ファイルを指定せずに、頻度を更新する
モードでその辞書を使用する事が不可能になります。

誰にも使うことのできないパスワード(atod の時に付ける事が出来ます)が辞
書本体、辞書頻度部分についている場合、

  辞書本体	辞書頻度部分	

  パスワード有	パスワード有     頻度ファイルを用い、登録不能
  パスワード無	パスワード有     頻度ファイルを用い、誰でも登録可能
  パスワード有	パスワード無     頻度は共有、登録はできない
  パスワード無	パスワード無     頻度は共有、誰でも登録可能

といったところでしょうか。もちろん、頻度部分にパスワードがついてなくて
も、頻度ファイルを辞書外部に作って辞書を用いることは可能ですし、パスワー
ドの無い辞書でも、今までとおり、辞書本体、あるいは頻度部分をリード・オ
ンリーで用いることもできます。

  頻度については、新しく、頻度値を用いてエントリの一時的削除を行なうこ
とを可能にしました。すなわち、頻度値をある値にセットすれば、そのエント
リーは、変換の時に用いられないというものです。このある値は、ライブラリ
では(実頻度) -1(WNN_ENTRY_NO_USE) になっています。頻度ファイルを指定し
ていない場合には、辞書内頻度値がこの値ならば、また、指定している場合に
は、頻度ファイル値もしくは辞書内頻度値のどちらかがこの値ならば、そのエ
ントリは、一時削除されたことになります。これによって、皆で共有して使用
している辞書に自分にとって不適当な単語が存在している場合に、それを変換
の対象から除外することができます。テキスト形式では、削除されたエントリ
は頻度の部分が "-" で示されます。テキスト形式で、エントリを消す時に、
コメントアウトなどの方法で実際に消してしまうと、atod で辞書を作ってそ
れを dtoa で再びテキストに戻した時に、エントリーが消えてしまいます。頻
度部分を "-" にする事により消したエントリは、実際に消えたわけではあり
ませんから、辞書の内容を編集する時に、便利です。高レベル・ライブラリで
は、エントリの一時削除のためのライブラリ関数が用意されています。

  Ver.4 では、辞書にコメントを付けることが出来るようになっています。
(コメントというより、ニックネームと言った方がいいかも知れません）uumで
は、これを、単語登録などの時の辞書名の指定に用いるようにしています。
usr/pubdic/pd-chimei といった辞書名を見ながら登録する辞書を選ぶよりも、
「地名辞書」といったニックネームを見ながら登録する辞書を選べた方が便利
なのは、理解していただけるでしょう。

また、コメントは、各辞書エントリにつけることも可能となっています。これ
は、テキスト形式に直して辞書を編集する時も見えますので、辞書の編集時に
便利だと思われます。

辞書のパスワード、コメントなどは辞書の作成時に指定しますが、すでに存在
する辞書に対して、これらの部分を書き換えるコマンドが用意されています。
これは、今のところ、ｇｍｗ上で動くように作ってありますが、普通の端末用
のものもこれから作る必要があるでしょう。

  いままで atou, atos, utoa, stoa と呼ばれていたコマンドは、atod (テキ
スト to 辞書)、dtoa (辞書 to テキスト) の二つにまとめられています。登
録可能形式、固定形式の選択は、atod のオプションで行ないます。

  辞書のテキスト形式に対しても、見やすさの観点から変更が加えられていま
す。品詞は数字ではなく、品詞名が現れます。頻度値として、圧縮された値で
はなく、実際の使用頻度(に近い値）が出されます。atod を行なう時に辞書を
ソートし直すので、テキスト形式の辞書を作成する時には、辞書項目はどのよ
うな順でも構いません。これにより、テキスト形式の辞書の編集がしやすくな
ります。dtoa は、読みの順にソートされた形で出力します。

  付属語ファイルは、ｊｓｅｒｖｅｒ 内に一つ存在するのではなく、環境毎に
設定できるようになりました。環境については、ライブラリの項を参照して下さい。

変換方式の変更にともない、付属語ファイルの内容、および、ａｔｏｆコマ
ンドも変更を受けています。このことについては、ここでは省略します。

  辞書をクライアントからｕｐｌｏａｄする機能が付け加えられます。これ
は、まだ、サポートされていません。正式バージョンには間に合わせる予定で
す。



３． ライブラリ  

Ver.4 では、ライブラリとして、jserver との通信と基本的に１対１に対応し
ている低レベル(ｊｓ)ライブラリと、ｊｓライブラリを用いて作られた、高レベ
ル(ｊｌ)ライブラリがあります。

低レベル・ライブラリは、細かいプリミティブから構成され、高レベル・ライ
ブラリは、仮名漢字変換の流れに沿った高レベルの処理を実現しています。例
えば、変換に関しては、ｊｓライブラリでは、
	読みに対して、連文節変換をした第一候補を返す(kanren)
	読みに対して、単文節変換をした第一候補を返す(kantan_dai, kantan_sho)
	読みに対して、単文節変換をした全候補を返す  (kanzen_dai, kanzen_sho)
	あるエントリの頻度値をある値にセットする(hindo_set)
といった関数が基本となります。

これに対して、ｊｌライブラリは、変換の履歴を文節の列として持っており、
	読みを与えて、連文節変換をする(ren_conv)
	文節の区切りを変えて変換し直す(nobi_conv)
	ある文節の次候補を返す。(zenkouho, zenkouho_dai)
	(変換の履歴に基づいて)頻度値の更新を行なう(update_hindo)
といった関数が基本となります。

低レベル・ライブラリの関数は、js_ ではじまる名前を持っており、高レベル・
ライブラリの関数は、jl_ ではじまる名前を持っています。ここでは、まず、
低レベル・ライブラリについて説明し、その後に、高レベル・ライブラリにつ
いて説明します。


３．１　低レベル・ライブラリ

まず、低レベル・ライブラリにおいて使用される以下の概念について、まとめ
ておきます。

	クライアント
	環境
	ファイル
	辞書Ｎｏ．

●クライアント
  jserver と通信路を持つアプリケーション・プログラムのことをクライアン
トと呼びます。複数の計算機上で jserver が動いている時に、一つのプログ
ラムは、複数の jserver のクライアントに同時になることが出来ます。

●環境
  仮名漢字変換の実行結果は、使用する辞書と頻度ファイル、使用する付属語
ファイル、あるいは、変換パラメータの設定といったものによって、変わって
きます。これらの設定は、jserver 内に「環境」と呼ばれるものを作り、それ
に対して行ないます。そして、変換の操作は、引数として読みの文字列と共に、
環境を指定して行ないます。
  一つのクライアントは、jserver 内に複数の環境を作り、変換の度に異なる
環境を用いることができます。また、一つの環境を複数のクライアント間で共
有することも可能です。その時には、その環境に対する辞書追加などの操作は、
その環境を使用している他のクライアントにも反映されます。

  環境は jserver 内に作られるものですが、js_ライブラリでは、jserver id 
と その jserver 内の環境の idのペアを環境としています。ですから、環境
の指定は、変換を行なう jserver の指定を含んでいます。

●ファイル
  Wnn においては、辞書ファイルなどのファイルを jserver 内に読み込む動
作と、ファイルを辞書として用いるなどといったファイルの使用を開始する動
作は、区別されています。それは、jserver が用いるファイルには、辞書ファ
イル、頻度ファイル、付属語ファイルといった種類があり、種類ごとに使用方
法は異なるのですが、ファイルとしての動作(メモリ上への読み込み、書きだ
し、使用されていないファイルをメモリ上から捨てる)は、どの種類のファイ
ルであっても共通だからです。特に、ファイルの読み込み、書き出しに関して
は、jserver が直接行う場合と、クライアントが読み込んで jserver に送信
する(あるいは、逆に、jserver から受信してクライアントのファイルシステ
ムに書き込む)場合があります。クライアントのローカルからの送信か、サー
バーのファイルシステムからの読み込みかをファイルの種類ごとに、ファイル
の使用開始時に指定するのより、ファイルの読み込み、送信を一つのプリミティ
ブとした方が明確だろうという趣旨です。

高水準ライブラリでは、ファイルの作成と読み込みと使用を一つにまとめたラ
イブラリ関数群が用意されています。

●辞書Ｎｏ．
  辞書は、頻度ファイルを指定して使用することも、指定せずに使用すること
もできます。ですから、環境にセットするのは、辞書と頻度ファイルの組、ま
たは、辞書だけです。環境に辞書をセットする事によって ID が返されますが、
この ID を 辞書Ｎｏ．と呼びます。
  辞書Ｎｏ．に付随する情報として、辞書ファイル、頻度ファイルの他に、辞書
のプライオリティ、辞書のenable/disable、辞書、頻度の書き込み許可の情報
があります。

＃簡単な例を通した低レベル・ライブラリの説明

以下、かな漢字変換、及び、漢字かな変換を行なう簡単なプログラムを例とし
て、低レベル・ライブラリの使い方を説明します。

-------------------------------------------------
#include <stdio.h>
#include "jslib.h"

#define FZK_FILE "/usr3/tachi/pubdic/v4/fzk.data"
#define REV_DIC "/usr3/proj/Wnn/dic/rev-pd-kihon"
#define REV_DIC_SETTO "/usr3/proj/Wnn/dic/rev-pd-setsuji"
#define KIHON_DIC "/usr3/tachi/pubdic/v4/pd-kihon.usr"
#define SETTO_DIC "/usr3/tachi/pubdic/v4/pd-setsuji.usr"

WNN_JSERVER_ID	*js;
struct wnn_env *env, *rev_env;
static struct wnn_ret_buf rb = {0, NULL};

int	dcnt,scnt;

char yomi[1024];
char kanji[5000];

int kihon_file, setto_file, rev_file, fzk_file, rev_setto_file;
int kihon_dic_no, setto_dic_no, rev_dic_no, rev_setto_dic_no;

main()
{
    rb.buf = (char *)malloc((unsigned)(rb.size = 0));
    if((js=js_open("hewey")) == NULL) err();

    if((env=js_connect(js, "kana")) == NULL) err(); 
    if((fzk_file = js_file_read(env,FZK_FILE)) == -1) err();
    if((kihon_file = js_file_read(env,KIHON_DIC)) == -1) err();
    if((setto_file = js_file_read(env,SETTO_DIC)) == -1) err();

    if(js_fuzokugo_set(env,fzk_file) == -1) err();
    if((kihon_dic_no = js_dic_add(env,kihon_file,-1,1,WNN_DIC_RDONLY, WNN_DIC_RDONLY, NULL, NULL)) == -1) err();
    if((setto_dic_no=js_dic_add(env,setto_file,-1,1,WNN_DIC_RDONLY, WNN_DIC_RDONLY, NULL, NULL)) == -1) err();
    p_set(env);

    if((rev_env=js_connect(js, "kanji")) == NULL) err();

    if((fzk_file = js_file_read(rev_env,FZK_FILE)) == -1) err();
    if((rev_file = js_file_read(rev_env,REV_DIC)) == -1) err();
    if((rev_setto_file = js_file_read(rev_env,REV_DIC_SETTO)) == -1) err();

    if(js_fuzokugo_set(rev_env,fzk_file) == -1) err();
    if((rev_dic_no = js_dic_add(rev_env,rev_file,-1,1,WNN_DIC_RDONLY, WNN_DIC_RDONLY, NULL, NULL)) == -1) err();
    if((rev_setto_dic_no = js_dic_add(rev_env,rev_setto_file,-1,1,WNN_DIC_RDONLY, WNN_DIC_RDONLY, NULL, NULL)) == -1) err();
    p_set(rev_env);

    henkan();
    js_close(js);	
}

henkan()
{
    wchar u[1024];
    struct wnn_env *c_env = env;
    struct wnn_dai_bunsetsu *dp;

    for(;;){
	if(c_env == env){printf("yomi> ");fflush(stdout);}
	else {printf("kanji> ");fflush(stdout);}
	if(gets(yomi) == NULL)return;
	if(yomi[0] == '@'){
	    c_env = (c_env == env)? rev_env:env;
	    continue;
	}
	strtows(u,yomi);
	dcnt =js_kanren(c_env,u,WNN_BUN_SENTOU, NULL, WNN_VECT_KANREN, &rb);
	dp = (struct wnn_dai_bunsetsu *)rb.buf;
	print_kanji(dp,dcnt );
    }
}

print_kanji(dlist, cnt)
struct wnn_dai_bunsetsu	*dlist;
int	cnt;
{
    int i;
    struct wnn_sho_bunsetsu  *sbn;

    if (dlist == 0) return;
    putchar('\n');
    for ( ; cnt > 0; dlist++, cnt --) {
	sbn = dlist->sbn;
	for (i = dlist->sbncnt; i > 0; i--) {
	    putws(sbn->kanji); printf("-"); 
	    putws(sbn->fuzoku); printf(" ");
	    sbn++;
	}
	printf("|"); 
    }
    putchar('\n');
    fflush(stdout);
}

p_set(env1)
struct wnn_env *env1;
{
struct wnn_param pa;
	pa.n= 2;		/* n_bun */
	pa.nsho = 10;	/* nshobun */
	pa.p1 = 2;	/* hindoval */
	pa.p2 = 50;	/* lenval */
	pa.p3 = 1;	/* jirival */
	pa.p4 = 128;	/* flagval */
	pa.p5 = 5;	/* jishoval */
	pa.p6 = 1;	/* sbn_val */
	pa.p7 = 50;	/* dbn_len_val */
	pa.p8 = -20;	/* sbn_cnt_val */
	pa.p9 = 0;	/* kan_len_val */

 js_param_set(env1,&pa);
}


putwchar(x)
unsigned short x;
{
    putchar( x >> 8);
    putchar( x );
}

putws(s)
unsigned short *s;
{
    while(*s) putwchar(*s++);
}

strtows(u,e)
wchar *u;
unsigned char *e;
{int x;
 for(;*e;){
	x= *e++;
	if(x & 0x80) x = (x << 8)  | *e++;
	*u++= x;
 }
 *u=0;
}

err()
{
    printf(wnn_perror());
    printf("\n bye.\n");
    exit(1);
}

このプログラムの実行例を示しておきます。

% kankana
yomi> だいぶんせつは、しょうぶんせつのれつで、せつぞくじょうけんをみたすものと
ていぎされます。

大- 文節-は、 |小- 文節-の |列-で、 |接続- |条件-を |満た-す |もの-と |定義-さ
れます。 |
yomi> このぷろぐらむのじっこうれいをしめしておきます。

この- |プログラム-の |実行- 例-を |示-しておきます。 |
yomi> !

kanji> 大文節は、小文節の列で、接続条件を満たすものと定義されます。

おお- ぶんせつ-は、 |こ- ぶんせつ-の |れつ-で、 |せつぞく- |じょうけん-を |み
た-す |もの-と |ていぎ-されます。 |
kanji> このプログラムの実行例を示しておきます。

この- |ぷろぐらむ-の |じっこう- れい-を |しめ-しておきます。 |
> ^D

-------------------------------------------------
プログラムの説明

このプログラムを用いで、低レベル・ライブラリの使い方について説明します。

#include "jslib.h"

include/jslib.h には、ｊｓライブラリで用いる構造体、マクロなどの定義が
なされています。ライブラリで提供する関数名、構造体名、マクロ名は、
"js_*" または、"wnn_*" (高レベル・ライブラリでは "jl_") という名前をつ
けていますので、名前の衝突が起こらないように注意して下さい。

static struct wnn_ret_buf rb = {0, NULL};

    rb.buf = (char *)malloc((unsigned)(rb.size = 0));

今までのライブラリでは、変換などの変値を入れる領域は、ライブラリを呼ぶ
側で用意し、その領域に入り切らない場合には、エラーになりました。一般に、
ライブラリを用いる側で、どれだけの領域が必要かはわからないので、大きな
問題となります。そこで、Ver.4 では、必要があれば、ライブラリの側で
reallocを行なうという仕様になっています。不定長の変値を返す関数は、
(struct wnn_ret_buf *) の引数を取ります。このポインタの先には、malloc 
または realloc で取られた領域と、その大きさのペアが与えられる必要があ
ります。

    if((js=js_open("hewey")) == NULL) err();

この一行で、jserver との通信路を設立し、jserver のクライアントになりま
す。"hewey" というのは、jserver の存在する計算機名です。計算機名として
ヌル・ストリングが与えられた時には、UNIX ドメインの通信を行ないます。
js_open は、返値として、jserver_id を返します。この通信路は、js_close 
をによって明示的に切断するか、プログラムが終了するまで有効です。

    if((env=js_connect(js, "kana")) == NULL) err(); 

次に、js_connect により、環境を jserver 内に作ります。どの jserver 内
に環境を作るかは、引数で jserver_id を渡すことにより指定します。
"kana" は、環境名です。js_connect は、同じ環境名を持つ環境が jserver 
内存在する時にはその id を返しそれ以外の時には新しく環境を jserver 内
に作り、その id を返します。環境名は、複数のプロセスで一つの環境を共有
するために用います。すなわち、他のプロセスが同じく "kana" という環境名
を引数としてjs_connect を呼んだ場合、そのとき得られる環境は、ここで
作られたものと同じです。他のプロセスと共有することの無い環境(間違って、
共有されたくない環境)を作りたい場合がありますが、その場合には、第一引
き数として空文字列を渡してやります。それにより、jserver は常に新しい環
境を作り、それを返します。その場合、返されてきた環境が、共有されること
はありません。

環境の使用を終るには、js_disconnect を用います。また、通信路が閉じられ
た時には自動的に環境の使用を終えます。環境は、その環境を用いているクラ
イアントがなくなった時に、jserver 内からなくなります。以下のライブラリ
関数では環境を引数としたものが多く存在しますが、それらの環境は、
js_connect でそのプロセスが受け取ったものである必要があります。それは、
他のプロセスに勝手に環境に対してアクセスされることを防ぐためです。

    if((fzk_file = js_file_read(env,FZK_FILE)) == -1) err();
    if((kihon_file = js_file_read(env,KIHON_DIC)) == -1) err();
    if((setto_file = js_file_read(env,SETTO_DIC)) == -1) err();

ここで、付属語ファイル、および辞書を jserver に読み込んでいます。
js_file_read は、そのファイルが jserver 内に存在しない時には、ファイル 
jserver 内に読み込みその Fid(ファイル ID) を返し、jserver 内に既に存在
している時にはその id を返します。また、js_file_send は、クライアント・
サイトのファイルを読み込むのに使用します。jserver は、ファイルの同一性
のチェックを厳密に行なっていますので、クライアントとサーバから同一のファ
イルを読み込んだとしても、同一のファイルがメモリー上に二つ以上存在する
ことはありません。js_file_read, js_file_send を行なうことにより、ファ
イルは環境に接続されます。Fid は、jserver 内でユニークに存在するもので
すが、そのファイルに対してアクセスするためには、ファイルが接続された環
境を持っている必要があります。js_file_send, js_file_receive は、現在の
バージョンでは、まだサポートされていません。

jserver のサイト上のパス名の指定は、フルパスで指定するか、JSERVER_DIR 
と呼ばれるディレクトリからの相対で指定するかします。JSERVER_DIR は、
jserverrc の中で指定されています。

  jserver 内に読み込まれたファイルは、js_file_discard によって、環境か
ら切り離されます。また、環境が先に消滅すれば、自動的にその環境から切り
離されます。そして、ファイルに対して接続している環境が無くなった時、そ
のファイルは jserver 内から消滅します。ファイルによっては、jserver が
読み込んでいる間に内容が更新されているため、その更新された内容をファイ
ル・システムに書き戻す必要が出てきます。それを行なうのが、js_file_write,
js_file_receive です。

  この他に、ファイルに関するライブラリとしては、js_file_list (環境に接
続されているファイルの情報一覧を得る)、js_file_list_all (jserver に読
み込まれているファイルの情報一覧を得る)、js_file_info (特定のファイル
についての情報を得る。)があります。

また、アプリケーションを書くためには、jserver のあるサイトのファイル・
システムに関する情報を得る必要が生じてきます。そのために、jserver サイ
ト上でのパス名を引数として取るライブラリとして

js_access	指定されたファイルの(jserver に対する)アクセス権を調べる。

js_file_stat	指定されたファイルの内容(辞書、頻度ファイル。付属語ファイル
		の別、ファイルに付けられているコメント)を得る
		
js_file_loaded	指定されたパス名のファイルが jserver 内に
		読み込まれているかどうか調べる。

ファイルシステムに関して、始めてアプリケーションを使う人のためのユーザ
辞書や頻度ファイルを作る必要があります。そのためのライブラリとして、

js_mkdir	指定された名前のディレクトリを作る。
		相対パスは、JSERVER_DIR からの相対で指定する。
		指定されたところにどこでも作ってしまうので、
		jserver に強い権限を与えてはいけない。
		(root で走らすなどもってのほか。)

js_hindo_file_create
		指定されたファイル id を持ったファイルの頻度ファイルを
		指定されたパス名で作る。

js_dic_file_create
		指定された名前で、語数 0 の登録可能形式の辞書を作る。

js_file_remove	Wnn のファイルをファイルシステムから消す。


があります。このなかで、js_hindo_file_create, js_dic_file_createは、
jserver のサイトに作るのか、クライアント・サイトに作るのか、引数で指
定することができます。(クライアント・サイトはまだサポートされていない)

    if(js_fuzokugo_set(env,fzk_file) == -1) err();

これは、fzk_file という file_id で示されたファイルを env の付属語ファ
イルとして設定しています。環境が js_connect で作られた時には、その環境
の付属語ファイルとしては、デフォルトの付属語ファイルが設定されています。
デフォルトの付属語ファイルは、jserverrc の中で指定してあります。

    if((kihon_dic_no = js_dic_add(env,kihon_file,-1,1,1,-1,NULL, NULL)) == -1) err();
    if((setto_dic_no=js_dic_add(env,setto_file,-1,1,0,0,-1,NULL, NULL)) == -1) err();

  これは、kihon_file, setto_file という file_id で示されたファイルを 
envの辞書として設定しています。

	js_dicadd(env, file_id, hfile_id, prio,
		rdonly, hrdonly, passwd_file, passwd_hfile)

によって、file_id で示され
たファイルを、hfile_id で示されたファイルを頻度ファイルとし、prio で示
された優先度で、辞書、頻度がそれぞれ rdonly, hrdonly で示された状態で 
env に追加することを意味しています。頻度情報として辞書ファイルの内部に
もつものを使用する場合には、第三引数で -1 を設定します。また、rdonly 
は WNN_DIC_RW の時、読み書き可能、WNN_DIC_RDONLY の時更新不能を意味し
ています。また、辞書には、パスワードがついていることがあります(参照)。
パスワードつきの辞書、頻度を、リード・オンリーでない状態で用いたい時に
は、それぞれのファイルのパスワードを第八、第九引数として与える必要が
あります。dic_add は、返値として、辞書Ｎｏ．を返します。それ以降の辞書、
頻度ファイル関する操作は、この dic_No を用いて行ないます。付属語ファイ
ルは環境に対して一つ存在するものですが、辞書は、一つの環境に複数設定し
てそれら全てを変換に用います。ここでは、二つの辞書を設定しています。

環境に設定されている 辞書Ｎｏ．に関する情報を得るライブラリとして、
js_dic_list があります。また、辞書Ｎｏ．を環境から無くさずに、一時的に無
効にするためのライブラリ (js_dic_use)があります。

  辞書Ｎｏ．を環境から外すには、js_dic_del を用います。

  環境に対する設定としては、辞書、付属語ファイルの他に、変換パラメーター
があります。変換パラメータに関しては、js_param_set によって設定を行な
い、js_param_get によって現在の設定の状態を得ます。変換パラメータに関
しても、デフォルト値が jserverrc に書かれていて、環境が js_connect で
作られた時には、その設定が用いられます。

    if((rev_env=js_connect(js, "kanji")) == NULL) err();
    if((fzk_file = js_file_read(rev_env,FZK_FILE)) == -1) err();
    if((rev_file = js_file_read(rev_env,REV_DIC)) == -1) err();
    if((rev_setto_file = js_file_read(rev_env,REV_DIC_SETTO)) == -1) err();

    if(js_fuzokugo_set(rev_env,fzk_file) == -1) err();
    if((rev_dic_no = js_dic_add(rev_env,rev_file,-1,1,WNN_DIC_RDONLY, WNN_DIC_RDONLY, NULL, NULL)) == -1) err();
    if((rev_setto_dic_no = js_dic_add(rev_env,rev_setto_file,-1,1,WNN_DIC_RDONLY, WNN_DIC_RDONLY, NULL, NULL)) == -1) err();


上記のかな漢字変換用の環境とは別に、もう一つ、漢字かな変換用の環境を作
り、それに対して設定を行なっています。ここで、fzk_fileとしては、同じファ
イルIDが返ってくるはずですが、fzk_file に関係するfile_read を再度行なっ
ていることに注意して下さい。先程述べたように、その環境に対して
file_readを先に行なっていないと、そのファイルがその環境で使えないからです。

    henkan();

henkan の中身は、御覧のように、読み文字列を得て、内部 UJIS コードに変
換して、仮名漢字変換を行ない、結果を表示するというものです。jserver と
の通信は、日本語のコードとして、全て内部 UJIS を用いて行ないます。

dcnt =js_kanren(c_env,u,WNN_BUN_SENTOU, NULL, WNN_VECT_KANREN, &rb);

これは、連文節変換を行なうライブラリ関数です。先に説明した通り、変換
の関数は、全て、環境(c_env)と、読み(u), 結果を入れる領域へのポインタ
(&rb)を引数として持ちます。後の３つの引数は、変換結果に影響を与える
パラメータとなるものです。
第３、４引数は、変換文字列の先頭に関する設定、
第５引数は、変換文字列の終端に関する設定です。

前にも述べたように、Ver.4 では、大文節と小文節を扱います。連文節変換で
は、変換の結果返してくるものは大文節の列ですが、指定の仕方によっては、
先頭の大文節および最後の大文節は、完全な大文節ではなく、大文節の部分を
返させることが可能です。それによって、前端と終端に接続条件の制約を
与えて変換を行なうことができます。

具体的には、前端の設定については、ある小文節の自立語の品詞と付属語列を第
3、第4引数で指定することにより、先頭の大文節として、その小文節とつながっ
て大文節を構成する小文節列を得ることができます。前端の設定を行わない時
には、WNN_BUN_SENTOU を第３引数として指定すれば、前端が大文節の前端と
なるように変換を行います。WNN_ALL_HINSI を第３引数として指定すれば、
前端が小文節の前端となるように変換を行います。この場合には、先頭の大文
節は擬似的なものとなります。


終端の設定については、ベクトル(品詞の集合)の番号を第５引数に指定するこ
とにより、最後の大文節として、そのベクトルを終端ベクトルとして解析した
結果を返します。ベクトルとしては、jslib.h で define されている ３つの
ベクトル、WNN_VECT_KANREN、WNN_VECT_KANTAN、WNN_VECT_KANZEN、および、 
解析結果としてかえされる、各小文節の前端ベクトル(前につながることので
きる小文節の最後の品詞) を用います。これらのベクトルの内容は、付属語ファ
イルで指定されます。

具体的に、この機構がどのように使われるかを説明します。
各[i]を小文節とし、‖ を大文節の区切りとします。最初の変換で、

‖[1][2][3]‖[4]‖[5]‖[6][7]‖[8][9]‖

という結果が得られたとします。ここで、[1],[2],および、[7]以降は正しく
変換されていて、[3] から [6] は読みを入れ間違えたために誤変換が起こっ
ているとします。これに対して、[3] から [6] までの文節を解除して読みを
直して変換し直したいとします。その時、[2] の文節の情報を第3、4引数とし
て与え、[7]の小文節の前端ベクトルを第5引数として与え、[3] から [6] ま
での読みを与えることによって、例えば

	[3']‖[4'][5']‖[6']

といった文節列で、[3'] は [1],[2] とつながって大文節を構成し、[6'] は 
[7]とつながって大文節を構成するような変換結果が得られます。高レベル・
ライブラリは、前後の指定を自分で行なわなくても、このような変換が行え
るように作られています。

最後の大文節以外の大文節の終端ベクトルは、WNN_VECT_KANREN が用いられま
す。

前端の接続条件を指定して変換を行った時に、その接続条件を満たすものが無
い場合には、そこが大文節の先頭となるような結果を返します。それも存在し
ない場合には、そこが小文節の先頭となるものを返します。この場合には、返
してくるものは、擬似的な大文節です。

それぞれの小文節は、その status として、前への接続状況を持っています。
status がWNN_CONNECT ならば、前の小文節に接続している、
WNN_SENTOU なら、大文節の先頭である。
WNN_NOT_CONNECT なら、大文節の先頭でもないし、前に接続もしない??? (意味不明)
WNN_GIJI なら、擬似小文節です。

この、接続状況の設定は、大文節というものを考える限り必要ではありますが、
中々難しい所です。特に、

	●前に接続する文節の評価方法をどうするか。
	●終端ベクトルとして、「あるものにつながる文節があればそれを優先し、
	無ければデフォルトの終端ベクトルを用いて変換を行う」
	という指定が出来ないものか。

ということを、現在議論中です。

現在の所、前者の問題に付いては、前に接続する文節列は、評価値を２倍とし
て評価を進めることにより、優先して出されるようにし、大文節の先頭となら
ない小文節を先頭として解析が終了した時には、その文節列の評価値を１／２
にして、大文節の先頭となるものが優先されるようにしています。ただし、前
端条件として WNN_BUN_SENTOU を指定して変換した時には、前者の処理は行わ
ず、WNN_ALL_HINSI を指定して変換した時には、両方の処理を行いません。

  将来的には、変換の時に、前の小文節列の評価値も送ってやって、それを元に、
前に接続する文節列の評価値を決めるようにする方向に議論が進んでいるよう
です。
  また、終端に付いても、最後の文節だけは付属語解析を2回行い、終端ベク
トルだけではなく、その後ろの文節列の評価値も送ってやることにより、公平
な変換が行われるのではないかという方向になってきています。

変換に付いては、js_kanren の他に、kantan, kanzen がありますが、これら
も前端、終端の接続条件を指定して変換を行います。

kantan, kanzen については、kantan_dai, kantan_syo 、kanzen_dai,
kanzen_syo という区別があります。kantan_sho, kanzen_sho は、与えられた
文字列が一つの小文節を成すものとして変換を行います。kantan_dai,
kanzen_dai は、与えられた文字列が一つの大文節の部分を成す小文節の列を
成すものとして変換を行います。

頻度の更新に付いては、js_hindo_set(env,dic_No,entry,ima,hindo) (ある辞
書のあるエントリの頻度、今使ったよビットの値をある値にセットする。) を
用います。ここで、与える頻度地は、実頻度値(jserver の中で圧縮して持っ
ている値ではなく、実際に使われた回数) です。今使ったよビット、頻度の値
は、別々に指定し、どちらか一方の値しか変化させない時には、もう一方の値
をWNN_HINDO_NOP としていします。頻度に付いては、値を指定してセットする
だけではなく、WNN_HINDO_INC (頻度を１上げる) WNN_HINDO_DEL (頻度を１
下げる)があります。WNN_HINDO_INC をしても、内部的には頻度は圧縮して持っ
ているので、必ずしも上がるとは限りません。この他に、WNN_ENTRY_NO_USE
を指定すると、そのエントリは、それ以降の変換で用いられなくなります。
(マイナス無限大にセットするという感じでしょうか。)

js_close(js);	

最後に、js_close を呼んで、コネクションを切断しています。コネクション
を切断することにより、そのコネクションから起こした全ての環境は、他のク
ライアントと共有していない限りなくなり、それらの環境で読み込んだファイ
ルで、他の環境から読み込まれていないものは全てメモリー上から開放されま
す。

その他の低レベル・ライブラリとして、

js_dic_info(env,dic_No,ret)
	dic_No の辞書に付いての情報を得る。

js_word_add(env,dic_No,読み,漢字,品詞)
	dic_No の辞書No. に、単語を登録する。

js_word_delete(env,dic_No,Yomi,jisho_entry)
	dic_No の辞書から単語を削除する。

js_word_search(env,dic_No,読み,ret_buf)
	dic_No の辞書に単語検索を行う。

js_word_inspect(env, dic_No, entry, ret_buf)
	dic_No の辞書の entry 番目の entry について、inspect を行う。
		   
js_word_search_by_env(env,読み,ret_buf)
	環境中の全ての辞書Ｎｏ．に対して単語検索を行う。

js_who
	jserver の使用者の一覧を得る。

があります。


３．２　高レベル・ライブラリ

高レベル・ライブラリでは、ユーザの変換の履歴を「バッファ」に残すことにより、
	●それぞれの変換を行う時の前端、後端の接続条件などの設定を行う。
	●頻度更新する時に、選択されなかった語に対し今使ったよビットを落とす。
といった処理をします。また、
	●次候補列をつくり、その中からの設定の便宜を計ります。
次候補列を作る時には、最初の変換で返ってきた候補を次候補列の先頭に持っていく、
同じ候補が重複しないようにするなどの処理をおこないます。

「バッファ」は複数持つことが出来ます。その時、不必要になった環境、
jserver との通信路の破壊などの面倒も見ます。

Ver.4 では、「環境」、「ファイル」、「大文節」といった複雑な概念が存在
しましたが、高レベルライブラリではこれらの概念について知らなくてもライ
ブラリを用いたプログラムが組めるようになっています。もちろん、大文節、
環境などを直接扱いたい場合には、扱うことが出来ます。

また、
	●環境に関する初期設定を行う。
	●サーバが突然死んだ時に接続し直す。
	●辞書追加の時、存在しない辞書、頻度ファイルの作成
といった処理も行います。



その他

(i) 辞書のディレクトリの変更 

    バージョン３での辞書のディレクトリは、/usr/local/lib/dic/sys/*.sys
    でしたが、バージョン４では、/usr/local/lib/wnn/dic/sys/*.sys に
    変更されました。また、辞書環境を拡充するためにパブリック辞書も含ま
    れています。( /usr/local/lib/wnn/dic/pubdic/*.sys )
    ユーザ辞書についても同様に /usr/local/lib/wnn/dic/usr/ユーザ名/ud 
    にディレクトリが変更されています。
    バージョン３を使用されていた方は、バージョン３で蓄積されたユーザ辞
    書を辞書ユーティリティで変換することによって、バージョン４のユーザ
    辞書として使用することができます。
    [変換方法]
	jdicutoa /usr/local/lib/dic/usr/ユーザ名/ud | oldatonewa
		| atod /usr/local/lib/wnn/dic/usr/ユーザ名/ud [CR]

(ii) 環境の変更

    バージョン３での環境ファイルは、/usr/local/lib/jd/wnnrc であり、こ
    の環境ファイルの中で、辞書や付属語ファイルなどをすべて設定していま
    したが、バージョン４では、環境ファイルに汎用性を多く持たせるために
    /usr/local/lib/wnn/uumrc と /usr/local/lib/wnn/wnnenvrc とに分割し
    てあります。詳細は、各ファイルのマニュアルを参照して下さい。
    
(iii) コマンド名の変更

    バージョン３では、起動コマンド名は wnn でしたが、バージョン４では、
    uum に変更されています。
    ( /usr/bin/wnn	→	/usr/local/bin/Wnn4/uum )

(iv) キーバインド表の変更

    バージョン３では、キーバインド表は wnnkey でしたが、バージョン４で
    は、uumkey に変更されています。
    ( /usr/local/lib/jd/wnnkey  →  /usr/local/lib/wnn/uumkey )


    以下に、主なキーの変更点を記述します。

	┏━━━━━━━┯━━━━━━━━┯━━━━━━━━━━┓	
	┃バージョン３  │  バージョン４  │ 	機	能      ┃  
	┣━━━━━━━┿━━━━━━━━┿━━━━━━━━━━┫
	┃    ^W^G	│       ^W^W	  │    次候補一覧表示  ┃ 
	┠───────┼────────┼──────────┨
	┃ ^W, ^N, 0x92	│       ^N	  │	次候補表示      ┃
	┠───────┼────────┼──────────┨
	┃	-	│       ^Z 	  │	単漢字変換	┃
	┠───────┼────────┼──────────┨
	┃	-	│       ^Z^Z	  │単漢字次候補一覧表示┃
	┠───────┼────────┼──────────┨
	┃	-       │	 ^C	  │	かな変換	┃
	┠───────┼────────┼──────────┨
	┃    0x96 	│  ^^, 0x84, 0x96│辞書ユーティリティ  ┃
	┗━━━━━━━┷━━━━━━━━┷━━━━━━━━━━┛
    
(9) ライブラリ名の変更

    バージョン３では、/usr/lib/libjd.a でしたが、バージョン４では、
    /usr/local/lib/libwnn.a , /usr/local/lib/libgetopt.a ,
    /usr/local/lib/libwnn_m.a
    に変更されています。

    また、ライブラリ関数も大幅に変更されました。
    低水準のライブラリ関数として、js ではじまる関数、高水準のライブラリ
    関数として、jl ではじまる関数を新規追加しました。
    バージョン３のライブラリ( jd ではじまる関数 )を使用されていた方に
    は、バージョン４において、互換ライブラリが装備されています。
    この互換ライブラリは、バージョン３のライブラリ関数名で低水準のライ
    ブラリ関数( js )を起動します。

          Ｗｎｎバージョン３からＷｎｎバージョン４への変更点一覧

     ┏━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━┓
     ┃     Ｗｎｎバージョン３	     │     Ｗｎｎバージョン４       ┃	
     ┣━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━┫
     ┃ /usr/bin/wnn	             │ /usr/local/bin/Wnn4/uum      ┃
     ┠───────────────┼───────────────┨
     ┃ /usr/local/lib/jd/wnnrc      │ /usr/local/lib/wnn/uumrc     ┃
     ┃		     		     │ /usr/local/lib/wnn/wnnenvrc  ┃
     ┠───────────────┼───────────────┨
     ┃ /usr/local/lib/jd/wnnkey     │ /usr/local/lib/wnn/uumkey    ┃
     ┠───────────────┼───────────────┨
     ┃ /usr/local/lib/jd/dic/sys    │ /usr/local/lib/wnn/dic/sys   ┃
     ┃ 		  	     │	/usr/local/lib/wnn/dic/pubdic┃
     ┠───────────────┼───────────────┨
     ┃ /usr/local/lib/jd/dic/usr    │ /usr/local/lib/wnn/dic/usr   ┃
     ┠───────────────┼───────────────┨
     ┃ /usr/lib/libjd.a	     │ /usr/lib/libjd.a	     ┃
     ┃ 			     │ /usr/lib/libwnn.a	     ┃
     ┃ 		  	     │	/usr/lib/libwnn_m.a	     ┃
     ┃ 		  	     │	/usr/lib/libgetopt.a	     ┃
     ┠───────────────┼───────────────┨
     ┃ 解析    	             │ 			     ┃
     ┃      文節		     │ 小文節 ( Ver.3の文節と同等 ) ┃
     ┃				     │ 大文節 ( 小文節の列 )        ┃
     ┠───────────────┼───────────────┨
     ┃ システム辞書	             │ 固定形式辞書	             ┃
     ┃     kihon_1  (基本辞書)	     │ pd-kihon.sys   (基本辞書)    ┃
     ┃     kihon_2  (基本辞書)	     │ pd-tankan.sys  (単漢辞書)    ┃
     ┃     tankan_1 (単漢辞書)	     │ pd-chimei.sys  (地名辞書)    ┃
     ┃     koyuu_1  (固有名詞辞書)  │ pd-jinmei.sys  (人名辞書)    ┃
     ┃     jim_1    (事務用語辞書)  │ pd-setsuji.sys               ┃
     ┃     jyoho_1  (情報処理辞書)  │	             (接頭接尾語辞書)┃
     ┃     			     │ pd-computer.sys(情報処理辞書)┃
     ┃				     │ pd-koyuu.sys                 ┃
     ┃				     │  (人名地名以外の固有名詞辞書)┃
     ┃				     │ pd-koyuu.sys                 ┃
     ┃				     │          (記号の一般呼称辞書)┃
     ┃				     │ pd-special.sys (特殊語辞書)  ┃
     ┠───────────────┼───────────────┨
     ┃ ユーザ辞書	             │ 登録可能形式辞書             ┃
     ┃(頻度ファイルを外部に持てない)│ (頻度ファイルを外部に持てる) ┃
     ┠───────────────┼───────────────┨
     ┃		     ─		     │ 品詞ファイルへのエントリの   ┃
     ┃				     │     追加は可能               ┃
     ┃				     │ (削除、並べ変えは不可)       ┃
     ┠───────────────┼───────────────┨
     ┃ 自立語品詞 32 種類	     │ 自立語品詞 256 種類	     ┃
     ┃				     │     (複合品詞 ほぼ無制限)    ┃
     ┠───────────────┼───────────────┨
     ┃	辞書ユーティリティ	     │				     ┃
     ┃     atou  	             │ atod  -U                     ┃
     ┃     atos		     │ atod  -S		     ┃
     ┃     utoa  ,  stoa	     │ dtoa     		     ┃
     ┃				     ├───────────────┨
     ┃		     ─		     │ wnnstat                      ┃
     ┃		     ─		     │ wnnkill                      ┃
     ┃		     ─		     │ wnntouch                     ┃
     ┠───────────────┼───────────────┨
     ┃ 付属語ファイルはサーバに一つ │ 環境毎に設定可能	     ┃
     ┠───────────────┼───────────────┨
     ┃ ライブラリ (jd)	             │ ライブラリ (jd)              ┃
     ┃				     │ 低レベルライブラリ (js)      ┃
     ┃				     │ 高レベルライブラリ (jl)      ┃
     ┠───────────────┼───────────────┨
     ┃ 辞書の読みの文字種に制限あり │ 読みに 2 バイトコードが可能  ┃
     ┃ 		(256種)	     │     (漢字仮名変換が可能)     ┃
     ┠───────────────┼───────────────┨
     ┃ 辞書はサーバマシン上にしか   │ クライアントのローカル側に   ┃
     ┃     置くことができない	     │     置くことも可能           ┃
     ┠───────────────┼───────────────┨
     ┃		     ─		     │ 辞書エントリの一時的削除可能 ┃
     ┃				     │ (頻度値をある値にセットする) ┃
     ┠───────────────┼───────────────┨
     ┃		     ─		     │ 辞書本体,辞書頻度部分に      ┃
     ┃				     │     パスワードを設定可能     ┃
     ┠───────────────┼───────────────┨
     ┃		     ─		     │ 辞書本体,辞書エントリに      ┃
     ┃				     │     コメントを設定可能       ┃
     ┗━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━┛
