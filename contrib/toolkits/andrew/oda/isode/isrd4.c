/* automatically generated by pepy 5.0 #1 (mss.andrew.cmu.edu), do not edit! */

#include <psap.h>

static char *pepyid = "pepy 5.0 #1 (mss.andrew.cmu.edu) of Mon May 22 20:44:32 EDT 1989";

#define	advise	PY_advise

void	advise ();

/* Generated from module ISRD4 */
# line 5 "isrd4.py"


/*
 *
 * (C) Copyright 1989 by Carnegie Mellon University
 *
 * Permission to use, copy, modify, and distribute these programs
 * and their documentation for any purpose and without fee is
 * hereby granted, provided that this copyright and permission
 * notice appear on all copies and supporting documentation, and
 * that the name of Carnegie Mellon University not be used in
 * advertising or publicity pertaining to distribution of the
 * programs without specific prior permission and notice be given
 * in supporting documentation that copying and distribution is
 * by permission of Carnegie Mellon University.
 *
 * Carnegie Mellon University makes no representations about the
 * suitability of this software for any purpose.  It is provided
 * as is, without express or implied warranty.
 *
 * Software by Ann Marks and James T. Lui,
 * Information Technology Center, Carnegie Mellon University,
 * except where noted.
 *
 */

#define TK_TKI_TKERR
#define TK_TKI_APIRT
#define TK_TKI_MM

#include <odatk.h>

#undef TK_TKI_TKERR
#undef TK_TKI_APIRT
#undef TK_TKI_MM

#define TK_IMPL_ISRD

#include <isrd.h>

#undef TK_IMPL_ISRD

#define PEPYPARM struct isode2toolkit_t *

INT_type dummy;


#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	parse_ISRD4_Position__Spec (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p0_count = 0;
    register PE p0;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Position-Spec");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Position-Spec bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Position-Spec bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p0 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Position-Spec bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p0;

    if (p0 = set_find (pe, PE_CLASS_CONT, 0)) {
        int p1_count = 0;
        register PE p1;

#ifdef DEBUG
        (void) testdebug (p0, "offset");
#endif

        if ((p1 = prim2set (p0)) == NULLPE) {
            advise (NULLCP, "offset bad set: %s",
                    pe_error (p0 -> pe_errno));
            return NOTOK;
        }
        p0 = p1;

        if (p1 = set_find (p0, PE_CLASS_CONT, 0)) {
#ifdef DEBUG
            (void) testdebug (p1, "leading");
#endif

            if (prim2num (p1) == NOTOK
                    && p1 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "leading bad integer: %s",
                        pe_error (p1 -> pe_errno));
                return NOTOK;
            }
            p1_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p1 = set_find (p0, PE_CLASS_CONT, 1)) {
#ifdef DEBUG
            (void) testdebug (p1, "trailing");
#endif

            if (prim2num (p1) == NOTOK
                    && p1 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "trailing bad integer: %s",
                        pe_error (p1 -> pe_errno));
                return NOTOK;
            }
            p1_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p1 = set_find (p0, PE_CLASS_CONT, 2)) {
#ifdef DEBUG
            (void) testdebug (p1, "left-hand");
#endif

            if (prim2num (p1) == NOTOK
                    && p1 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "left-hand bad integer: %s",
                        pe_error (p1 -> pe_errno));
                return NOTOK;
            }
            p1_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p1 = set_find (p0, PE_CLASS_CONT, 3)) {
#ifdef DEBUG
            (void) testdebug (p1, "right-hand");
#endif

            if (prim2num (p1) == NOTOK
                    && p1 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "right-hand bad integer: %s",
                        pe_error (p1 -> pe_errno));
                return NOTOK;
            }
            p1_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p1_count != p0 -> pe_cardinal)
            advise (NULLCP, "warning: extra or duplicate members present in SET");
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 1)) {
        int p2_count = 0;
        register PE p2;

#ifdef DEBUG
        (void) testdebug (p0, "separation");
#endif

        if ((p2 = prim2set (p0)) == NULLPE) {
            advise (NULLCP, "separation bad set: %s",
                    pe_error (p0 -> pe_errno));
            return NOTOK;
        }
        p0 = p2;

        if (p2 = set_find (p0, PE_CLASS_CONT, 0)) {
#ifdef DEBUG
            (void) testdebug (p2, "leading");
#endif

            if (prim2num (p2) == NOTOK
                    && p2 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "leading bad integer: %s",
                        pe_error (p2 -> pe_errno));
                return NOTOK;
            }
            p2_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p2 = set_find (p0, PE_CLASS_CONT, 1)) {
#ifdef DEBUG
            (void) testdebug (p2, "trailing");
#endif

            if (prim2num (p2) == NOTOK
                    && p2 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "trailing bad integer: %s",
                        pe_error (p2 -> pe_errno));
                return NOTOK;
            }
            p2_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p2 = set_find (p0, PE_CLASS_CONT, 2)) {
#ifdef DEBUG
            (void) testdebug (p2, "centre");
#endif

            if (prim2num (p2) == NOTOK
                    && p2 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "centre bad integer: %s",
                        pe_error (p2 -> pe_errno));
                return NOTOK;
            }
            p2_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p2_count != p0 -> pe_cardinal)
            advise (NULLCP, "warning: extra or duplicate members present in SET");
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 2)) {
        register int p3;

#ifdef DEBUG
        (void) testdebug (p0, "alignment");
#endif

        if ((p3 = prim2num (p0)) == NOTOK
                && p0 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "alignment bad integer: %s",
                    pe_error (p0 -> pe_errno));
            return NOTOK;
        }
        switch (p3) {
            case 0:	/* right-hand */
                break;
            case 1:	/* centred */
                break;
            case 2:	/* left-hand */
                break;
            default:
                advise (NULLCP, "alignment has unknown component: %d", p3);
                return NOTOK;
        }
        p0_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p0 = set_find (pe, PE_CLASS_CONT, 3)) {
        register int p4;

#ifdef DEBUG
        (void) testdebug (p0, "fill-order");
#endif

        if ((p4 = prim2num (p0)) == NOTOK
                && p0 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "fill-order bad integer: %s",
                    pe_error (p0 -> pe_errno));
            return NOTOK;
        }
        switch (p4) {
            case 0:	/* normal */
                break;
            case 1:	/* reverse */
                break;
            default:
                advise (NULLCP, "fill-order has unknown component: %d", p4);
                return NOTOK;
        }
        p0_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p0_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Dimension__Pair (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p5;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Dimension-Pair");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Dimension-Pair bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Dimension-Pair bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p5 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Dimension-Pair bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p5;

    {
        register PE p6;

        if ((p6 = first_member (pe)) != NULLPE) {
            p5 = p6;

            {	/* horizontal */
#ifdef DEBUG
                (void) testdebug (p6, "horizontal");
#endif

                if (prim2num (p6) == NOTOK
                        && p6 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "horizontal bad integer: %s",
                            pe_error (p6 -> pe_errno));
                    return NOTOK;
                }
            }
        }
        else {
            advise (NULLCP, "Dimension-Pair missing horizontal element");
            return NOTOK;
        }

    }

    {
        register PE p7;

        if ((p7 = (pe != p5 ? next_member (pe, p5) : first_member (pe))) != NULLPE) {
            p5 = p7;

            {	/* vertical */
#ifdef DEBUG
                (void) testdebug (p7, "vertical");
#endif

                switch (PE_ID (p7 -> pe_class, p7 -> pe_id)) {
                    case PE_ID (PE_CLASS_CONT, 0):	/* fixed */
                        {
#ifdef DEBUG
                            (void) testdebug (p7, "fixed");
#endif

                            if (prim2num (p7) == NOTOK
                                    && p7 -> pe_errno != PE_ERR_NONE) {
                                advise (NULLCP, "fixed bad integer: %s",
                                        pe_error (p7 -> pe_errno));
                                return NOTOK;
                            }
                        }
                        break;
                    case PE_ID (PE_CLASS_CONT, 1):	/* variable */
                        {
#ifdef DEBUG
                            (void) testdebug (p7, "variable");
#endif

                            if (prim2num (p7) == NOTOK
                                    && p7 -> pe_errno != PE_ERR_NONE) {
                                advise (NULLCP, "variable bad integer: %s",
                                        pe_error (p7 -> pe_errno));
                                return NOTOK;
                            }
                        }
                        break;

                    default:
                        advise (NULLCP, "vertical has unknown choice: %s/%d/0x%x",
                                pe_classlist[p7 -> pe_class], p7 -> pe_form, p7 -> pe_id);
                        return NOTOK;
                }
            }
        }
        else {
            advise (NULLCP, "Dimension-Pair missing vertical element");
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Dimension-Pair has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Dimension__Spec (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p8;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Dimension-Spec");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Dimension-Spec bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Dimension-Spec bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p8 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Dimension-Spec bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p8;

    {
        register PE p9;

        if ((p9 = first_member (pe)) != NULLPE) {
            p8 = p9;

            {	/* horizontal */
#ifdef DEBUG
                (void) testdebug (p9, "horizontal");
#endif

                if (parse_ISRD4_Dimension (p9, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Dimension-Spec missing horizontal element");
            return NOTOK;
        }

    }

    {
        register PE p10;

        if ((p10 = (pe != p8 ? next_member (pe, p8) : first_member (pe))) != NULLPE) {
            p8 = p10;

            {	/* vertical */
#ifdef DEBUG
                (void) testdebug (p10, "vertical");
#endif

                if (parse_ISRD4_Dimension (p10, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Dimension-Spec missing vertical element");
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Dimension-Spec has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Dimension (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Dimension");
#endif

    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* fixed */
            {
#ifdef DEBUG
                (void) testdebug (pe, "fixed");
#endif

                if (prim2num (pe) == NOTOK
                        && pe -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "fixed bad integer: %s",
                            pe_error (pe -> pe_errno));
                    return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* rule-a */
            {
                int p11_count = 0;
                register PE p11;

#ifdef DEBUG
                (void) testdebug (pe, "rule-a");
#endif

                if ((p11 = prim2set (pe)) == NULLPE) {
                    advise (NULLCP, "rule-a bad set: %s",
                            pe_error (pe -> pe_errno));
                    return NOTOK;
                }
                pe = p11;

                if (p11 = set_find (pe, PE_CLASS_CONT, 0)) {
#ifdef DEBUG
                    (void) testdebug (p11, "minimum-a");
#endif

                    if (prim2num (p11) == NOTOK
                            && p11 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "minimum-a bad integer: %s",
                                pe_error (p11 -> pe_errno));
                        return NOTOK;
                    }
                    p11_count ++;
                }
                else {
                    /* set default here using yp -> yp_default */
                }

                if (p11 = set_find (pe, PE_CLASS_CONT, 1)) {
#ifdef DEBUG
                    (void) testdebug (p11, "maximum-a");
#endif

                    if (prim2num (p11) == NOTOK
                            && p11 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "maximum-a bad integer: %s",
                                pe_error (p11 -> pe_errno));
                        return NOTOK;
                    }
                    p11_count ++;
                }
                else {
                    /* set default here using yp -> yp_default */
                }

                if (p11_count != pe -> pe_cardinal)
                    advise (NULLCP, "warning: extra or duplicate members present in SET");
            }
            break;
        case PE_ID (PE_CLASS_CONT, 2):	/* rule-b */
            {
                int p12_count = 0;
                register PE p12;

#ifdef DEBUG
                (void) testdebug (pe, "rule-b");
#endif

                if ((p12 = prim2set (pe)) == NULLPE) {
                    advise (NULLCP, "rule-b bad set: %s",
                            pe_error (pe -> pe_errno));
                    return NOTOK;
                }
                pe = p12;

                if (p12 = set_find (pe, PE_CLASS_CONT, 0)) {
#ifdef DEBUG
                    (void) testdebug (p12, "minimum-b");
#endif

                    if (prim2num (p12) == NOTOK
                            && p12 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "minimum-b bad integer: %s",
                                pe_error (p12 -> pe_errno));
                        return NOTOK;
                    }
                    p12_count ++;
                }
                else {
                    /* set default here using yp -> yp_default */
                }

                if (p12 = set_find (pe, PE_CLASS_CONT, 1)) {
#ifdef DEBUG
                    (void) testdebug (p12, "maximum-b");
#endif

                    if (prim2num (p12) == NOTOK
                            && p12 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "maximum-b bad integer: %s",
                                pe_error (p12 -> pe_errno));
                        return NOTOK;
                    }
                    p12_count ++;
                }
                else {
                    /* set default here using yp -> yp_default */
                }

                if (p12_count != pe -> pe_cardinal)
                    advise (NULLCP, "warning: extra or duplicate members present in SET");
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* maximum-size */
            {
#ifdef DEBUG
                (void) testdebug (pe, "maximum-size");
#endif

            }
            break;

        default:
            advise (NULLCP, "Dimension has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Transparency (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p13;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Transparency");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "Transparency bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "Transparency bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p13 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "Transparency bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p13;
    switch (p13) {
        case 0:	/* transparent */
            break;
        case 1:	/* opaque */
            break;
        default:
            advise (NULLCP, "Transparency has unknown component: %d", p13);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Comment__String (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register char *p14;
    int p14_len;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Comment-String");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV || pe -> pe_id != PE_PRIM_OCTS) {
            advise (NULLCP, "Comment-String bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }

    if ((p14 = prim2str (pe, &p14_len)) == NULLCP) {
        advise (NULLCP, "Comment-String bad octetstring: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p14_len;
    if (buffer)
        *buffer = p14;
    else
        if (p14)
            free (p14);

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Binding__Pair (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p15_count = 0;
    register PE p15;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Binding-Pair");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Binding-Pair bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Binding-Pair bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p15 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Binding-Pair bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p15;

    if (p15 = set_find (pe, PE_CLASS_CONT, 0)) {
#ifdef DEBUG
        (void) testdebug (p15, "binding-identifier");
#endif

        if (parse_ISRD3_Binding__Name (p15, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p15_count ++;
    }
    else {
        advise (NULLCP, "binding-identifier missing binding-identifier member");
        return NOTOK;
    }

    if ( (p15 = set_find (pe, PE_CLASS_CONT, 1))
        || (p15 = set_find (pe, PE_CLASS_CONT, 2))
        || (p15 = set_find (pe, PE_CLASS_CONT, 3))
        || (p15 = set_find (pe, PE_CLASS_CONT, 4))
        || (p15 = set_find (pe, PE_CLASS_CONT, 5))
        || (p15 = set_find (pe, PE_CLASS_CONT, 6)) ) {
#ifdef DEBUG
        (void) testdebug (p15, "binding-value");
#endif

        switch (PE_ID (p15 -> pe_class, p15 -> pe_id)) {
            case PE_ID (PE_CLASS_CONT, 1):
                {
                    register PE p16 = p15;

                    {	/* member TAG PULLUP */
                        register PE p17;

                        if ((p17 = prim2set (p16)) == NULLPE) {
                            advise (NULLCP, "member bad member: %s",
                                    pe_error (p16 -> pe_errno));
                            return NOTOK;
                        }
                        if (p17 -> pe_cardinal != 1) {
                            advise (NULLCP, "member too many elements for tagged member: %d",
                                    p17 -> pe_cardinal);
                            return NOTOK;
                        }
                        p16 = first_member (p17);
                    }
                    {
#ifdef DEBUG
                        (void) testdebug (p16, "member");
#endif

                        if (parse_ISRD3_Object__Id__Expression (p16, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                            return NOTOK;
                    }
                }
                break;
            case PE_ID (PE_CLASS_CONT, 2):
                {
                    register PE p18 = p15;

                    {	/* member TAG PULLUP */
                        register PE p19;

                        if ((p19 = prim2set (p18)) == NULLPE) {
                            advise (NULLCP, "member bad member: %s",
                                    pe_error (p18 -> pe_errno));
                            return NOTOK;
                        }
                        if (p19 -> pe_cardinal != 1) {
                            advise (NULLCP, "member too many elements for tagged member: %d",
                                    p19 -> pe_cardinal);
                            return NOTOK;
                        }
                        p18 = first_member (p19);
                    }
                    {
#ifdef DEBUG
                        (void) testdebug (p18, "member");
#endif

                        if (parse_ISRD3_Numeric__Expression (p18, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                            return NOTOK;
                    }
                }
                break;
            case PE_ID (PE_CLASS_CONT, 3):
                {
                    register PE p20 = p15;

                    {	/* member TAG PULLUP */
                        register PE p21;

                        if ((p21 = prim2set (p20)) == NULLPE) {
                            advise (NULLCP, "member bad member: %s",
                                    pe_error (p20 -> pe_errno));
                            return NOTOK;
                        }
                        if (p21 -> pe_cardinal != 1) {
                            advise (NULLCP, "member too many elements for tagged member: %d",
                                    p21 -> pe_cardinal);
                            return NOTOK;
                        }
                        p20 = first_member (p21);
                    }
                    {
#ifdef DEBUG
                        (void) testdebug (p20, "member");
#endif

                        if (parse_ISRD3_String__Expression (p20, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                            return NOTOK;
                    }
                }
                break;
            case PE_ID (PE_CLASS_CONT, 4):
                {
#ifdef DEBUG
                    (void) testdebug (p15, "member");
#endif

                    if (parse_ISRD3_Object__or__Class__Identifier (p15, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;
            case PE_ID (PE_CLASS_CONT, 5):
                {
#ifdef DEBUG
                    (void) testdebug (p15, "member");
#endif

                    if (prim2num (p15) == NOTOK
                            && p15 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "member bad integer: %s",
                                pe_error (p15 -> pe_errno));
                        return NOTOK;
                    }
                }
                break;
            case PE_ID (PE_CLASS_CONT, 6):
                {
#ifdef DEBUG
                    (void) testdebug (p15, "member");
#endif

                }
                break;

            default:
                advise (NULLCP, "binding-value has unknown choice: %s/%d/0x%x",
                        pe_classlist[p15 -> pe_class], p15 -> pe_form, p15 -> pe_id);
                return NOTOK;
        }
        p15_count ++;
    }
    else {
        advise (NULLCP, "binding-value missing binding-value member");
        return NOTOK;
    }

    if (p15_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_One__Of__Four__Angles (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p22;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.One-Of-Four-Angles");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "One-Of-Four-Angles bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "One-Of-Four-Angles bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p22 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "One-Of-Four-Angles bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p22;
    switch (p22) {
        case 0:	/* d0 */
            break;
        case 1:	/* d90 */
            break;
        case 2:	/* d180 */
            break;
        case 3:	/* d270 */
            break;
        default:
            advise (NULLCP, "One-Of-Four-Angles has unknown component: %d", p22);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Measure__Pair (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p23;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Measure-Pair");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Measure-Pair bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Measure-Pair bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p23 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Measure-Pair bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p23;

    {
        register PE p24;

        if ((p24 = first_member (pe)) != NULLPE) {
            p23 = p24;

            {	/* horizontal */
#ifdef DEBUG
                (void) testdebug (p24, "horizontal");
#endif

                if (prim2num (p24) == NOTOK
                        && p24 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "horizontal bad integer: %s",
                            pe_error (p24 -> pe_errno));
                    return NOTOK;
                }
            }
        }
        else {
            advise (NULLCP, "Measure-Pair missing horizontal element");
            return NOTOK;
        }

    }

    {
        register PE p25;

        if ((p25 = (pe != p23 ? next_member (pe, p23) : first_member (pe))) != NULLPE) {
            p23 = p25;

            {	/* vertical */
#ifdef DEBUG
                (void) testdebug (p25, "vertical");
#endif

                if (prim2num (p25) == NOTOK
                        && p25 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "vertical bad integer: %s",
                            pe_error (p25 -> pe_errno));
                    return NOTOK;
                }
            }
        }
        else {
            advise (NULLCP, "Measure-Pair missing vertical element");
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Measure-Pair has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Medium__Type (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p26;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Medium-Type");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Medium-Type bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Medium-Type bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p26 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Medium-Type bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p26;

    {
        register PE p27;

        if ((p27 = first_member (pe)) != NULLPE
                && PE_ID (p27 -> pe_class, p27 -> pe_id)
                        != PE_ID (PE_CLASS_UNIV, 16))
            p27 = NULLPE;
        if (p27 != NULLPE) {
            p26 = p27;

            {	/* nominal-page-size */
#ifdef DEBUG
                (void) testdebug (p27, "nominal-page-size");
#endif

                if (parse_ISRD4_Measure__Pair (p27, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p28;

        if ((p28 = (pe != p26 ? next_member (pe, p26) : first_member (pe))) != NULLPE) {
            p26 = p28;

            {	/* side-of-sheet */
                register int p29;

#ifdef DEBUG
                (void) testdebug (p28, "side-of-sheet");
#endif

                if (p28 -> pe_class != PE_CLASS_UNIV
                        || p28 -> pe_form != PE_FORM_PRIM
                        || p28 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "side-of-sheet bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p28 -> pe_class], p28 -> pe_form, p28 -> pe_id);
                    return NOTOK;
                }

                if ((p29 = prim2num (p28)) == NOTOK
                        && p28 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "side-of-sheet bad integer: %s",
                            pe_error (p28 -> pe_errno));
                    return NOTOK;
                }
                switch (p29) {
                    case 0:	/* unspecified */
                        break;
                    case 1:	/* recto */
                        break;
                    case 2:	/* verso */
                        break;
                    default:
                        advise (NULLCP, "side-of-sheet has unknown component: %d", p29);
                        return NOTOK;
                }
            }
        }
    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Medium-Type has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Colour (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p30;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Colour");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "Colour bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "Colour bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p30 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "Colour bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p30;
    switch (p30) {
        case 0:	/* colourless */
            break;
        case 1:	/* white */
            break;
        default:
            advise (NULLCP, "Colour has unknown component: %d", p30);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Border (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p31_count = 0;
    register PE p31;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Border");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Border bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Border bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p31 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Border bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p31;

    if (p31 = set_find (pe, PE_CLASS_CONT, 0)) {
#ifdef DEBUG
        (void) testdebug (p31, "left-hand-edge");
#endif

        if (parse_ISRD4_Border__Edge (p31, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p31_count ++;
    }
    if (p31 = set_find (pe, PE_CLASS_CONT, 1)) {
#ifdef DEBUG
        (void) testdebug (p31, "right-hand-edge");
#endif

        if (parse_ISRD4_Border__Edge (p31, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p31_count ++;
    }
    if (p31 = set_find (pe, PE_CLASS_CONT, 2)) {
#ifdef DEBUG
        (void) testdebug (p31, "trailing-edge");
#endif

        if (parse_ISRD4_Border__Edge (p31, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p31_count ++;
    }
    if (p31 = set_find (pe, PE_CLASS_CONT, 3)) {
#ifdef DEBUG
        (void) testdebug (p31, "leading-edge");
#endif

        if (parse_ISRD4_Border__Edge (p31, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p31_count ++;
    }
    if (p31_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Border__Edge (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p32_count = 0;
    register PE p32;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Border-Edge");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Border-Edge bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Border-Edge bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p32 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Border-Edge bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p32;

    if (p32 = set_find (pe, PE_CLASS_CONT, 0)) {
#ifdef DEBUG
        (void) testdebug (p32, "line-width");
#endif

        if (prim2num (p32) == NOTOK
                && p32 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "line-width bad integer: %s",
                    pe_error (p32 -> pe_errno));
            return NOTOK;
        }
        p32_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p32 = set_find (pe, PE_CLASS_CONT, 1)) {
        register int p33;

#ifdef DEBUG
        (void) testdebug (p32, "line-type");
#endif

        if ((p33 = prim2num (p32)) == NOTOK
                && p32 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "line-type bad integer: %s",
                    pe_error (p32 -> pe_errno));
            return NOTOK;
        }
        switch (p33) {
            case 0:	/* invisible */
                break;
            case 1:	/* solid */
                break;
            case 2:	/* dashed */
                break;
            case 3:	/* dot */
                break;
            case 4:	/* dash-dot */
                break;
            case 5:	/* dash-dot-dot */
                break;
            default:
                advise (NULLCP, "line-type has unknown component: %d", p33);
                return NOTOK;
        }
        p32_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p32 = set_find (pe, PE_CLASS_CONT, 2)) {
#ifdef DEBUG
        (void) testdebug (p32, "freespace-width");
#endif

        if (prim2num (p32) == NOTOK
                && p32 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "freespace-width bad integer: %s",
                    pe_error (p32 -> pe_errno));
            return NOTOK;
        }
        p32_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p32_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Layout__Object__Descriptor (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct isode2toolkit_t *  parm;
{
# line 170 "isrd4.py"
    
    INT_type AnInt;
    VALUE_type ObjectType;

    STRING_type ObjectIDString;

    register PE p34;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Layout-Object-Descriptor");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Layout-Object-Descriptor bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Layout-Object-Descriptor bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p34 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Layout-Object-Descriptor bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p34;

    {
        register PE p35;

        if ((p35 = first_member (pe)) != NULLPE
                && PE_ID (p35 -> pe_class, p35 -> pe_id)
                        != PE_ID (PE_CLASS_UNIV, 2))
            p35 = NULLPE;
        if (p35 != NULLPE) {
            p34 = p35;

            {	/* object-type */
#ifdef DEBUG
                (void) testdebug (p35, "object-type");
#endif

                if (parse_ISRD4_Layout__Object__Type (p35, 1, &(AnInt ), NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                {
# line 183 "isrd4.py"

	    switch( AnInt ){
		case 0:
		    ObjectType = at_OBJECT_TYPE_doc_layout_root;
		    break;
		case 1:
		    ObjectType = at_OBJECT_TYPE_page_set;
		    break;
		case 2:
		    ObjectType = at_OBJECT_TYPE_page;
		    break;
		case 3:
		    ObjectType = at_OBJECT_TYPE_frame;
		    break;
		case 4:
		    ObjectType = at_OBJECT_TYPE_block;
		    break;
	    }
	    parm->constituent =
		    MakeComponent( parm->document, 
				   ObjectType,
				   SPECIFIC_COMPONENT );
	    if( parm->constituent == ERROR_CONSTITUENT ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor]: can not make the component" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
	    }
	
                }
            }
        }
    }

    {
        register PE p36;

        if ((p36 = (pe != p34 ? next_member (pe, p34) : first_member (pe))) != NULLPE) {
            p34 = p36;

            {	/* descriptor-body */
#ifdef DEBUG
                (void) testdebug (p36, "descriptor-body");
#endif

                if (parse_ISRD4_Layout__Object__Descriptor__Body (p36, 1, NULLIP, NULLVP, parm ) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Layout-Object-Descriptor has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }
    {
# line 224 "isrd4.py"

    if ( GetAttr( parm->constituent,
		  at_OBJECT_IDENTIFIER,
		  (POINTER_type) &ObjectIDString,
		  /* default */ BOOL_false,
		  /* mask */ (PARM_MASK_type *) 0
	        ) == ERROR_INT ) {
	return ( NOTOK );
    } else {
	if ( ISODE_FillInConstituent ( parm->constituent,
				       ObjectIDString
				     ) == ERROR_INT ) {
	    return ( NOTOK );
	}
    }
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Layout__Object__Type (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p37;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Layout-Object-Type");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "Layout-Object-Type bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "Layout-Object-Type bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p37 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "Layout-Object-Type bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p37;
    switch (p37) {
        case 0:	/* document-layout-root */
            break;
        case 1:	/* page-set */
            break;
        case 2:	/* page */
            break;
        case 3:	/* frame */
            break;
        case 4:	/* block */
            break;
        default:
            advise (NULLCP, "Layout-Object-Type has unknown component: %d", p37);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Layout__Object__Descriptor__Body (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct isode2toolkit_t *  parm;
{
# line 257 "isrd4.py"
    

    CHAR_type *ObjectIDChars;
    STRING_type ObjectIDString;

    CHAR_type *CommentChars;
    INT_type CommentLength;
    STRING_type CommentString;

    CHAR_type *NameChars;
    INT_type NameLength;
    STRING_type NameString;

    CHAR_type *ObjectClassIDChars;
    STRING_type ObjectClassIDString;
    struct hash_t *ObjectClassBucket;
    CONSTITUENT_type ObjectClass;

    CHAR_type *PresentStyleIDChars;
    STRING_type PresentStyleIDString;
    struct hash_t *PresentStyleBucket;
    CONSTITUENT_type PresentStyle;

    STRING_type ParentID;

    CHAR_type *SubordinatesIDChars;
    STRING_type SubordinatesIDString;
    SEQUENCE_STRING_type SubordinatesIDSequence;
    SEQUENCE_CONSTITUENT_type Subordinates;

    CHAR_type *ContentIDChars;
    STRING_type ContentIDString;
    SEQUENCE_STRING_type ContentIDSequence;
    SEQUENCE_CONSTITUENT_type ContentPortions;

    INT_type ApplCommentLength;
    CHAR_type *ApplCommentChars;
    STRING_type ApplCommentString;
    SEQUENCE_BYTE_type ApplComment;

    int p38_count = 0;
    register PE p38;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Layout-Object-Descriptor-Body");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Layout-Object-Descriptor-Body bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Layout-Object-Descriptor-Body bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p38 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Layout-Object-Descriptor-Body bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p38;

    if (p38 = set_find (pe, PE_CLASS_APPL, 1)) {
#ifdef DEBUG
        (void) testdebug (p38, "object-identifier");
#endif

        if (parse_ISRD3_Object__or__Class__Identifier (p38, 0, NULLIP, &(ObjectIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 304 "isrd4.py"

	    ObjectIDString = Chars2String(ObjectIDChars);
	    if ( ObjectIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not convert object-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_OBJECT_IDENTIFIER,
			  (POINTER_type) ObjectIDString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not set attribute at_OBJECT_IDENTIFIER" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 0)) {
        register PE p39;

#ifdef DEBUG
        (void) testdebug (p38, "subordinates");
#endif

        {
# line 328 "isrd4.py"

	    SubordinatesIDSequence =
		MakeSequence( SEQUENCE_STRING_tag, (INT_type) 0 );
	    if ( SubordinatesIDSequence == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not make sequence" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        if ((p39 = prim2seq (p38)) == NULLPE) {
            advise (NULLCP, "subordinates bad sequence: %s",
                    pe_error (p38 -> pe_errno));
            return NOTOK;
        }
        p38 = p39;

        for (p39 = first_member (p38); p39; p39 = next_member (p38, p39)) {
#ifdef DEBUG
            (void) testdebug (p39, "element");
#endif

            if (parse_UNIV_NumericString (p39, 1, NULLIP, &(SubordinatesIDChars ), NullParm) == NOTOK)
                return NOTOK;
            {
# line 343 "isrd4.py"

		SubordinatesIDString = Chars2String(SubordinatesIDChars);
		if ( SubordinatesIDString == ERROR_STRING ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not convert subordinates id chars to string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		if ( ExpandSequence(SubordinatesIDSequence,
				    (INT_type) 1) == ERROR_INT ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not expand subordinates id string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		SubordinatesIDSequence ->
		    sequence_value.strings[
		      SubordinatesIDSequence->length-1] = SubordinatesIDString;
	    
            }
        }
        {
# line 363 "isrd4.py"

	    if ( GetAttr( parm->constituent,
			  at_OBJECT_IDENTIFIER,
			  (POINTER_type) &ParentID,
			  /* default */ BOOL_false,
			  /* mask */ (PARM_MASK_type *) 0
			) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not get parent id for subordinates");
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    Subordinates =
		ISODE_MakeSequenceConstituent( ParentID,
					       SubordinatesIDSequence,
					       parm->document );
	    if ( Subordinates == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not convert subordinates ids to constituents" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_SUBORDINATES,
			  (POINTER_type) Subordinates,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not set attribute at_SUBORDINATES" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 1)) {
        register PE p40;

#ifdef DEBUG
        (void) testdebug (p38, "content-portions");
#endif

        {
# line 401 "isrd4.py"

	    ContentIDSequence =
		MakeSequence( SEQUENCE_STRING_tag, (INT_type) 0 );
	    if ( ContentIDSequence == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not make sequence" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        if ((p40 = prim2seq (p38)) == NULLPE) {
            advise (NULLCP, "content-portions bad sequence: %s",
                    pe_error (p38 -> pe_errno));
            return NOTOK;
        }
        p38 = p40;

        for (p40 = first_member (p38); p40; p40 = next_member (p38, p40)) {
#ifdef DEBUG
            (void) testdebug (p40, "element");
#endif

            if (parse_UNIV_NumericString (p40, 1, NULLIP, &(ContentIDChars ), NullParm) == NOTOK)
                return NOTOK;
            {
# line 416 "isrd4.py"

		ContentIDString = Chars2String(ContentIDChars);
		if ( ContentIDString == ERROR_STRING ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not convert content id chars to string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		if ( ExpandSequence(ContentIDSequence,
				    (INT_type) 1) == ERROR_INT ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not expand content id string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		ContentIDSequence ->
		    sequence_value.strings[
		      ContentIDSequence->length-1] = ContentIDString;
	    
            }
        }
        {
# line 436 "isrd4.py"

	    if ( GetAttr( parm->constituent,
			  at_OBJECT_IDENTIFIER,
			  (POINTER_type) &ParentID,
			  /* default */ BOOL_false,
			  /* mask */ (PARM_MASK_type *) 0
			) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not get parent id for subordinates");
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ContentPortions =
		ISODE_MakeSequenceConstituent( ParentID,
					       ContentIDSequence,
					       parm->document );
	    if ( ContentPortions == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not convert content ids to constituents" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_CONTENT_PORTIONS,
			  (POINTER_type) ContentPortions,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not set attribute at_CONTENT_PORTIONS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 2)) {
#ifdef DEBUG
        (void) testdebug (p38, "object-class");
#endif

        if (parse_ISRD3_Object__or__Class__Identifier (p38, 0, NULLIP, &(ObjectClassIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 476 "isrd4.py"

	    ObjectClassIDString = Chars2String(ObjectClassIDChars);
	    if ( ObjectClassIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not convert object-class-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ObjectClassBucket =
		ISODE_GetHashStructure(ObjectClassIDString,parm->document);
	    if ( ObjectClassBucket == ERROR_BUCKET ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not get hash structure" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ObjectClass = ObjectClassBucket->constituent;
	    if ( SetAttr( parm->constituent,
			  at_OBJECT_CLASS,
			  (POINTER_type) ObjectClass,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not set attribute at_OBJECT_CLASS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 3)) {
#ifdef DEBUG
        (void) testdebug (p38, "position");
#endif

        if (parse_ISRD4_Measure__Pair (p38, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 4)) {
#ifdef DEBUG
        (void) testdebug (p38, "dimensions");
#endif

        if (parse_ISRD4_Dimension__Pair (p38, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 5)) {
#ifdef DEBUG
        (void) testdebug (p38, "transparency");
#endif

        if (parse_ISRD4_Transparency (p38, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 6)) {
#ifdef DEBUG
        (void) testdebug (p38, "presentation-attributes");
#endif

        if (parse_ISRD6_Presentation__Attributes (p38, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 7)) {
#ifdef DEBUG
        (void) testdebug (p38, "default-value-lists");
#endif

        if (parse_ISRD7_Default__Value__Lists__Layout (p38, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 8)) {
#ifdef DEBUG
        (void) testdebug (p38, "user-readable-comments");
#endif

        if (parse_ISRD4_Comment__String (p38, 0, &( CommentLength ), &(CommentChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 519 "isrd4.py"

	    CommentString = MakeString(CommentLength);
	    if ( CommentString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor]: can not make string");
		dummy = TKERR_EndErrMsg();
		return ( NOTOK );
	    }
	    CommentString->sequence_value.chars = CommentChars;
	    if ( SetAttr( parm->constituent,
			  at_USER_READABLE_COMMENTS,
			  (POINTER_type) CommentString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_USER_READABLE_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 9)) {
        register PE p41;

#ifdef DEBUG
        (void) testdebug (p38, "bindings");
#endif

        if ((p41 = prim2set (p38)) == NULLPE) {
            advise (NULLCP, "bindings bad set: %s",
                    pe_error (p38 -> pe_errno));
            return NOTOK;
        }
        p38 = p41;

        for (p41 = first_member (p38); p41; p41 = next_member (p38, p41)) {
#ifdef DEBUG
            (void) testdebug (p41, "member");
#endif

            if (parse_ISRD4_Binding__Pair (p41, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 11)) {
#ifdef DEBUG
        (void) testdebug (p38, "layout-path");
#endif

        if (parse_ISRD4_One__Of__Four__Angles (p38, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 12)) {
        register PE p42;

#ifdef DEBUG
        (void) testdebug (p38, "imaging-order");
#endif

        if ((p42 = prim2seq (p38)) == NULLPE) {
            advise (NULLCP, "imaging-order bad sequence: %s",
                    pe_error (p38 -> pe_errno));
            return NOTOK;
        }
        p38 = p42;

        for (p42 = first_member (p38); p42; p42 = next_member (p38, p42)) {
#ifdef DEBUG
            (void) testdebug (p42, "element");
#endif

            if (parse_UNIV_NumericString (p42, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 13)) {
        register PE p43;

#ifdef DEBUG
        (void) testdebug (p38, "permitted-categories");
#endif

        if ((p43 = prim2set (p38)) == NULLPE) {
            advise (NULLCP, "permitted-categories bad set: %s",
                    pe_error (p38 -> pe_errno));
            return NOTOK;
        }
        p38 = p43;

        for (p43 = first_member (p38); p43; p43 = next_member (p38, p43)) {
#ifdef DEBUG
            (void) testdebug (p43, "member");
#endif

            if (parse_ISRD3_Layout__Category__Name (p43, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 14)) {
#ifdef DEBUG
        (void) testdebug (p38, "user-visible-name");
#endif

        if (parse_ISRD4_Comment__String (p38, 0, &( NameLength ), &(NameChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 555 "isrd4.py"

	    NameString = MakeString(NameLength);
	    if ( NameString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor]: can not make string");
		dummy = TKERR_EndErrMsg();
		return ( NOTOK );
	    }
	    NameString->sequence_value.chars = NameChars;
	    if ( SetAttr( parm->constituent,
			  at_USER_VISIBLE_NAME,
			  (POINTER_type) NameString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_USER_VISIBLE_NAME" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 15)) {
#ifdef DEBUG
        (void) testdebug (p38, "page-position");
#endif

        if (parse_ISRD4_Measure__Pair (p38, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 16)) {
#ifdef DEBUG
        (void) testdebug (p38, "medium-type");
#endif

        if (parse_ISRD4_Medium__Type (p38, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 17)) {
#ifdef DEBUG
        (void) testdebug (p38, "presentation-style");
#endif

        if (parse_ISRD3_Style__Identifier (p38, 0, NULLIP, &(PresentStyleIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 585 "isrd4.py"

	    PresentStyleIDString = Chars2String(PresentStyleIDChars);
	    if ( PresentStyleIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not convert presentation-style-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    PresentStyleBucket =
		ISODE_GetHashStructure(PresentStyleIDString,parm->document);
	    if ( PresentStyleBucket == ERROR_BUCKET ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not get hash structure" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    PresentStyle = PresentStyleBucket->constituent;
	    if ( SetAttr( parm->constituent,
			  at_PRESENTATION_STYLE,
			  (POINTER_type) PresentStyle,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_PRESENTATION_STYLE" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 21)) {
        register PE p44;

#ifdef DEBUG
        (void) testdebug (p38, "balance");
#endif

        if ((p44 = prim2set (p38)) == NULLPE) {
            advise (NULLCP, "balance bad set: %s",
                    pe_error (p38 -> pe_errno));
            return NOTOK;
        }
        p38 = p44;

        for (p44 = first_member (p38); p44; p44 = next_member (p38, p44)) {
#ifdef DEBUG
            (void) testdebug (p44, "member");
#endif

            if (parse_ISRD3_Object__or__Class__Identifier (p44, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 22)) {
#ifdef DEBUG
        (void) testdebug (p38, "colour");
#endif

        if (parse_ISRD4_Colour (p38, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 23)) {
#ifdef DEBUG
        (void) testdebug (p38, "border");
#endif

        if (parse_ISRD4_Border (p38, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p38_count ++;
    }
    if (p38 = set_find (pe, PE_CLASS_CONT, 25)) {
#ifdef DEBUG
        (void) testdebug (p38, "application-comments");
#endif

        if (parse_ISRD4_Comment__String (p38, 0, &( ApplCommentLength ), &(ApplCommentChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 629 "isrd4.py"

	    ApplCommentString = MakeString(ApplCommentLength);
	    if ( ApplCommentString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not make string for attribute at_APPLICATION_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ApplCommentString->sequence_value.chars = ApplCommentChars;
	    ApplComment = String2Bytes(ApplCommentString);
	    if ( ApplComment == ERROR_SEQUENCE) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not make byte sequence for attribute at_APPLICATION_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_APPLICATION_COMMENTS,
			  (POINTER_type) ApplComment,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Object__Descriptor__Body]: can not set attribute at_CONTENT_INFORMATION" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p38_count ++;
    }
    if (p38_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Layout__Class__Descriptor (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct isode2toolkit_t *  parm;
{
# line 664 "isrd4.py"
    

    INT_type AnInt;
    VALUE_type ObjectType;

    STRING_type ObjectClassIDString;


    register PE p45;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Layout-Class-Descriptor");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Layout-Class-Descriptor bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Layout-Class-Descriptor bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p45 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Layout-Class-Descriptor bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p45;

    {
        register PE p46;

        if ((p46 = first_member (pe)) != NULLPE) {
            p45 = p46;

            {	/* object-type */
#ifdef DEBUG
                (void) testdebug (p46, "object-type");
#endif

                if (parse_ISRD4_Layout__Object__Type (p46, 1, &(AnInt ), NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                {
# line 679 "isrd4.py"

	    switch ( AnInt ) {
		case 0:
		    ObjectType = at_OBJECT_TYPE_doc_layout_root;
		    break;
		case 1:
		    ObjectType = at_OBJECT_TYPE_page_set;
		    break;
		case 2:
		    ObjectType = at_OBJECT_TYPE_page;
		    break;
		case 3:
		    ObjectType = at_OBJECT_TYPE_frame;
		    break;
		case 4:
		    ObjectType = at_OBJECT_TYPE_block;
		    break;
	    }
	    parm->constituent =
		    MakeComponent( parm->document, 
				   ObjectType,
				   GENERIC_COMPONENT );
	    if( parm->constituent == ERROR_CONSTITUENT ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor]: can not make the component" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
	    }

	
                }
            }
        }
        else {
            advise (NULLCP, "Layout-Class-Descriptor missing object-type element");
            return NOTOK;
        }

    }

    {
        register PE p47;

        if ((p47 = (pe != p45 ? next_member (pe, p45) : first_member (pe))) != NULLPE) {
            p45 = p47;

            {	/* descriptor-body */
#ifdef DEBUG
                (void) testdebug (p47, "descriptor-body");
#endif

                if (parse_ISRD4_Layout__Class__Descriptor__Body (p47, 1, NULLIP, NULLVP, parm ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Layout-Class-Descriptor missing descriptor-body element");
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Layout-Class-Descriptor has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }
    {
# line 716 "isrd4.py"

    if ( GetAttr( parm->constituent,
		  at_OBJECT_CLASS_IDENTIFIER,
		  (POINTER_type) &ObjectClassIDString,
		  /* default */ BOOL_false,
		  /* mask */ (PARM_MASK_type *) 0
	        ) == ERROR_INT ) {
	return ( NOTOK );
    } else {
	if ( ISODE_FillInConstituent ( parm->constituent,
				       ObjectClassIDString
				     ) == ERROR_INT ) {
	    return ( NOTOK );
	}
    }
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD4_Layout__Class__Descriptor__Body (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct isode2toolkit_t *  parm;
{
# line 736 "isrd4.py"
    
    POINTER_type memp;

    CHAR_type *ObjectClassIDChars;
    STRING_type ObjectClassIDString;
    struct hash_t *ObjectClassBucket;
    CONSTITUENT_type ObjectClass;

    CHAR_type *CommentChars;
    INT_type CommentLength;
    STRING_type CommentString;

    CHAR_type *NameChars;
    INT_type NameLength;
    STRING_type NameString;

    CHAR_type *PresentStyleIDChars;
    STRING_type PresentStyleIDString;
    struct hash_t *PresentStyleBucket;
    CONSTITUENT_type PresentStyle;

    CHAR_type *LayoutStyleIDChars;
    STRING_type LayoutStyleIDString;
    struct hash_t *LayoutStyleBucket;
    CONSTITUENT_type LayoutStyle;

    INT_type Protection;
    VALUE_type ProtectionValue;

    CONSTRUCTION_EXPR_type *ConstructionExpr;

    STRING_type ParentID;

    CHAR_type *ContentIDChars;
    STRING_type ContentIDString;
    SEQUENCE_STRING_type ContentIDSequence;
    SEQUENCE_CONSTITUENT_type ContentPortions;

    INT_type ApplCommentLength;
    CHAR_type *ApplCommentChars;
    STRING_type ApplCommentString;
    SEQUENCE_BYTE_type ApplComment;

    CHAR_type *ResourceNameChars;
    STRING_type ResourceNameString;

    int p48_count = 0;
    register PE p48;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD4.Layout-Class-Descriptor-Body");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Layout-Class-Descriptor-Body bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Layout-Class-Descriptor-Body bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p48 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Layout-Class-Descriptor-Body bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p48;

    if (p48 = set_find (pe, PE_CLASS_APPL, 1)) {
#ifdef DEBUG
        (void) testdebug (p48, "object-class-identifier");
#endif

        if (parse_ISRD3_Object__or__Class__Identifier (p48, 0, NULLIP, &(ObjectClassIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 789 "isrd4.py"

	    ObjectClassIDString = Chars2String(ObjectClassIDChars);
	    if ( ObjectClassIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not convert object-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_OBJECT_CLASS_IDENTIFIER,
			  (POINTER_type) ObjectClassIDString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not set attribute at_OBJECT_IDENTIFIER" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p48_count ++;
    }
    else {
        advise (NULLCP, "object-class-identifier missing object-class-identifier member");
        return NOTOK;
    }

    if (p48 = set_find (pe, PE_CLASS_CONT, 0)) {
        register PE p49 = p48;

        {	/* generator-for-subordinates TAG PULLUP */
            register PE p50;

            if ((p50 = prim2set (p49)) == NULLPE) {
                advise (NULLCP, "generator-for-subordinates bad generator-for-subordinates: %s",
                        pe_error (p49 -> pe_errno));
                return NOTOK;
            }
            if (p50 -> pe_cardinal != 1) {
                advise (NULLCP, "generator-for-subordinates too many elements for tagged generator-for-subordinates: %d",
                        p50 -> pe_cardinal);
                return NOTOK;
            }
            p49 = first_member (p50);
        }
        {
#ifdef DEBUG
            (void) testdebug (p49, "generator-for-subordinates");
#endif

            {
# line 811 "isrd4.py"

	    memp = MM_Malloc(sizeof(CONSTRUCTION_EXPR_type));
	    if ( memp == ERROR_POINTER ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: out of memory" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ConstructionExpr = (CONSTRUCTION_EXPR_type *) memp;
	    SaveThisDocument( parm->document );
	
            }
            if (parse_ISRD3_Construction__Expression (p49, 1, NULLIP, NULLVP, ConstructionExpr ) == NOTOK)
                return NOTOK;
            {
# line 825 "isrd4.py"

	    if ( SetAttr( parm->constituent,
			  at_GEN_FOR_SUBORDINATES,
			  (POINTER_type) ConstructionExpr,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not set attribute at_GEN_FOR_SUBORDINATES" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
            }
        }
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 1)) {
        register PE p51;

#ifdef DEBUG
        (void) testdebug (p48, "content-portions");
#endif

        {
# line 842 "isrd4.py"

	    ContentIDSequence =
		MakeSequence( SEQUENCE_STRING_tag, (INT_type) 0 );
	    if ( ContentIDSequence == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not make sequence" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        if ((p51 = prim2seq (p48)) == NULLPE) {
            advise (NULLCP, "content-portions bad sequence: %s",
                    pe_error (p48 -> pe_errno));
            return NOTOK;
        }
        p48 = p51;

        for (p51 = first_member (p48); p51; p51 = next_member (p48, p51)) {
#ifdef DEBUG
            (void) testdebug (p51, "element");
#endif

            if (parse_UNIV_NumericString (p51, 1, NULLIP, &(ContentIDChars ), NullParm) == NOTOK)
                return NOTOK;
            {
# line 857 "isrd4.py"

		ContentIDString = Chars2String(ContentIDChars);
		if ( ContentIDString == ERROR_STRING ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not convert content id chars to string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		if ( ExpandSequence(ContentIDSequence,
				    (INT_type) 1) == ERROR_INT ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not expand content id string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		ContentIDSequence ->
		    sequence_value.strings[
		      ContentIDSequence->length-1] = ContentIDString;
	    
            }
        }
        {
# line 877 "isrd4.py"

	    if ( GetAttr( parm->constituent,
			  at_OBJECT_IDENTIFIER,
			  (POINTER_type) &ParentID,
			  /* default */ BOOL_false,
			  /* mask */ (PARM_MASK_type *) 0
			) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not get parent id for subordinates");
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ContentPortions =
		ISODE_MakeSequenceConstituent( ParentID,
					       ContentIDSequence,
					       parm->document );
	    if ( ContentPortions == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not convert content ids to constituents" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_CONTENT_PORTIONS,
			  (POINTER_type) ContentPortions,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not set attribute at_CONTENT_PORTIONS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p48_count ++;
    }
    if ( (p48 = set_find (pe, PE_CLASS_CONT, 3))
        || (p48 = set_find (pe, PE_CLASS_CONT, 26)) ) {
#ifdef DEBUG
        (void) testdebug (p48, "position");
#endif

        switch (PE_ID (p48 -> pe_class, p48 -> pe_id)) {
            case PE_ID (PE_CLASS_CONT, 3):	/* fixed-position */
                {
#ifdef DEBUG
                    (void) testdebug (p48, "fixed-position");
#endif

                    if (parse_ISRD4_Measure__Pair (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;
            case PE_ID (PE_CLASS_CONT, 26):	/* variable-position */
                {
#ifdef DEBUG
                    (void) testdebug (p48, "variable-position");
#endif

                    if (parse_ISRD4_Position__Spec (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;

            default:
                advise (NULLCP, "position has unknown choice: %s/%d/0x%x",
                        pe_classlist[p48 -> pe_class], p48 -> pe_form, p48 -> pe_id);
                return NOTOK;
        }
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 4)) {
#ifdef DEBUG
        (void) testdebug (p48, "dimensions");
#endif

        if (parse_ISRD4_Dimension__Spec (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 5)) {
#ifdef DEBUG
        (void) testdebug (p48, "transparency");
#endif

        if (parse_ISRD4_Transparency (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 6)) {
#ifdef DEBUG
        (void) testdebug (p48, "presentation-attributes");
#endif

        if (parse_ISRD6_Presentation__Attributes (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 7)) {
#ifdef DEBUG
        (void) testdebug (p48, "default-value-lists");
#endif

        if (parse_ISRD7_Default__Value__Lists__Layout (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 8)) {
#ifdef DEBUG
        (void) testdebug (p48, "user-readable-comments");
#endif

        if (parse_ISRD4_Comment__String (p48, 0, &( CommentLength ), &(CommentChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 927 "isrd4.py"

	    CommentString = MakeString(CommentLength);
	    if ( CommentString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class_Descriptor]: can not make string");
		dummy = TKERR_EndErrMsg();
		return ( NOTOK );
	    }
	    CommentString->sequence_value.chars = CommentChars;
	    if ( SetAttr( parm->constituent,
			  at_USER_READABLE_COMMENTS,
			  (POINTER_type) CommentString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not set attribute at_USER_READABLE_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 9)) {
        register PE p52;

#ifdef DEBUG
        (void) testdebug (p48, "bindings");
#endif

        if ((p52 = prim2set (p48)) == NULLPE) {
            advise (NULLCP, "bindings bad set: %s",
                    pe_error (p48 -> pe_errno));
            return NOTOK;
        }
        p48 = p52;

        for (p52 = first_member (p48); p52; p52 = next_member (p48, p52)) {
#ifdef DEBUG
            (void) testdebug (p52, "member");
#endif

            if (parse_ISRD4_Binding__Pair (p52, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 10)) {
#ifdef DEBUG
        (void) testdebug (p48, "content-generator");
#endif

        if (parse_ISRD3_String__Expression (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 11)) {
#ifdef DEBUG
        (void) testdebug (p48, "layout-path");
#endif

        if (parse_ISRD4_One__Of__Four__Angles (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 13)) {
        register PE p53;

#ifdef DEBUG
        (void) testdebug (p48, "permitted-categories");
#endif

        if ((p53 = prim2set (p48)) == NULLPE) {
            advise (NULLCP, "permitted-categories bad set: %s",
                    pe_error (p48 -> pe_errno));
            return NOTOK;
        }
        p48 = p53;

        for (p53 = first_member (p48); p53; p53 = next_member (p48, p53)) {
#ifdef DEBUG
            (void) testdebug (p53, "member");
#endif

            if (parse_ISRD3_Layout__Category__Name (p53, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 14)) {
#ifdef DEBUG
        (void) testdebug (p48, "user-visible-name");
#endif

        if (parse_ISRD4_Comment__String (p48, 0, &( NameLength ), &(NameChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 962 "isrd4.py"

	    NameString = MakeString(NameLength);
	    if ( CommentString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor]: can not make string");
		dummy = TKERR_EndErrMsg();
		return ( NOTOK );
	    }
	    NameString->sequence_value.chars = NameChars;
	    if ( SetAttr( parm->constituent,
			  at_USER_VISIBLE_NAME,
			  (POINTER_type) NameString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not set attribute at_USER_VISIBLE_NAME" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 15)) {
#ifdef DEBUG
        (void) testdebug (p48, "page-position");
#endif

        if (parse_ISRD4_Measure__Pair (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 16)) {
#ifdef DEBUG
        (void) testdebug (p48, "medium-type");
#endif

        if (parse_ISRD4_Medium__Type (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 17)) {
#ifdef DEBUG
        (void) testdebug (p48, "presentation-style");
#endif

        if (parse_ISRD3_Style__Identifier (p48, 0, NULLIP, &(PresentStyleIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 992 "isrd4.py"

	    PresentStyleIDString = Chars2String(PresentStyleIDChars);
	    if ( PresentStyleIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not convert presentation-style-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    PresentStyleBucket =
		ISODE_GetHashStructure(PresentStyleIDString,parm->document);
	    if ( PresentStyleBucket == ERROR_BUCKET ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not get hash structure" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    PresentStyle = PresentStyleBucket->constituent;
	    if ( SetAttr( parm->constituent,
			  at_PRESENTATION_STYLE,
			  (POINTER_type) PresentStyle,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not set attribute at_PRESENTATION_STYLE" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 18)) {
#ifdef DEBUG
        (void) testdebug (p48, "logical-source");
#endif

        if (parse_ISRD3_Object__or__Class__Identifier (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 21)) {
        register PE p54;

#ifdef DEBUG
        (void) testdebug (p48, "balance");
#endif

        if ((p54 = prim2set (p48)) == NULLPE) {
            advise (NULLCP, "balance bad set: %s",
                    pe_error (p48 -> pe_errno));
            return NOTOK;
        }
        p48 = p54;

        for (p54 = first_member (p48); p54; p54 = next_member (p48, p54)) {
#ifdef DEBUG
            (void) testdebug (p54, "member");
#endif

            if (parse_ISRD3_Object__or__Class__Identifier (p54, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 22)) {
#ifdef DEBUG
        (void) testdebug (p48, "colour");
#endif

        if (parse_ISRD4_Colour (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 23)) {
#ifdef DEBUG
        (void) testdebug (p48, "border");
#endif

        if (parse_ISRD4_Border (p48, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 24)) {
#ifdef DEBUG
        (void) testdebug (p48, "resource");
#endif

        if (parse_ISRD3_Resource__Name (p48, 0, NULLIP, &(ResourceNameChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 1037 "isrd4.py"

	    ResourceNameString = Chars2String(ResourceNameChars);
	    if ( ResourceNameString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not convert resource-name to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_RESOURCE,
			  (POINTER_type) ResourceNameString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not set attribute at_RESOURCE" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p48_count ++;
    }
    if (p48 = set_find (pe, PE_CLASS_CONT, 25)) {
#ifdef DEBUG
        (void) testdebug (p48, "application-comments");
#endif

        if (parse_ISRD4_Comment__String (p48, 0, &( ApplCommentLength ), &(ApplCommentChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 1064 "isrd4.py"

	    ApplCommentString = MakeString(ApplCommentLength);
	    if ( ApplCommentString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not make string for attribute at_APPLICATION_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ApplCommentString->sequence_value.chars = ApplCommentChars;
	    ApplComment = String2Bytes(ApplCommentString);
	    if ( ApplComment == ERROR_SEQUENCE) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not make byte sequence for attribute at_APPLICATION_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_APPLICATION_COMMENTS,
			  (POINTER_type) ApplComment,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD4_Layout__Class__Descriptor__Body]: can not set attribute at_CONTENT_INFORMATION" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p48_count ++;
    }
    if (p48_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");

    return OK;
}
