/* automatically generated by pepy 5.0 #1 (mss.andrew.cmu.edu), do not edit! */

#include <psap.h>

static char *pepyid = "pepy 5.0 #1 (mss.andrew.cmu.edu) of Mon May 22 20:44:32 EDT 1989";

#define	advise	PY_advise

void	advise ();

/* Generated from module ISRD5 */
# line 5 "isrd5.py"


/*
 *
 * (C) Copyright 1989 by Carnegie Mellon University
 *
 * Permission to use, copy, modify, and distribute these programs
 * and their documentation for any purpose and without fee is
 * hereby granted, provided that this copyright and permission
 * notice appear on all copies and supporting documentation, and
 * that the name of Carnegie Mellon University not be used in
 * advertising or publicity pertaining to distribution of the
 * programs without specific prior permission and notice be given
 * in supporting documentation that copying and distribution is
 * by permission of Carnegie Mellon University.
 *
 * Carnegie Mellon University makes no representations about the
 * suitability of this software for any purpose.  It is provided
 * as is, without express or implied warranty.
 *
 * Software by Ann Marks and James T. Lui,
 * Information Technology Center, Carnegie Mellon University,
 * except where noted.
 *
 */

#define TK_TKI_TKERR
#define TK_TKI_APIRT
#define TK_TKI_MM

#include <odatk.h>

#undef TK_TKI_TKERR
#undef TK_TKI_APIRT
#undef TK_TKI_MM

#define TK_IMPL_ISRD

#include <isrd.h>

#undef TK_IMPL_ISRD

#define PEPYPARM struct isode2toolkit_t *

INT_type dummy;


#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	parse_ISRD5_Logical__Object__Descriptor (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct isode2toolkit_t *  parm;
{
# line 77 "isrd5.py"
    
    INT_type AnInt;
    VALUE_type ObjectType;

    STRING_type ObjectIDString;

    register PE p0;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD5.Logical-Object-Descriptor");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Logical-Object-Descriptor bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Logical-Object-Descriptor bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p0 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Logical-Object-Descriptor bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p0;

    {
        register PE p1;

        if ((p1 = first_member (pe)) != NULLPE
                && PE_ID (p1 -> pe_class, p1 -> pe_id)
                        != PE_ID (PE_CLASS_UNIV, 2))
            p1 = NULLPE;
        if (p1 != NULLPE) {
            p0 = p1;

            {	/* object-type */
#ifdef DEBUG
                (void) testdebug (p1, "object-type");
#endif

                if (parse_ISRD5_Logical__Object__Type (p1, 1, &(AnInt ), NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                {
# line 90 "isrd5.py"

	    switch( AnInt ){
		case 0:
		    ObjectType = at_OBJECT_TYPE_doc_logical_root;
		    break;
		case 1:
		    ObjectType = at_OBJECT_TYPE_comp_logical_obj;
		    break;
		case 2:
		    ObjectType = at_OBJECT_TYPE_bas_logical_obj;
		    break;
	    }
	    parm->constituent =
		    MakeComponent( parm->document, 
				   ObjectType,
				   SPECIFIC_COMPONENT );
	    if( parm->constituent == ERROR_CONSTITUENT ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor]: can not make the component" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
	    }
	
                }
            }
        }
    }

    {
        register PE p2;

        if ((p2 = (pe != p0 ? next_member (pe, p0) : first_member (pe))) != NULLPE) {
            p0 = p2;

            {	/* descriptor-body */
#ifdef DEBUG
                (void) testdebug (p2, "descriptor-body");
#endif

                if (parse_ISRD5_Logical__Object__Descriptor__Body (p2, 1, NULLIP, NULLVP, parm ) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Logical-Object-Descriptor has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }
    {
# line 124 "isrd5.py"

    if ( GetAttr( parm->constituent,
		  at_OBJECT_IDENTIFIER,
		  (POINTER_type) &ObjectIDString,
		  /* default */ BOOL_false,
		  /* mask */ (PARM_MASK_type *) 0
	        ) == ERROR_INT ) {
	return ( NOTOK );
    } else {
	if ( ISODE_FillInConstituent ( parm->constituent,
				       ObjectIDString
				     ) == ERROR_INT ) {
	    return ( NOTOK );
	}
    }
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD5_Logical__Object__Type (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p3;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD5.Logical-Object-Type");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "Logical-Object-Type bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "Logical-Object-Type bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p3 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "Logical-Object-Type bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p3;
    switch (p3) {
        case 0:	/* document-logical-root */
            break;
        case 1:	/* composite-logical-object */
            break;
        case 2:	/* basic-logical-object */
            break;
        default:
            advise (NULLCP, "Logical-Object-Type has unknown component: %d", p3);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD5_Logical__Object__Descriptor__Body (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct isode2toolkit_t *  parm;
{
# line 155 "isrd5.py"
    
    CHAR_type *ObjectIDChars;
    STRING_type ObjectIDString;

    CHAR_type *CommentChars;
    INT_type CommentLength;
    STRING_type CommentString;

    CHAR_type *NameChars;
    INT_type NameLength;
    STRING_type NameString;

    CHAR_type *ObjectClassIDChars;
    STRING_type ObjectClassIDString;
    struct hash_t *ObjectClassBucket;
    CONSTITUENT_type ObjectClass;

    CHAR_type *PresentStyleIDChars;
    STRING_type PresentStyleIDString;
    struct hash_t *PresentStyleBucket;
    CONSTITUENT_type PresentStyle;

    CHAR_type *LayoutStyleIDChars;
    STRING_type LayoutStyleIDString;
    struct hash_t *LayoutStyleBucket;
    CONSTITUENT_type LayoutStyle;

    INT_type Protection;
    VALUE_type ProtectionValue;

    STRING_type ParentID;

    CHAR_type *SubordinatesIDChars;
    STRING_type SubordinatesIDString;
    SEQUENCE_STRING_type SubordinatesIDSequence;
    SEQUENCE_CONSTITUENT_type Subordinates;

    CHAR_type *ContentIDChars;
    STRING_type ContentIDString;
    SEQUENCE_STRING_type ContentIDSequence;
    SEQUENCE_CONSTITUENT_type ContentPortions;

    INT_type ApplCommentLength;
    CHAR_type *ApplCommentChars;
    STRING_type ApplCommentString;
    SEQUENCE_BYTE_type ApplComment;

    int p4_count = 0;
    register PE p4;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD5.Logical-Object-Descriptor-Body");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Logical-Object-Descriptor-Body bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Logical-Object-Descriptor-Body bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p4 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Logical-Object-Descriptor-Body bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p4;

    if (p4 = set_find (pe, PE_CLASS_APPL, 1)) {
#ifdef DEBUG
        (void) testdebug (p4, "object-identifier");
#endif

        if (parse_ISRD3_Object__or__Class__Identifier (p4, 0, NULLIP, &(ObjectIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 209 "isrd5.py"

	    ObjectIDString = Chars2String(ObjectIDChars);
	    if ( ObjectIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not convert object-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_OBJECT_IDENTIFIER,
			  (POINTER_type) ObjectIDString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_OBJECT_IDENTIFIER" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 0)) {
        register PE p5;

#ifdef DEBUG
        (void) testdebug (p4, "subordinates");
#endif

        {
# line 233 "isrd5.py"

	    SubordinatesIDSequence =
		MakeSequence( SEQUENCE_STRING_tag, (INT_type) 0 );
	    if ( SubordinatesIDSequence == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not make sequence" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        if ((p5 = prim2seq (p4)) == NULLPE) {
            advise (NULLCP, "subordinates bad sequence: %s",
                    pe_error (p4 -> pe_errno));
            return NOTOK;
        }
        p4 = p5;

        for (p5 = first_member (p4); p5; p5 = next_member (p4, p5)) {
#ifdef DEBUG
            (void) testdebug (p5, "element");
#endif

            if (parse_UNIV_NumericString (p5, 1, NULLIP, &(SubordinatesIDChars ), NullParm) == NOTOK)
                return NOTOK;
            {
# line 248 "isrd5.py"

		SubordinatesIDString = Chars2String(SubordinatesIDChars);
		if ( SubordinatesIDString == ERROR_STRING ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not convert subordinates id chars to string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		if ( ExpandSequence(SubordinatesIDSequence,
				    (INT_type) 1) == ERROR_INT ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not expand subordinates id string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		SubordinatesIDSequence ->
		    sequence_value.strings[
		      SubordinatesIDSequence->length-1] = SubordinatesIDString;
	    
            }
        }
        {
# line 268 "isrd5.py"

	    if ( GetAttr( parm->constituent,
			  at_OBJECT_IDENTIFIER,
			  (POINTER_type) &ParentID,
			  /* default */ BOOL_false,
			  /* mask */ (PARM_MASK_type *) 0
			) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not get parent id for subordinates");
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    Subordinates =
		ISODE_MakeSequenceConstituent( ParentID,
					       SubordinatesIDSequence,
					       parm->document );
	    if ( Subordinates == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not convert subordinates ids to constituents" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_SUBORDINATES,
			  (POINTER_type) Subordinates,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_SUBORDINATES" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 1)) {
        register PE p6;

#ifdef DEBUG
        (void) testdebug (p4, "content-portions");
#endif

        {
# line 306 "isrd5.py"

	    ContentIDSequence =
		MakeSequence( SEQUENCE_STRING_tag, (INT_type) 0 );
	    if ( ContentIDSequence == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not make sequence" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        if ((p6 = prim2seq (p4)) == NULLPE) {
            advise (NULLCP, "content-portions bad sequence: %s",
                    pe_error (p4 -> pe_errno));
            return NOTOK;
        }
        p4 = p6;

        for (p6 = first_member (p4); p6; p6 = next_member (p4, p6)) {
#ifdef DEBUG
            (void) testdebug (p6, "element");
#endif

            if (parse_UNIV_NumericString (p6, 1, NULLIP, &(ContentIDChars ), NullParm) == NOTOK)
                return NOTOK;
            {
# line 321 "isrd5.py"

		ContentIDString = Chars2String(ContentIDChars);
		if ( ContentIDString == ERROR_STRING ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not convert content id chars to string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		if ( ExpandSequence(ContentIDSequence,
				    (INT_type) 1) == ERROR_INT ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not expand content id string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		ContentIDSequence ->
		    sequence_value.strings[
		      ContentIDSequence->length-1] = ContentIDString;
	    
            }
        }
        {
# line 341 "isrd5.py"

	    if ( GetAttr( parm->constituent,
			  at_OBJECT_IDENTIFIER,
			  (POINTER_type) &ParentID,
			  /* default */ BOOL_false,
			  /* mask */ (PARM_MASK_type *) 0
			) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not get parent id for subordinates");
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ContentPortions =
		ISODE_MakeSequenceConstituent( ParentID,
					       ContentIDSequence,
					       parm->document );
	    if ( ContentPortions == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not convert content ids to constituents" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_CONTENT_PORTIONS,
			  (POINTER_type) ContentPortions,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_CONTENT_PORTIONS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 2)) {
#ifdef DEBUG
        (void) testdebug (p4, "object-class");
#endif

        if (parse_ISRD3_Object__or__Class__Identifier (p4, 0, NULLIP, &(ObjectClassIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 381 "isrd5.py"

	    ObjectClassIDString = Chars2String(ObjectClassIDChars);
	    if ( ObjectClassIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not convert object-class-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ObjectClassBucket =
		ISODE_GetHashStructure(ObjectClassIDString,parm->document);
	    if ( ObjectClassBucket == ERROR_BUCKET ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not get hash structure" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ObjectClass = ObjectClassBucket->constituent;
	    if ( SetAttr( parm->constituent,
			  at_OBJECT_CLASS,
			  (POINTER_type) ObjectClass,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_OBJECT_CLASS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 6)) {
#ifdef DEBUG
        (void) testdebug (p4, "presentation-attributes");
#endif

        if (parse_ISRD6_Presentation__Attributes (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        {
# line 416 "isrd5.py"


	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 7)) {
#ifdef DEBUG
        (void) testdebug (p4, "default-value-lists");
#endif

        if (parse_ISRD7_Default__Value__Lists__Logical (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        {
# line 426 "isrd5.py"


	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 8)) {
#ifdef DEBUG
        (void) testdebug (p4, "user-readable-comments");
#endif

        if (parse_ISRD4_Comment__String (p4, 0, &( CommentLength ), &(CommentChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 436 "isrd5.py"

	    CommentString = MakeString(CommentLength);
	    if ( CommentString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor]: can not make string");
		dummy = TKERR_EndErrMsg();
		return ( NOTOK );
	    }
	    CommentString->sequence_value.chars = CommentChars;
	    if ( SetAttr( parm->constituent,
			  at_USER_READABLE_COMMENTS,
			  (POINTER_type) CommentString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_USER_READABLE_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 9)) {
        register PE p7;

#ifdef DEBUG
        (void) testdebug (p4, "bindings");
#endif

        if ((p7 = prim2set (p4)) == NULLPE) {
            advise (NULLCP, "bindings bad set: %s",
                    pe_error (p4 -> pe_errno));
            return NOTOK;
        }
        p4 = p7;

        for (p7 = first_member (p4); p7; p7 = next_member (p4, p7)) {
#ifdef DEBUG
            (void) testdebug (p7, "member");
#endif

            if (parse_ISRD4_Binding__Pair (p7, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
            {
# line 463 "isrd5.py"


	
            }
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 10)) {
#ifdef DEBUG
        (void) testdebug (p4, "content-generator");
#endif

        if (parse_ISRD3_String__Expression (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        {
# line 473 "isrd5.py"


	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 14)) {
#ifdef DEBUG
        (void) testdebug (p4, "user-visible-name");
#endif

        if (parse_ISRD4_Comment__String (p4, 0, &( NameLength ), &(NameChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 483 "isrd5.py"

	    NameString = MakeString(NameLength);
	    if ( NameString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor]: can not make string");
		dummy = TKERR_EndErrMsg();
		return ( NOTOK );
	    }
	    NameString->sequence_value.chars = NameChars;
	    if ( SetAttr( parm->constituent,
			  at_USER_VISIBLE_NAME,
			  (POINTER_type) NameString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_USER_VISIBLE_NAME" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 17)) {
#ifdef DEBUG
        (void) testdebug (p4, "presentation-style");
#endif

        if (parse_ISRD3_Style__Identifier (p4, 0, NULLIP, &(PresentStyleIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 510 "isrd5.py"

	    PresentStyleIDString = Chars2String(PresentStyleIDChars);
	    if ( PresentStyleIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not convert presentation-style-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    PresentStyleBucket =
		ISODE_GetHashStructure(PresentStyleIDString,parm->document);
	    if ( PresentStyleBucket == ERROR_BUCKET ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not get hash structure" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    PresentStyle = PresentStyleBucket->constituent;
	    if ( SetAttr( parm->constituent,
			  at_PRESENTATION_STYLE,
			  (POINTER_type) PresentStyle,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_PRESENTATION_STYLE" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 19)) {
#ifdef DEBUG
        (void) testdebug (p4, "layout-style");
#endif

        if (parse_ISRD3_Style__Identifier (p4, 0, NULLIP, &(LayoutStyleIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 545 "isrd5.py"

	    LayoutStyleIDString = Chars2String(LayoutStyleIDChars);
	    if ( LayoutStyleIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not convert layout-style-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    LayoutStyleBucket =
		ISODE_GetHashStructure(LayoutStyleIDString,parm->document);
	    if ( LayoutStyleBucket == ERROR_BUCKET ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not get hash structure" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    LayoutStyle = LayoutStyleBucket->constituent;
	    if ( SetAttr( parm->constituent,
			  at_LAYOUT_STYLE,
			  (POINTER_type) LayoutStyle,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_LAYOUT_STYLE" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 20)) {
#ifdef DEBUG
        (void) testdebug (p4, "protection");
#endif

        if (parse_ISRD5_Protection (p4, 0, &(Protection ), NULLVP, NullParm) == NOTOK)
            return NOTOK;
        {
# line 580 "isrd5.py"

	    switch ( Protection ) {
		case 0:
		    ProtectionValue = at_PROTECTION_unprotected;
		    break;
		case 1:
		    ProtectionValue = at_PROTECTION_protected;
		    break;
	    }
	    if ( SetAttr( parm->constituent,
			  at_PROTECTION,
			  (POINTER_type) &ProtectionValue,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_PROTECTION" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 25)) {
#ifdef DEBUG
        (void) testdebug (p4, "application-comments");
#endif

        if (parse_ISRD4_Comment__String (p4, 0, &( ApplCommentLength ), &(ApplCommentChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 608 "isrd5.py"

	    ApplCommentString = MakeString(ApplCommentLength);
	    if ( ApplCommentString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not make string for attribute at_APPLICATION_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ApplCommentString->sequence_value.chars = ApplCommentChars;
	    ApplComment = String2Bytes(ApplCommentString);
	    if ( ApplComment == ERROR_SEQUENCE) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not make byte sequence for attribute at_APPLICATION_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_APPLICATION_COMMENTS,
			  (POINTER_type) ApplComment,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Object__Descriptor__Body]: can not set attribute at_CONTENT_INFORMATION" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p4_count ++;
    }
    if (p4_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");

    return OK;
}

/* ARGSUSED */

int	parse_ISRD5_Logical__Class__Descriptor (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct isode2toolkit_t *  parm;
{
# line 643 "isrd5.py"
    

    INT_type AnInt;
    VALUE_type ObjectType;

    STRING_type ObjectClassIDString;


    register PE p8;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD5.Logical-Class-Descriptor");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Logical-Class-Descriptor bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Logical-Class-Descriptor bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p8 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Logical-Class-Descriptor bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p8;

    {
        register PE p9;

        if ((p9 = first_member (pe)) != NULLPE) {
            p8 = p9;

            {	/* object-type */
#ifdef DEBUG
                (void) testdebug (p9, "object-type");
#endif

                if (parse_ISRD5_Logical__Object__Type (p9, 1, &(AnInt ), NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                {
# line 658 "isrd5.py"

	    switch ( AnInt ) {
		case 0:
		    ObjectType = at_OBJECT_TYPE_doc_logical_root;
		    break;
		case 1:
		    ObjectType = at_OBJECT_TYPE_comp_logical_obj;
		    break;
		case 2:
		    ObjectType = at_OBJECT_TYPE_bas_logical_obj;
		    break;
	    }
	    parm->constituent =
		    MakeComponent( parm->document, 
				   ObjectType,
				   GENERIC_COMPONENT );
	    if( parm->constituent == ERROR_CONSTITUENT ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor]: can not make the component" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
	    }

	
                }
            }
        }
        else {
            advise (NULLCP, "Logical-Class-Descriptor missing object-type element");
            return NOTOK;
        }

    }

    {
        register PE p10;

        if ((p10 = (pe != p8 ? next_member (pe, p8) : first_member (pe))) != NULLPE) {
            p8 = p10;

            {	/* descriptor-body */
#ifdef DEBUG
                (void) testdebug (p10, "descriptor-body");
#endif

                if (parse_ISRD5_Logical__Class__Descriptor__Body (p10, 1, NULLIP, NULLVP, parm ) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Logical-Class-Descriptor missing descriptor-body element");
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Logical-Class-Descriptor has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }
    {
# line 689 "isrd5.py"

    if ( GetAttr( parm->constituent,
		  at_OBJECT_CLASS_IDENTIFIER,
		  (POINTER_type) &ObjectClassIDString,
		  /* default */ BOOL_false,
		  /* mask */ (PARM_MASK_type *) 0
	        ) == ERROR_INT ) {
	return ( NOTOK );
    } else {
	if ( ISODE_FillInConstituent ( parm->constituent,
				       ObjectClassIDString
				     ) == ERROR_INT ) {
	    return ( NOTOK );
	}
    }
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD5_Logical__Class__Descriptor__Body (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct isode2toolkit_t *  parm;
{
# line 709 "isrd5.py"
    
    POINTER_type memp;

    CHAR_type *ObjectClassIDChars;
    STRING_type ObjectClassIDString;
    struct hash_t *ObjectClassBucket;
    CONSTITUENT_type ObjectClass;

    CHAR_type *CommentChars;
    INT_type CommentLength;
    STRING_type CommentString;

    CHAR_type *NameChars;
    INT_type NameLength;
    STRING_type NameString;

    CHAR_type *PresentStyleIDChars;
    STRING_type PresentStyleIDString;
    struct hash_t *PresentStyleBucket;
    CONSTITUENT_type PresentStyle;

    CHAR_type *LayoutStyleIDChars;
    STRING_type LayoutStyleIDString;
    struct hash_t *LayoutStyleBucket;
    CONSTITUENT_type LayoutStyle;

    INT_type Protection;
    VALUE_type ProtectionValue;

    CONSTRUCTION_EXPR_type *ConstructionExpr;

    STRING_type ParentID;

    CHAR_type *ContentIDChars;
    STRING_type ContentIDString;
    SEQUENCE_STRING_type ContentIDSequence;
    SEQUENCE_CONSTITUENT_type ContentPortions;

    INT_type ApplCommentLength;
    CHAR_type *ApplCommentChars;
    STRING_type ApplCommentString;
    SEQUENCE_BYTE_type ApplComment;

    CHAR_type *ResourceNameChars;
    STRING_type ResourceNameString;

    int p11_count = 0;
    register PE p11;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD5.Logical-Class-Descriptor-Body");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Logical-Class-Descriptor-Body bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Logical-Class-Descriptor-Body bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p11 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Logical-Class-Descriptor-Body bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p11;

    if (p11 = set_find (pe, PE_CLASS_APPL, 1)) {
#ifdef DEBUG
        (void) testdebug (p11, "object-class-identifier");
#endif

        if (parse_ISRD3_Object__or__Class__Identifier (p11, 0, NULLIP, &(ObjectClassIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 762 "isrd5.py"

	    ObjectClassIDString = Chars2String(ObjectClassIDChars);
	    if ( ObjectClassIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not convert object-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_OBJECT_CLASS_IDENTIFIER,
			  (POINTER_type) ObjectClassIDString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not set attribute at_OBJECT_IDENTIFIER" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p11_count ++;
    }
    else {
        advise (NULLCP, "object-class-identifier missing object-class-identifier member");
        return NOTOK;
    }

    if (p11 = set_find (pe, PE_CLASS_CONT, 0)) {
        register PE p12 = p11;

        {	/* generator-for-subordinates TAG PULLUP */
            register PE p13;

            if ((p13 = prim2set (p12)) == NULLPE) {
                advise (NULLCP, "generator-for-subordinates bad generator-for-subordinates: %s",
                        pe_error (p12 -> pe_errno));
                return NOTOK;
            }
            if (p13 -> pe_cardinal != 1) {
                advise (NULLCP, "generator-for-subordinates too many elements for tagged generator-for-subordinates: %d",
                        p13 -> pe_cardinal);
                return NOTOK;
            }
            p12 = first_member (p13);
        }
        {
#ifdef DEBUG
            (void) testdebug (p12, "generator-for-subordinates");
#endif

            {
# line 784 "isrd5.py"

	    memp = MM_Malloc(sizeof(CONSTRUCTION_EXPR_type));
	    if ( memp == ERROR_POINTER ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: out of memory" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ConstructionExpr = (CONSTRUCTION_EXPR_type *) memp;
	    SaveThisDocument( parm->document );
	
            }
            if (parse_ISRD3_Construction__Expression (p12, 1, NULLIP, NULLVP, ConstructionExpr ) == NOTOK)
                return NOTOK;
            {
# line 798 "isrd5.py"

	    if ( SetAttr( parm->constituent,
			  at_GEN_FOR_SUBORDINATES,
			  (POINTER_type) ConstructionExpr,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not set attribute at_GEN_FOR_SUBORDINATES" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
            }
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 1)) {
        register PE p14;

#ifdef DEBUG
        (void) testdebug (p11, "content-portions");
#endif

        {
# line 815 "isrd5.py"

	    ContentIDSequence =
		MakeSequence( SEQUENCE_STRING_tag, (INT_type) 0 );
	    if ( ContentIDSequence == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not make sequence" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        if ((p14 = prim2seq (p11)) == NULLPE) {
            advise (NULLCP, "content-portions bad sequence: %s",
                    pe_error (p11 -> pe_errno));
            return NOTOK;
        }
        p11 = p14;

        for (p14 = first_member (p11); p14; p14 = next_member (p11, p14)) {
#ifdef DEBUG
            (void) testdebug (p14, "element");
#endif

            if (parse_UNIV_NumericString (p14, 1, NULLIP, &(ContentIDChars ), NullParm) == NOTOK)
                return NOTOK;
            {
# line 830 "isrd5.py"

		ContentIDString = Chars2String(ContentIDChars);
		if ( ContentIDString == ERROR_STRING ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not convert content id chars to string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		if ( ExpandSequence(ContentIDSequence,
				    (INT_type) 1) == ERROR_INT ) {
		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not expand content id string" );
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		}
		ContentIDSequence ->
		    sequence_value.strings[
		      ContentIDSequence->length-1] = ContentIDString;
	    
            }
        }
        {
# line 850 "isrd5.py"

	    if ( GetAttr( parm->constituent,
			  at_OBJECT_IDENTIFIER,
			  (POINTER_type) &ParentID,
			  /* default */ BOOL_false,
			  /* mask */ (PARM_MASK_type *) 0
			) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not get parent id for subordinates");
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ContentPortions =
		ISODE_MakeSequenceConstituent( ParentID,
					       ContentIDSequence,
					       parm->document );
	    if ( ContentPortions == ERROR_SEQUENCE ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not convert content ids to constituents" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_CONTENT_PORTIONS,
			  (POINTER_type) ContentPortions,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not set attribute at_CONTENT_PORTIONS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 6)) {
#ifdef DEBUG
        (void) testdebug (p11, "presentation-attributes");
#endif

        if (parse_ISRD6_Presentation__Attributes (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        {
# line 890 "isrd5.py"


	
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 7)) {
#ifdef DEBUG
        (void) testdebug (p11, "default-value-lists");
#endif

        if (parse_ISRD7_Default__Value__Lists__Logical (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        {
# line 900 "isrd5.py"


	
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 8)) {
#ifdef DEBUG
        (void) testdebug (p11, "user-readable-comments");
#endif

        if (parse_ISRD4_Comment__String (p11, 0, &( CommentLength ), &(CommentChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 910 "isrd5.py"

	    CommentString = MakeString(CommentLength);
	    if ( CommentString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class_Descriptor]: can not make string");
		dummy = TKERR_EndErrMsg();
		return ( NOTOK );
	    }
	    CommentString->sequence_value.chars = CommentChars;
	    if ( SetAttr( parm->constituent,
			  at_USER_READABLE_COMMENTS,
			  (POINTER_type) CommentString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not set attribute at_USER_READABLE_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 9)) {
        register PE p15;

#ifdef DEBUG
        (void) testdebug (p11, "bindings");
#endif

        if ((p15 = prim2set (p11)) == NULLPE) {
            advise (NULLCP, "bindings bad set: %s",
                    pe_error (p11 -> pe_errno));
            return NOTOK;
        }
        p11 = p15;

        for (p15 = first_member (p11); p15; p15 = next_member (p11, p15)) {
#ifdef DEBUG
            (void) testdebug (p15, "member");
#endif

            if (parse_ISRD4_Binding__Pair (p15, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
            {
# line 937 "isrd5.py"


	
            }
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 10)) {
#ifdef DEBUG
        (void) testdebug (p11, "content-generator");
#endif

        if (parse_ISRD3_String__Expression (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        {
# line 947 "isrd5.py"


	
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 14)) {
#ifdef DEBUG
        (void) testdebug (p11, "user-visible-name");
#endif

        if (parse_ISRD4_Comment__String (p11, 0, &( NameLength ), &(NameChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 957 "isrd5.py"

	    NameString = MakeString(NameLength);
	    if ( CommentString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor]: can not make string");
		dummy = TKERR_EndErrMsg();
		return ( NOTOK );
	    }
	    NameString->sequence_value.chars = NameChars;
	    if ( SetAttr( parm->constituent,
			  at_USER_VISIBLE_NAME,
			  (POINTER_type) NameString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not set attribute at_USER_VISIBLE_NAME" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 17)) {
#ifdef DEBUG
        (void) testdebug (p11, "presentation-style");
#endif

        if (parse_ISRD3_Style__Identifier (p11, 0, NULLIP, &(PresentStyleIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 984 "isrd5.py"

	    PresentStyleIDString = Chars2String(PresentStyleIDChars);
	    if ( PresentStyleIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not convert presentation-style-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    PresentStyleBucket =
		ISODE_GetHashStructure(PresentStyleIDString,parm->document);
	    if ( PresentStyleBucket == ERROR_BUCKET ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not get hash structure" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    PresentStyle = PresentStyleBucket->constituent;
	    if ( SetAttr( parm->constituent,
			  at_PRESENTATION_STYLE,
			  (POINTER_type) PresentStyle,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not set attribute at_PRESENTATION_STYLE" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 19)) {
#ifdef DEBUG
        (void) testdebug (p11, "layout-style");
#endif

        if (parse_ISRD3_Style__Identifier (p11, 0, NULLIP, &(LayoutStyleIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 1019 "isrd5.py"

	    LayoutStyleIDString = Chars2String(LayoutStyleIDChars);
	    if ( LayoutStyleIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not convert layout-style-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    LayoutStyleBucket =
		ISODE_GetHashStructure(LayoutStyleIDString,parm->document);
	    if ( LayoutStyleBucket == ERROR_BUCKET ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not get hash structure" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    LayoutStyle = LayoutStyleBucket->constituent;
	    if ( SetAttr( parm->constituent,
			  at_LAYOUT_STYLE,
			  (POINTER_type) LayoutStyle,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not set attribute at_LAYOUT_STYLE" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 20)) {
#ifdef DEBUG
        (void) testdebug (p11, "protection");
#endif

        if (parse_ISRD5_Protection (p11, 0, &(Protection ), NULLVP, NullParm) == NOTOK)
            return NOTOK;
        {
# line 1054 "isrd5.py"

	    switch ( Protection ) {
		case 0:
		    ProtectionValue = at_PROTECTION_unprotected;
		    break;
		case 1:
		    ProtectionValue = at_PROTECTION_protected;
		    break;
	    }
	    if ( SetAttr( parm->constituent,
			  at_PROTECTION,
			  (POINTER_type) &ProtectionValue,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not set attribute at_PROTECTION" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 24)) {
#ifdef DEBUG
        (void) testdebug (p11, "resource");
#endif

        if (parse_ISRD3_Resource__Name (p11, 0, NULLIP, &(ResourceNameChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 1081 "isrd5.py"

	    ResourceNameString = Chars2String(ResourceNameChars);
	    if ( ResourceNameString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not convert resource-name to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_RESOURCE,
			  (POINTER_type) ResourceNameString,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not set attribute at_RESOURCE" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 25)) {
#ifdef DEBUG
        (void) testdebug (p11, "application-comments");
#endif

        if (parse_ISRD4_Comment__String (p11, 0, &( ApplCommentLength ), &(ApplCommentChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 1108 "isrd5.py"

	    ApplCommentString = MakeString(ApplCommentLength);
	    if ( ApplCommentString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not make string for attribute at_APPLICATION_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ApplCommentString->sequence_value.chars = ApplCommentChars;
	    ApplComment = String2Bytes(ApplCommentString);
	    if ( ApplComment == ERROR_SEQUENCE) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not make byte sequence for attribute at_APPLICATION_COMMENTS" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_APPLICATION_COMMENTS,
			  (POINTER_type) ApplComment,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD5_Logical__Class__Descriptor__Body]: can not set attribute at_CONTENT_INFORMATION" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
        }
        p11_count ++;
    }
    if (p11_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");

    return OK;
}

/* ARGSUSED */

int	parse_ISRD5_Protection (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p16;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD5.Protection");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "Protection bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "Protection bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p16 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "Protection bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p16;
    switch (p16) {
        case 0:	/* unprotected */
            break;
        case 1:	/* protected */
            break;
        default:
            advise (NULLCP, "Protection has unknown component: %d", p16);
            return NOTOK;
    }

    return OK;
}
