/* automatically generated by pepy 5.0 #1 (mss.andrew.cmu.edu), do not edit! */

#include <psap.h>

static char *pepyid = "pepy 5.0 #1 (mss.andrew.cmu.edu) of Mon May 22 20:44:32 EDT 1989";

#define	advise	PY_advise

void	advise ();

/* Generated from module ISPR5 */
# line 5 "ispr5.py"


/*
 *
 * (C) Copyright 1989 by Carnegie Mellon University
 *
 * Permission to use, copy, modify, and distribute these programs
 * and their documentation for any purpose and without fee is
 * hereby granted, provided that this copyright and permission
 * notice appear on all copies and supporting documentation, and
 * that the name of Carnegie Mellon University not be used in
 * advertising or publicity pertaining to distribution of the
 * programs without specific prior permission and notice be given
 * in supporting documentation that copying and distribution is
 * by permission of Carnegie Mellon University.
 *
 * Carnegie Mellon University makes no representations about the
 * suitability of this software for any purpose.  It is provided
 * as is, without express or implied warranty.
 *
 * Software by Ann Marks and James T. Lui,
 * Information Technology Center, Carnegie Mellon University,
 * except where noted.
 *
 */


#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	print_ISPR5_Logical__Object__Descriptor (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p0;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Logical-Object-Descriptor bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Logical-Object-Descriptor bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p0 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Logical-Object-Descriptor bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p0;

    vpush ();
    {
        register PE p1;

        if ((p1 = first_member (pe)) != NULLPE
                && PE_ID (p1 -> pe_class, p1 -> pe_id)
                        != PE_ID (PE_CLASS_UNIV, 2))
            p1 = NULLPE;
        if (p1 != NULLPE) {
            p0 = p1;

            {	/* object-type */
                vname ("object-type");
                if (print_ISPR5_Logical__Object__Type (p1, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p2;

        if ((p2 = (pe != p0 ? next_member (pe, p0) : first_member (pe))) != NULLPE) {
            p0 = p2;

            {	/* descriptor-body */
                vname ("descriptor-body");
                if (print_ISPR5_Logical__Object__Descriptor__Body (p2, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
    }

    vpop ();

    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Logical-Object-Descriptor has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR5_Logical__Object__Type (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p3;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "Logical-Object-Type bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "Logical-Object-Type bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p3 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "Logical-Object-Type bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p3;
    switch (p3) {
        case 0:	/* document-logical-root */
            vprint ("document-logical-root");
            break;
        case 1:	/* composite-logical-object */
            vprint ("composite-logical-object");
            break;
        case 2:	/* basic-logical-object */
            vprint ("basic-logical-object");
            break;
        default:
            advise (NULLCP, "Logical-Object-Type has unknown component: %d", p3);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR5_Logical__Object__Descriptor__Body (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p4_count = 0;
    register PE p4;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Logical-Object-Descriptor-Body bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Logical-Object-Descriptor-Body bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p4 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Logical-Object-Descriptor-Body bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p4;

    vpush ();
    if (p4 = set_find (pe, PE_CLASS_APPL, 1)) {
        vname ("object-identifier");
        if (print_ISPR3_Object__or__Class__Identifier (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 0)) {
        register PE p5;

        vname ("subordinates");
        if ((p5 = prim2seq (p4)) == NULLPE) {
            advise (NULLCP, "subordinates bad sequence: %s",
                    pe_error (p4 -> pe_errno));
            return NOTOK;
        }
        p4 = p5;

        vpush ();
        for (p5 = first_member (p4); p5; p5 = next_member (p4, p5)) {
            if (print_UNIV_NumericString (p5, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 1)) {
        register PE p6;

        vname ("content-portions");
        if ((p6 = prim2seq (p4)) == NULLPE) {
            advise (NULLCP, "content-portions bad sequence: %s",
                    pe_error (p4 -> pe_errno));
            return NOTOK;
        }
        p4 = p6;

        vpush ();
        for (p6 = first_member (p4); p6; p6 = next_member (p4, p6)) {
            if (print_UNIV_NumericString (p6, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 2)) {
        vname ("object-class");
        if (print_ISPR3_Object__or__Class__Identifier (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 6)) {
        vname ("presentation-attributes");
        if (print_ISPR6_Presentation__Attributes (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 7)) {
        vname ("default-value-lists");
        if (print_ISPR7_Default__Value__Lists__Logical (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 8)) {
        vname ("user-readable-comments");
        if (print_ISPR4_Comment__String (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 9)) {
        register PE p7;

        vname ("bindings");
        if ((p7 = prim2set (p4)) == NULLPE) {
            advise (NULLCP, "bindings bad set: %s",
                    pe_error (p4 -> pe_errno));
            return NOTOK;
        }
        p4 = p7;

        vpush ();
        for (p7 = first_member (p4); p7; p7 = next_member (p4, p7)) {
            if (print_ISPR4_Binding__Pair (p7, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 10)) {
        vname ("content-generator");
        if (print_ISPR3_String__Expression (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 14)) {
        vname ("user-visible-name");
        if (print_ISPR4_Comment__String (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 17)) {
        vname ("presentation-style");
        if (print_ISPR3_Style__Identifier (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 19)) {
        vname ("layout-style");
        if (print_ISPR3_Style__Identifier (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 20)) {
        vname ("protection");
        if (print_ISPR5_Protection (p4, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p4_count ++;
    }
    if (p4 = set_find (pe, PE_CLASS_CONT, 25)) {
        vname ("application-comments");
        vstring (p4);
        p4_count ++;
    }
    if (p4_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR5_Logical__Class__Descriptor (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p8;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Logical-Class-Descriptor bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Logical-Class-Descriptor bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p8 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Logical-Class-Descriptor bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p8;

    vpush ();
    {
        register PE p9;

        if ((p9 = first_member (pe)) != NULLPE) {
            p8 = p9;

            {	/* object-type */
                vname ("object-type");
                if (print_ISPR5_Logical__Object__Type (p9, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Logical-Class-Descriptor missing object-type element");
            return NOTOK;
        }

    }

    {
        register PE p10;

        if ((p10 = (pe != p8 ? next_member (pe, p8) : first_member (pe))) != NULLPE) {
            p8 = p10;

            {	/* descriptor-body */
                vname ("descriptor-body");
                if (print_ISPR5_Logical__Class__Descriptor__Body (p10, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Logical-Class-Descriptor missing descriptor-body element");
            return NOTOK;
        }

    }

    vpop ();

    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Logical-Class-Descriptor has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR5_Logical__Class__Descriptor__Body (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p11_count = 0;
    register PE p11;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Logical-Class-Descriptor-Body bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Logical-Class-Descriptor-Body bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p11 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Logical-Class-Descriptor-Body bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p11;

    vpush ();
    if (p11 = set_find (pe, PE_CLASS_APPL, 1)) {
        vname ("object-class-identifier");
        if (print_ISPR3_Object__or__Class__Identifier (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p11_count ++;
    }
    else {
        advise (NULLCP, "object-class-identifier missing object-class-identifier member");
        return NOTOK;
    }

    if (p11 = set_find (pe, PE_CLASS_CONT, 0)) {
        register PE p12 = p11;

        {	/* generator-for-subordinates TAG PULLUP */
            register PE p13;

            if ((p13 = prim2set (p12)) == NULLPE) {
                advise (NULLCP, "generator-for-subordinates bad generator-for-subordinates: %s",
                        pe_error (p12 -> pe_errno));
                return NOTOK;
            }
            if (p13 -> pe_cardinal != 1) {
                advise (NULLCP, "generator-for-subordinates too many elements for tagged generator-for-subordinates: %d",
                        p13 -> pe_cardinal);
                return NOTOK;
            }
            p12 = first_member (p13);
        }
        {
            vname ("generator-for-subordinates");
            if (print_ISPR3_Construction__Expression (p12, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 1)) {
        register PE p14;

        vname ("content-portions");
        if ((p14 = prim2seq (p11)) == NULLPE) {
            advise (NULLCP, "content-portions bad sequence: %s",
                    pe_error (p11 -> pe_errno));
            return NOTOK;
        }
        p11 = p14;

        vpush ();
        for (p14 = first_member (p11); p14; p14 = next_member (p11, p14)) {
            if (print_UNIV_NumericString (p14, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 6)) {
        vname ("presentation-attributes");
        if (print_ISPR6_Presentation__Attributes (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 7)) {
        vname ("default-value-lists");
        if (print_ISPR7_Default__Value__Lists__Logical (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 8)) {
        vname ("user-readable-comments");
        if (print_ISPR4_Comment__String (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 9)) {
        register PE p15;

        vname ("bindings");
        if ((p15 = prim2set (p11)) == NULLPE) {
            advise (NULLCP, "bindings bad set: %s",
                    pe_error (p11 -> pe_errno));
            return NOTOK;
        }
        p11 = p15;

        vpush ();
        for (p15 = first_member (p11); p15; p15 = next_member (p11, p15)) {
            if (print_ISPR4_Binding__Pair (p15, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 10)) {
        vname ("content-generator");
        if (print_ISPR3_String__Expression (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 14)) {
        vname ("user-visible-name");
        if (print_ISPR4_Comment__String (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 17)) {
        vname ("presentation-style");
        if (print_ISPR3_Style__Identifier (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 19)) {
        vname ("layout-style");
        if (print_ISPR3_Style__Identifier (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 20)) {
        vname ("protection");
        if (print_ISPR5_Protection (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 24)) {
        vname ("resource");
        if (print_ISPR3_Resource__Name (p11, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p11_count ++;
    }
    if (p11 = set_find (pe, PE_CLASS_CONT, 25)) {
        vname ("application-comments");
        vstring (p11);
        p11_count ++;
    }
    if (p11_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR5_Protection (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p16;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "Protection bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "Protection bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p16 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "Protection bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p16;
    switch (p16) {
        case 0:	/* unprotected */
            vprint ("unprotected");
            break;
        case 1:	/* protected */
            vprint ("protected");
            break;
        default:
            advise (NULLCP, "Protection has unknown component: %d", p16);
            return NOTOK;
    }

    return OK;
}
