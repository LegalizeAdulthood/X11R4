/* automatically generated by pepy 5.0 #1 (mss.andrew.cmu.edu), do not edit! */

#include <psap.h>

static char *pepyid = "pepy 5.0 #1 (mss.andrew.cmu.edu) of Mon May 22 20:44:32 EDT 1989";

#define	advise	PY_advise

void	advise ();

/* Generated from module ISPR3 */
# line 5 "ispr3.py"


/*
 *
 * (C) Copyright 1989 by Carnegie Mellon University
 *
 * Permission to use, copy, modify, and distribute these programs
 * and their documentation for any purpose and without fee is
 * hereby granted, provided that this copyright and permission
 * notice appear on all copies and supporting documentation, and
 * that the name of Carnegie Mellon University not be used in
 * advertising or publicity pertaining to distribution of the
 * programs without specific prior permission and notice be given
 * in supporting documentation that copying and distribution is
 * by permission of Carnegie Mellon University.
 *
 * Carnegie Mellon University makes no representations about the
 * suitability of this software for any purpose.  It is provided
 * as is, without express or implied warranty.
 *
 * Software by Ann Marks and James T. Lui,
 * Information Technology Center, Carnegie Mellon University,
 * except where noted.
 *
 */


#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	print_ISPR3_Content__Portion__Identifier (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_APPL, 0)) {
        advise (NULLCP, "Content-Portion-Identifier bad class/id: %s/0x%x", 
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (print_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Object__or__Class__Identifier (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_APPL, 1)) {
        advise (NULLCP, "Object-or-Class-Identifier bad class/id: %s/0x%x", 
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (print_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Style__Identifier (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_APPL, 5)) {
        advise (NULLCP, "Style-Identifier bad class/id: %s/0x%x", 
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (print_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Layout__Category__Name (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    if (print_UNIV_PrintableString (pe, explicit, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Resource__Name (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    if (print_UNIV_PrintableString (pe, explicit, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Binding__Name (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    if (print_UNIV_PrintableString (pe, explicit, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Construction__Expression (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    vpush ();
    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):
        case PE_ID (PE_CLASS_CONT, 1):
        case PE_ID (PE_CLASS_CONT, 2):	/* construction-type */
            {
                vname ("construction-type");
                if (print_ISPR3_Construction__Type (pe, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* single-term-construction */
            {
                register PE p0 = pe;

                {	/* single-term-construction TAG PULLUP */
                    register PE p1;

                    if ((p1 = prim2set (p0)) == NULLPE) {
                        advise (NULLCP, "single-term-construction bad single-term-construction: %s",
                                pe_error (p0 -> pe_errno));
                        return NOTOK;
                    }
                    if (p1 -> pe_cardinal != 1) {
                        advise (NULLCP, "single-term-construction too many elements for tagged single-term-construction: %d",
                                p1 -> pe_cardinal);
                        return NOTOK;
                    }
                    p0 = first_member (p1);
                }
                {
                    vname ("single-term-construction");
                    if (print_ISPR3_Construction__Term (p0, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;

        default:
            advise (NULLCP, "Construction-Expression has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Construction__Type (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    vpush ();
    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* sequence-construction */
            {
                vname ("sequence-construction");
                if (print_ISPR3_Term__Sequence (pe, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* aggregate-construction */
            {
                vname ("aggregate-construction");
                if (print_ISPR3_Term__Sequence (pe, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
            break;
        case PE_ID (PE_CLASS_CONT, 2):	/* choice-construction */
            {
                vname ("choice-construction");
                if (print_ISPR3_Term__Sequence (pe, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
            break;

        default:
            advise (NULLCP, "Construction-Type has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Term__Sequence (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p2;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Term-Sequence bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Term-Sequence bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p2 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Term-Sequence bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p2;

    vpush ();
    for (p2 = first_member (pe); p2; p2 = next_member (pe, p2)) {
        if (print_ISPR3_Construction__Term (p2, 1, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Construction__Term (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    vpush ();
    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* required-construction-factor */
            {
                register PE p3 = pe;

                {	/* required-construction-factor TAG PULLUP */
                    register PE p4;

                    if ((p4 = prim2set (p3)) == NULLPE) {
                        advise (NULLCP, "required-construction-factor bad required-construction-factor: %s",
                                pe_error (p3 -> pe_errno));
                        return NOTOK;
                    }
                    if (p4 -> pe_cardinal != 1) {
                        advise (NULLCP, "required-construction-factor too many elements for tagged required-construction-factor: %d",
                                p4 -> pe_cardinal);
                        return NOTOK;
                    }
                    p3 = first_member (p4);
                }
                {
                    vname ("required-construction-factor");
                    if (print_ISPR3_Construction__Factor (p3, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* optional-construction-factor */
            {
                register PE p5 = pe;

                {	/* optional-construction-factor TAG PULLUP */
                    register PE p6;

                    if ((p6 = prim2set (p5)) == NULLPE) {
                        advise (NULLCP, "optional-construction-factor bad optional-construction-factor: %s",
                                pe_error (p5 -> pe_errno));
                        return NOTOK;
                    }
                    if (p6 -> pe_cardinal != 1) {
                        advise (NULLCP, "optional-construction-factor too many elements for tagged optional-construction-factor: %d",
                                p6 -> pe_cardinal);
                        return NOTOK;
                    }
                    p5 = first_member (p6);
                }
                {
                    vname ("optional-construction-factor");
                    if (print_ISPR3_Construction__Factor (p5, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 2):	/* repetitive-construction-factor */
            {
                register PE p7 = pe;

                {	/* repetitive-construction-factor TAG PULLUP */
                    register PE p8;

                    if ((p8 = prim2set (p7)) == NULLPE) {
                        advise (NULLCP, "repetitive-construction-factor bad repetitive-construction-factor: %s",
                                pe_error (p7 -> pe_errno));
                        return NOTOK;
                    }
                    if (p8 -> pe_cardinal != 1) {
                        advise (NULLCP, "repetitive-construction-factor too many elements for tagged repetitive-construction-factor: %d",
                                p8 -> pe_cardinal);
                        return NOTOK;
                    }
                    p7 = first_member (p8);
                }
                {
                    vname ("repetitive-construction-factor");
                    if (print_ISPR3_Construction__Factor (p7, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* optional-repetitive-factor */
            {
                register PE p9 = pe;

                {	/* optional-repetitive-factor TAG PULLUP */
                    register PE p10;

                    if ((p10 = prim2set (p9)) == NULLPE) {
                        advise (NULLCP, "optional-repetitive-factor bad optional-repetitive-factor: %s",
                                pe_error (p9 -> pe_errno));
                        return NOTOK;
                    }
                    if (p10 -> pe_cardinal != 1) {
                        advise (NULLCP, "optional-repetitive-factor too many elements for tagged optional-repetitive-factor: %d",
                                p10 -> pe_cardinal);
                        return NOTOK;
                    }
                    p9 = first_member (p10);
                }
                {
                    vname ("optional-repetitive-factor");
                    if (print_ISPR3_Construction__Factor (p9, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;

        default:
            advise (NULLCP, "Construction-Term has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Construction__Factor (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    vpush ();
    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_APPL, 1):	/* object-class-identifier */
            {
                vname ("object-class-identifier");
                if (print_ISPR3_Object__or__Class__Identifier (pe, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
            break;
        case PE_ID (PE_CLASS_CONT, 0):
        case PE_ID (PE_CLASS_CONT, 1):
        case PE_ID (PE_CLASS_CONT, 2):
        case PE_ID (PE_CLASS_CONT, 3):	/* construction-expression */
            {
                vname ("construction-expression");
                if (print_ISPR3_Construction__Expression (pe, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
            break;

        default:
            advise (NULLCP, "Construction-Factor has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Object__Id__Expression (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    vpush ();
    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* current-object-function */
            {
                vname ("current-object-function");
                vprint ("NULL");
            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* preceding-object-function */
            {
                register PE p11 = pe;

                {	/* preceding-object-function TAG PULLUP */
                    register PE p12;

                    if ((p12 = prim2set (p11)) == NULLPE) {
                        advise (NULLCP, "preceding-object-function bad preceding-object-function: %s",
                                pe_error (p11 -> pe_errno));
                        return NOTOK;
                    }
                    if (p12 -> pe_cardinal != 1) {
                        advise (NULLCP, "preceding-object-function too many elements for tagged preceding-object-function: %d",
                                p12 -> pe_cardinal);
                        return NOTOK;
                    }
                    p11 = first_member (p12);
                }
                {
                    vname ("preceding-object-function");
                    if (print_ISPR3_Object__Id__Expression (p11, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* superior-object-function */
            {
                register PE p13 = pe;

                {	/* superior-object-function TAG PULLUP */
                    register PE p14;

                    if ((p14 = prim2set (p13)) == NULLPE) {
                        advise (NULLCP, "superior-object-function bad superior-object-function: %s",
                                pe_error (p13 -> pe_errno));
                        return NOTOK;
                    }
                    if (p14 -> pe_cardinal != 1) {
                        advise (NULLCP, "superior-object-function too many elements for tagged superior-object-function: %d",
                                p14 -> pe_cardinal);
                        return NOTOK;
                    }
                    p13 = first_member (p14);
                }
                {
                    vname ("superior-object-function");
                    if (print_ISPR3_Object__Id__Expression (p13, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 4):	/* current-instance-function */
            {
                register PE p15 = pe;

                {	/* current-instance-function TAG PULLUP */
                    register PE p16;

                    if ((p16 = prim2set (p15)) == NULLPE) {
                        advise (NULLCP, "current-instance-function bad current-instance-function: %s",
                                pe_error (p15 -> pe_errno));
                        return NOTOK;
                    }
                    if (p16 -> pe_cardinal != 1) {
                        advise (NULLCP, "current-instance-function too many elements for tagged current-instance-function: %d",
                                p16 -> pe_cardinal);
                        return NOTOK;
                    }
                    p15 = first_member (p16);
                }
                {
                    vname ("current-instance-function");
                    if (print_ISPR3_Current__Instance__Function (p15, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;

        default:
            advise (NULLCP, "Object-Id-Expression has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Numeric__Expression (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    vpush ();
    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* numeric-literal */
            {
                register int p17;

                vname ("numeric-literal");
                if ((p17 = prim2num (pe)) == NOTOK
                        && pe -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "numeric-literal bad integer: %s",
                            pe_error (pe -> pe_errno));
                    return NOTOK;
                }
                vprint ("%d", p17);
            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* increment-application */
            {
                register PE p18 = pe;

                {	/* increment-application TAG PULLUP */
                    register PE p19;

                    if ((p19 = prim2set (p18)) == NULLPE) {
                        advise (NULLCP, "increment-application bad increment-application: %s",
                                pe_error (p18 -> pe_errno));
                        return NOTOK;
                    }
                    if (p19 -> pe_cardinal != 1) {
                        advise (NULLCP, "increment-application too many elements for tagged increment-application: %d",
                                p19 -> pe_cardinal);
                        return NOTOK;
                    }
                    p18 = first_member (p19);
                }
                {
                    vname ("increment-application");
                    if (print_ISPR3_Numeric__Expression (p18, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 2):	/* decrement-application */
            {
                register PE p20 = pe;

                {	/* decrement-application TAG PULLUP */
                    register PE p21;

                    if ((p21 = prim2set (p20)) == NULLPE) {
                        advise (NULLCP, "decrement-application bad decrement-application: %s",
                                pe_error (p20 -> pe_errno));
                        return NOTOK;
                    }
                    if (p21 -> pe_cardinal != 1) {
                        advise (NULLCP, "decrement-application too many elements for tagged decrement-application: %d",
                                p21 -> pe_cardinal);
                        return NOTOK;
                    }
                    p20 = first_member (p21);
                }
                {
                    vname ("decrement-application");
                    if (print_ISPR3_Numeric__Expression (p20, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* ordinal-application */
            {
                register PE p22 = pe;

                {	/* ordinal-application TAG PULLUP */
                    register PE p23;

                    if ((p23 = prim2set (p22)) == NULLPE) {
                        advise (NULLCP, "ordinal-application bad ordinal-application: %s",
                                pe_error (p22 -> pe_errno));
                        return NOTOK;
                    }
                    if (p23 -> pe_cardinal != 1) {
                        advise (NULLCP, "ordinal-application too many elements for tagged ordinal-application: %d",
                                p23 -> pe_cardinal);
                        return NOTOK;
                    }
                    p22 = first_member (p23);
                }
                {
                    vname ("ordinal-application");
                    vpush ();
                    switch (PE_ID (p22 -> pe_class, p22 -> pe_id)) {
                        case PE_ID (PE_CLASS_APPL, 1):	/* identifier */
                            {
                                vname ("identifier");
                                if (print_ISPR3_Object__or__Class__Identifier (p22, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                                    return NOTOK;
                            }
                            break;
                        case PE_ID (PE_CLASS_CONT, 0):
                        case PE_ID (PE_CLASS_CONT, 1):
                        case PE_ID (PE_CLASS_CONT, 3):
                        case PE_ID (PE_CLASS_CONT, 4):	/* expression */
                            {
                                vname ("expression");
                                if (print_ISPR3_Object__Id__Expression (p22, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                                    return NOTOK;
                            }
                            break;

                        default:
                            advise (NULLCP, "ordinal-application has unknown choice: %s/%d/0x%x",
                                    pe_classlist[p22 -> pe_class], p22 -> pe_form, p22 -> pe_id);
                            return NOTOK;
                    }
                    vpop ();
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 4):	/* binding-reference */
            {
                vname ("binding-reference");
                if (print_ISPR3_Binding__Reference (pe, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
            break;

        default:
            advise (NULLCP, "Numeric-Expression has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Binding__Reference (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p24_count = 0;
    register PE p24;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Binding-Reference bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Binding-Reference bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p24 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Binding-Reference bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p24;

    vpush ();
    if ( (p24 = set_find (pe, PE_CLASS_APPL, 1))
        || (p24 = set_find (pe, PE_CLASS_CONT, 0))
        || (p24 = set_find (pe, PE_CLASS_CONT, 1))
        || (p24 = set_find (pe, PE_CLASS_CONT, 3))
        || (p24 = set_find (pe, PE_CLASS_CONT, 4)) ) {
        vname ("object-reference");
        vpush ();
        switch (PE_ID (p24 -> pe_class, p24 -> pe_id)) {
            case PE_ID (PE_CLASS_APPL, 1):	/* identifier */
                {
                    vname ("identifier");
                    if (print_ISPR3_Object__or__Class__Identifier (p24, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;
            case PE_ID (PE_CLASS_CONT, 0):
            case PE_ID (PE_CLASS_CONT, 1):
            case PE_ID (PE_CLASS_CONT, 3):
            case PE_ID (PE_CLASS_CONT, 4):	/* expression */
                {
                    vname ("expression");
                    if (print_ISPR3_Binding__Selection__Function (p24, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;

            default:
                advise (NULLCP, "object-reference has unknown choice: %s/%d/0x%x",
                        pe_classlist[p24 -> pe_class], p24 -> pe_form, p24 -> pe_id);
                return NOTOK;
        }
        vpop ();
        p24_count ++;
    }
    else {
        advise (NULLCP, "object-reference missing object-reference member");
        return NOTOK;
    }

    if (p24 = set_find (pe, PE_CLASS_UNIV, 19)) {
        vname ("binding-identifier");
        if (print_ISPR3_Binding__Name (p24, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p24_count ++;
    }
    else {
        advise (NULLCP, "binding-identifier missing binding-identifier member");
        return NOTOK;
    }

    if (p24_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Binding__Selection__Function (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    vpush ();
    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* current-object-function */
            {
                vname ("current-object-function");
                vprint ("NULL");
            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* preceding-function */
            {
                register PE p25 = pe;

                {	/* preceding-function TAG PULLUP */
                    register PE p26;

                    if ((p26 = prim2set (p25)) == NULLPE) {
                        advise (NULLCP, "preceding-function bad preceding-function: %s",
                                pe_error (p25 -> pe_errno));
                        return NOTOK;
                    }
                    if (p26 -> pe_cardinal != 1) {
                        advise (NULLCP, "preceding-function too many elements for tagged preceding-function: %d",
                                p26 -> pe_cardinal);
                        return NOTOK;
                    }
                    p25 = first_member (p26);
                }
                {
                    vname ("preceding-function");
                    if (print_ISPR3_Object__Id__Expression (p25, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* superior-function */
            {
                register PE p27 = pe;

                {	/* superior-function TAG PULLUP */
                    register PE p28;

                    if ((p28 = prim2set (p27)) == NULLPE) {
                        advise (NULLCP, "superior-function bad superior-function: %s",
                                pe_error (p27 -> pe_errno));
                        return NOTOK;
                    }
                    if (p28 -> pe_cardinal != 1) {
                        advise (NULLCP, "superior-function too many elements for tagged superior-function: %d",
                                p28 -> pe_cardinal);
                        return NOTOK;
                    }
                    p27 = first_member (p28);
                }
                {
                    vname ("superior-function");
                    if (print_ISPR3_Object__Id__Expression (p27, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 4):	/* current-instance-function */
            {
                register PE p29 = pe;

                {	/* current-instance-function TAG PULLUP */
                    register PE p30;

                    if ((p30 = prim2set (p29)) == NULLPE) {
                        advise (NULLCP, "current-instance-function bad current-instance-function: %s",
                                pe_error (p29 -> pe_errno));
                        return NOTOK;
                    }
                    if (p30 -> pe_cardinal != 1) {
                        advise (NULLCP, "current-instance-function too many elements for tagged current-instance-function: %d",
                                p30 -> pe_cardinal);
                        return NOTOK;
                    }
                    p29 = first_member (p30);
                }
                {
                    vname ("current-instance-function");
                    if (print_ISPR3_Current__Instance__Function (p29, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;

        default:
            advise (NULLCP, "Binding-Selection-Function has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Current__Instance__Function (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p31;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Current-Instance-Function bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Current-Instance-Function bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p31 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Current-Instance-Function bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p31;

    vpush ();
    {
        register PE p32;

        if ((p32 = first_member (pe)) != NULLPE) {
            p31 = p32;

            {	/* first-parameter */
                vname ("first-parameter");
                vpush ();
                switch (PE_ID (p32 -> pe_class, p32 -> pe_id)) {
                    case PE_ID (PE_CLASS_CONT, 0):	/* identifier */
                        {
                            vname ("identifier");
                            if (print_ISPR3_Object__or__Class__Identifier (p32, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                                return NOTOK;
                        }
                        break;
                    case PE_ID (PE_CLASS_CONT, 1):	/* layout-object-type */
                        {
                            vname ("layout-object-type");
                            if (print_ISPR4_Layout__Object__Type (p32, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                                return NOTOK;
                        }
                        break;
                    case PE_ID (PE_CLASS_CONT, 2):	/* logical-object-type */
                        {
                            vname ("logical-object-type");
                            if (print_ISPR5_Logical__Object__Type (p32, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                                return NOTOK;
                        }
                        break;

                    default:
                        advise (NULLCP, "first-parameter has unknown choice: %s/%d/0x%x",
                                pe_classlist[p32 -> pe_class], p32 -> pe_form, p32 -> pe_id);
                        return NOTOK;
                }
                vpop ();
            }
        }
        else {
            advise (NULLCP, "Current-Instance-Function missing first-parameter element");
            return NOTOK;
        }

    }

    {
        register PE p33;

        if ((p33 = (pe != p31 ? next_member (pe, p31) : first_member (pe))) != NULLPE) {
            p31 = p33;

            {	/* second-parameter */
                vname ("second-parameter");
                vpush ();
                switch (PE_ID (p33 -> pe_class, p33 -> pe_id)) {
                    case PE_ID (PE_CLASS_APPL, 1):	/* identifier */
                        {
                            vname ("identifier");
                            if (print_ISPR3_Object__or__Class__Identifier (p33, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                                return NOTOK;
                        }
                        break;
                    case PE_ID (PE_CLASS_CONT, 0):
                    case PE_ID (PE_CLASS_CONT, 1):
                    case PE_ID (PE_CLASS_CONT, 3):
                    case PE_ID (PE_CLASS_CONT, 4):	/* expression */
                        {
                            vname ("expression");
                            if (print_ISPR3_Object__Id__Expression (p33, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                                return NOTOK;
                        }
                        break;

                    default:
                        advise (NULLCP, "second-parameter has unknown choice: %s/%d/0x%x",
                                pe_classlist[p33 -> pe_class], p33 -> pe_form, p33 -> pe_id);
                        return NOTOK;
                }
                vpop ();
            }
        }
        else {
            advise (NULLCP, "Current-Instance-Function missing second-parameter element");
            return NOTOK;
        }

    }

    vpop ();

    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Current-Instance-Function has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_String__Expression (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p34;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "String-Expression bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "String-Expression bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p34 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "String-Expression bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p34;

    vpush ();
    for (p34 = first_member (pe); p34; p34 = next_member (pe, p34)) {
        if (print_ISPR3_Atomic__String__Expression (p34, 1, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR3_Atomic__String__Expression (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    vpush ();
    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* string-literal */
            {
                vname ("string-literal");
                vstring (pe);
            }
            break;
        case PE_ID (PE_CLASS_CONT, 2):	/* binding-reference */
            {
                vname ("binding-reference");
                if (print_ISPR3_Binding__Reference (pe, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* make-string-application */
            {
                register PE p35 = pe;

                {	/* make-string-application TAG PULLUP */
                    register PE p36;

                    if ((p36 = prim2set (p35)) == NULLPE) {
                        advise (NULLCP, "make-string-application bad make-string-application: %s",
                                pe_error (p35 -> pe_errno));
                        return NOTOK;
                    }
                    if (p36 -> pe_cardinal != 1) {
                        advise (NULLCP, "make-string-application too many elements for tagged make-string-application: %d",
                                p36 -> pe_cardinal);
                        return NOTOK;
                    }
                    p35 = first_member (p36);
                }
                {
                    vname ("make-string-application");
                    if (print_ISPR3_Numeric__Expression (p35, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 4):	/* upper-alpha-application */
            {
                register PE p37 = pe;

                {	/* upper-alpha-application TAG PULLUP */
                    register PE p38;

                    if ((p38 = prim2set (p37)) == NULLPE) {
                        advise (NULLCP, "upper-alpha-application bad upper-alpha-application: %s",
                                pe_error (p37 -> pe_errno));
                        return NOTOK;
                    }
                    if (p38 -> pe_cardinal != 1) {
                        advise (NULLCP, "upper-alpha-application too many elements for tagged upper-alpha-application: %d",
                                p38 -> pe_cardinal);
                        return NOTOK;
                    }
                    p37 = first_member (p38);
                }
                {
                    vname ("upper-alpha-application");
                    if (print_ISPR3_Numeric__Expression (p37, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 5):	/* lower-alpha-application */
            {
                register PE p39 = pe;

                {	/* lower-alpha-application TAG PULLUP */
                    register PE p40;

                    if ((p40 = prim2set (p39)) == NULLPE) {
                        advise (NULLCP, "lower-alpha-application bad lower-alpha-application: %s",
                                pe_error (p39 -> pe_errno));
                        return NOTOK;
                    }
                    if (p40 -> pe_cardinal != 1) {
                        advise (NULLCP, "lower-alpha-application too many elements for tagged lower-alpha-application: %d",
                                p40 -> pe_cardinal);
                        return NOTOK;
                    }
                    p39 = first_member (p40);
                }
                {
                    vname ("lower-alpha-application");
                    if (print_ISPR3_Numeric__Expression (p39, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 6):	/* upper-roman-application */
            {
                register PE p41 = pe;

                {	/* upper-roman-application TAG PULLUP */
                    register PE p42;

                    if ((p42 = prim2set (p41)) == NULLPE) {
                        advise (NULLCP, "upper-roman-application bad upper-roman-application: %s",
                                pe_error (p41 -> pe_errno));
                        return NOTOK;
                    }
                    if (p42 -> pe_cardinal != 1) {
                        advise (NULLCP, "upper-roman-application too many elements for tagged upper-roman-application: %d",
                                p42 -> pe_cardinal);
                        return NOTOK;
                    }
                    p41 = first_member (p42);
                }
                {
                    vname ("upper-roman-application");
                    if (print_ISPR3_Numeric__Expression (p41, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 7):	/* lower-roman-application */
            {
                register PE p43 = pe;

                {	/* lower-roman-application TAG PULLUP */
                    register PE p44;

                    if ((p44 = prim2set (p43)) == NULLPE) {
                        advise (NULLCP, "lower-roman-application bad lower-roman-application: %s",
                                pe_error (p43 -> pe_errno));
                        return NOTOK;
                    }
                    if (p44 -> pe_cardinal != 1) {
                        advise (NULLCP, "lower-roman-application too many elements for tagged lower-roman-application: %d",
                                p44 -> pe_cardinal);
                        return NOTOK;
                    }
                    p43 = first_member (p44);
                }
                {
                    vname ("lower-roman-application");
                    if (print_ISPR3_Numeric__Expression (p43, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;

        default:
            advise (NULLCP, "Atomic-String-Expression has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }
    vpop ();

    return OK;
}
