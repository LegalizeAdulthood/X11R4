/* automatically generated by pepy 5.0 #1 (mss.andrew.cmu.edu), do not edit! */

#include <psap.h>

static char *pepyid = "pepy 5.0 #1 (mss.andrew.cmu.edu) of Mon May 22 20:44:32 EDT 1989";

#define	advise	PY_advise

void	advise ();

/* Generated from module ISRD3 */
# line 5 "isrd3.py"


/*
 *
 * (C) Copyright 1989 by Carnegie Mellon University
 *
 * Permission to use, copy, modify, and distribute these programs
 * and their documentation for any purpose and without fee is
 * hereby granted, provided that this copyright and permission
 * notice appear on all copies and supporting documentation, and
 * that the name of Carnegie Mellon University not be used in
 * advertising or publicity pertaining to distribution of the
 * programs without specific prior permission and notice be given
 * in supporting documentation that copying and distribution is
 * by permission of Carnegie Mellon University.
 *
 * Carnegie Mellon University makes no representations about the
 * suitability of this software for any purpose.  It is provided
 * as is, without express or implied warranty.
 *
 * Software by Ann Marks and James T. Lui,
 * Information Technology Center, Carnegie Mellon University,
 * except where noted.
 *
 */

#define TK_TKI_TKERR
#define TK_TKI_APIRT
#define TK_TKI_MM

#include <odatk.h>

#undef TK_TKI_TKERR
#undef TK_TKI_APIRT
#undef TK_TKI_MM

#define TK_IMPL_ISRD

#include <isrd.h>

#undef TK_IMPL_ISRD

#define PEPYPARM struct isode2toolkit_t *

INT_type dummy;


#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	parse_ISRD3_Content__Portion__Identifier (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Content-Portion-Identifier");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_APPL, 0)) {
        advise (NULLCP, "Content-Portion-Identifier bad class/id: %s/0x%x", 
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (parse_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Object__or__Class__Identifier (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Object-or-Class-Identifier");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_APPL, 1)) {
        advise (NULLCP, "Object-or-Class-Identifier bad class/id: %s/0x%x", 
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (parse_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Style__Identifier (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Style-Identifier");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_APPL, 5)) {
        advise (NULLCP, "Style-Identifier bad class/id: %s/0x%x", 
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (parse_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Layout__Category__Name (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Layout-Category-Name");
#endif

    if (parse_UNIV_PrintableString (pe, explicit, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Resource__Name (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Resource-Name");
#endif

    if (parse_UNIV_PrintableString (pe, explicit, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Binding__Name (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Binding-Name");
#endif

    if (parse_UNIV_PrintableString (pe, explicit, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Construction__Expression (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
CONSTRUCTION_EXPR_type *  parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Construction-Expression");
#endif

    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):
        case PE_ID (PE_CLASS_CONT, 1):
        case PE_ID (PE_CLASS_CONT, 2):	/* construction-type */
            {
#ifdef DEBUG
                (void) testdebug (pe, "construction-type");
#endif

                if (parse_ISRD3_Construction__Type (pe, 1, NULLIP, NULLVP, parm ) == NOTOK)
                    return NOTOK;
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* single-term-construction */
            {
                register PE p0 = pe;

                {	/* single-term-construction TAG PULLUP */
                    register PE p1;

                    if ((p1 = prim2set (p0)) == NULLPE) {
                        advise (NULLCP, "single-term-construction bad single-term-construction: %s",
                                pe_error (p0 -> pe_errno));
                        return NOTOK;
                    }
                    if (p1 -> pe_cardinal != 1) {
                        advise (NULLCP, "single-term-construction too many elements for tagged single-term-construction: %d",
                                p1 -> pe_cardinal);
                        return NOTOK;
                    }
                    p0 = first_member (p1);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p0, "single-term-construction");
#endif

                    if (parse_ISRD3_Construction__Term (p0, 1, NULLIP, NULLVP, &(parm->construction_value.term) ) == NOTOK)
                        return NOTOK;
                    {
# line 132 "isrd3.py"

	    parm->construction_tag = TERM_tag;
	
                    }
                }
            }
            break;

        default:
            advise (NULLCP, "Construction-Expression has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Construction__Type (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
CONSTRUCTION_EXPR_type *  parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Construction-Type");
#endif

    {
# line 143 "isrd3.py"


    parm->construction_value.construction =
	MakeSequence( SEQUENCE_CONSTRUCTION_TERM_tag, (INT_type) 0 );
    if ( parm->construction_value.construction == ERROR_SEQUENCE ) {
	dummy = TKERR_StartErrMsg();
	dummy = TKERR_Format("[parse_ISRD3_Construction__Type]: can not make sequence for construction terms" );
	dummy = TKERR_EndErrMsg();
	return( NOTOK );
    }
    }
    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* sequence-construction */
            {
#ifdef DEBUG
                (void) testdebug (pe, "sequence-construction");
#endif

                if (parse_ISRD3_Term__Sequence (pe, 0, NULLIP, NULLVP, parm->construction_value.construction ) == NOTOK)
                    return NOTOK;
                {
# line 162 "isrd3.py"

	    parm->construction_tag = SEQUENCE_tag;
	
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* aggregate-construction */
            {
#ifdef DEBUG
                (void) testdebug (pe, "aggregate-construction");
#endif

                if (parse_ISRD3_Term__Sequence (pe, 0, NULLIP, NULLVP, parm->construction_value.construction ) == NOTOK)
                    return NOTOK;
                {
# line 171 "isrd3.py"

	    parm->construction_tag = AGGREGATE_tag;
	
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 2):	/* choice-construction */
            {
#ifdef DEBUG
                (void) testdebug (pe, "choice-construction");
#endif

                if (parse_ISRD3_Term__Sequence (pe, 0, NULLIP, NULLVP, parm->construction_value.construction ) == NOTOK)
                    return NOTOK;
                {
# line 180 "isrd3.py"

	    parm->construction_tag = CHOICE_tag;
	
                }
            }
            break;

        default:
            advise (NULLCP, "Construction-Type has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Term__Sequence (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
SEQUENCE_CONSTRUCTION_TERM_type  parm;
{
# line 189 "isrd3.py"
    
    POINTER_type memp;
    CONSTRUCTION_TERM_type *ConstructionTerm;

    register PE p2;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Term-Sequence");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Term-Sequence bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Term-Sequence bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p2 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Term-Sequence bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p2;

    for (p2 = first_member (pe); p2; p2 = next_member (pe, p2)) {
        {
# line 196 "isrd3.py"

	memp = MM_Malloc(sizeof(CONSTRUCTION_TERM_type));
	if ( memp == ERROR_POINTER ) {
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[parse_ISRD3_Term__Sequence]: out of memory" );
	    dummy = TKERR_EndErrMsg();
	    return( NOTOK );
	}
	ConstructionTerm = (CONSTRUCTION_TERM_type *) memp;
    
        }
        {
#ifdef DEBUG
            (void) testdebug (p2, "element");
#endif

            if (parse_ISRD3_Construction__Term (p2, 1, NULLIP, NULLVP, ConstructionTerm ) == NOTOK)
                return NOTOK;
            {
# line 209 "isrd3.py"

	if ( ExpandSequence( parm, (INT_type) 1 ) == ERROR_INT ) {
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[parse_ISRD3_Term__Sequence]: can not expand sequence of construction terms" );
	    dummy = TKERR_EndErrMsg();
	    dummy = MM_Free( ConstructionTerm );
	    return( NOTOK );
	}
	parm->sequence_value.construction_terms[parm->length-1] =
	    *ConstructionTerm;
	dummy = MM_Free( ConstructionTerm );
    
            }
        }
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Construction__Term (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
CONSTRUCTION_TERM_type *  parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Construction-Term");
#endif

    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* required-construction-factor */
            {
                register PE p3 = pe;

                {	/* required-construction-factor TAG PULLUP */
                    register PE p4;

                    if ((p4 = prim2set (p3)) == NULLPE) {
                        advise (NULLCP, "required-construction-factor bad required-construction-factor: %s",
                                pe_error (p3 -> pe_errno));
                        return NOTOK;
                    }
                    if (p4 -> pe_cardinal != 1) {
                        advise (NULLCP, "required-construction-factor too many elements for tagged required-construction-factor: %d",
                                p4 -> pe_cardinal);
                        return NOTOK;
                    }
                    p3 = first_member (p4);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p3, "required-construction-factor");
#endif

                    if (parse_ISRD3_Construction__Factor (p3, 1, NULLIP, NULLVP, &(parm->factor) ) == NOTOK)
                        return NOTOK;
                    {
# line 231 "isrd3.py"

	    parm->term_tag = REQ_tag;
	
                    }
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* optional-construction-factor */
            {
                register PE p5 = pe;

                {	/* optional-construction-factor TAG PULLUP */
                    register PE p6;

                    if ((p6 = prim2set (p5)) == NULLPE) {
                        advise (NULLCP, "optional-construction-factor bad optional-construction-factor: %s",
                                pe_error (p5 -> pe_errno));
                        return NOTOK;
                    }
                    if (p6 -> pe_cardinal != 1) {
                        advise (NULLCP, "optional-construction-factor too many elements for tagged optional-construction-factor: %d",
                                p6 -> pe_cardinal);
                        return NOTOK;
                    }
                    p5 = first_member (p6);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p5, "optional-construction-factor");
#endif

                    if (parse_ISRD3_Construction__Factor (p5, 1, NULLIP, NULLVP, &(parm->factor) ) == NOTOK)
                        return NOTOK;
                    {
# line 239 "isrd3.py"

	    parm->term_tag = OPT_tag;
	
                    }
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 2):	/* repetitive-construction-factor */
            {
                register PE p7 = pe;

                {	/* repetitive-construction-factor TAG PULLUP */
                    register PE p8;

                    if ((p8 = prim2set (p7)) == NULLPE) {
                        advise (NULLCP, "repetitive-construction-factor bad repetitive-construction-factor: %s",
                                pe_error (p7 -> pe_errno));
                        return NOTOK;
                    }
                    if (p8 -> pe_cardinal != 1) {
                        advise (NULLCP, "repetitive-construction-factor too many elements for tagged repetitive-construction-factor: %d",
                                p8 -> pe_cardinal);
                        return NOTOK;
                    }
                    p7 = first_member (p8);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p7, "repetitive-construction-factor");
#endif

                    if (parse_ISRD3_Construction__Factor (p7, 1, NULLIP, NULLVP, &(parm->factor) ) == NOTOK)
                        return NOTOK;
                    {
# line 247 "isrd3.py"

	    parm->term_tag = REP_tag;
	
                    }
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* optional-repetitive-factor */
            {
                register PE p9 = pe;

                {	/* optional-repetitive-factor TAG PULLUP */
                    register PE p10;

                    if ((p10 = prim2set (p9)) == NULLPE) {
                        advise (NULLCP, "optional-repetitive-factor bad optional-repetitive-factor: %s",
                                pe_error (p9 -> pe_errno));
                        return NOTOK;
                    }
                    if (p10 -> pe_cardinal != 1) {
                        advise (NULLCP, "optional-repetitive-factor too many elements for tagged optional-repetitive-factor: %d",
                                p10 -> pe_cardinal);
                        return NOTOK;
                    }
                    p9 = first_member (p10);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p9, "optional-repetitive-factor");
#endif

                    if (parse_ISRD3_Construction__Factor (p9, 1, NULLIP, NULLVP, &(parm->factor) ) == NOTOK)
                        return NOTOK;
                    {
# line 255 "isrd3.py"

	    parm->term_tag = OPT_REP_tag;
	
                    }
                }
            }
            break;

        default:
            advise (NULLCP, "Construction-Term has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Construction__Factor (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
CONSTRUCTION_FACTOR_type *  parm;
{
# line 264 "isrd3.py"
    
    POINTER_type memp;

    CHAR_type *ObjectClassIDChars;
    STRING_type ObjectClassIDString;
    struct hash_t *ObjectClassBucket;
    CONSTITUENT_type ObjectClass;
    DOCUMENT_type Document;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Construction-Factor");
#endif

    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_APPL, 1):	/* object-class-identifier */
            {
#ifdef DEBUG
                (void) testdebug (pe, "object-class-identifier");
#endif

                if (parse_ISRD3_Object__or__Class__Identifier (pe, 1, NULLIP, &(ObjectClassIDChars ), NullParm) == NOTOK)
                    return NOTOK;
                {
# line 280 "isrd3.py"

	    parm->factor_tag = OBJECT_CLASS_ID_tag;
	    ObjectClassIDString = Chars2String(ObjectClassIDChars);
	    if ( ObjectClassIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD3_Construction__Factor]: can not convert object-class-identifier to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    Document = GetSavedDocument();
	    if ( Document == ERROR_DOCUMENT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD3_Construction__Factor]:  could not get the document" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ObjectClassBucket =
		ISODE_GetHashStructure(ObjectClassIDString,Document);
	    if ( ObjectClassBucket == ERROR_BUCKET ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD3_Construction__Factor]: can not get hash structure" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ObjectClass = ObjectClassBucket->constituent;
	    parm->factor_value.object_class_id = ObjectClass;
	
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 0):
        case PE_ID (PE_CLASS_CONT, 1):
        case PE_ID (PE_CLASS_CONT, 2):
        case PE_ID (PE_CLASS_CONT, 3):	/* construction-expression */
            {
#ifdef DEBUG
                (void) testdebug (pe, "construction-expression");
#endif

                {
# line 310 "isrd3.py"

	    memp = MM_Malloc(sizeof(CONSTRUCTION_EXPR_type));
	    if ( memp == ERROR_POINTER ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD3_Construction__Factor]: out of memory" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    parm->factor_value.expr = (CONSTRUCTION_EXPR_type *) memp;
	
                }
                if (parse_ISRD3_Construction__Expression (pe, 1, NULLIP, NULLVP, parm->factor_value.expr ) == NOTOK)
                    return NOTOK;
                {
# line 323 "isrd3.py"

	    parm->factor_tag = EXPR_tag;
	
                }
            }
            break;

        default:
            advise (NULLCP, "Construction-Factor has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Object__Id__Expression (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Object-Id-Expression");
#endif

    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* current-object-function */
            {
#ifdef DEBUG
                (void) testdebug (pe, "current-object-function");
#endif

            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* preceding-object-function */
            {
                register PE p11 = pe;

                {	/* preceding-object-function TAG PULLUP */
                    register PE p12;

                    if ((p12 = prim2set (p11)) == NULLPE) {
                        advise (NULLCP, "preceding-object-function bad preceding-object-function: %s",
                                pe_error (p11 -> pe_errno));
                        return NOTOK;
                    }
                    if (p12 -> pe_cardinal != 1) {
                        advise (NULLCP, "preceding-object-function too many elements for tagged preceding-object-function: %d",
                                p12 -> pe_cardinal);
                        return NOTOK;
                    }
                    p11 = first_member (p12);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p11, "preceding-object-function");
#endif

                    if (parse_ISRD3_Object__Id__Expression (p11, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* superior-object-function */
            {
                register PE p13 = pe;

                {	/* superior-object-function TAG PULLUP */
                    register PE p14;

                    if ((p14 = prim2set (p13)) == NULLPE) {
                        advise (NULLCP, "superior-object-function bad superior-object-function: %s",
                                pe_error (p13 -> pe_errno));
                        return NOTOK;
                    }
                    if (p14 -> pe_cardinal != 1) {
                        advise (NULLCP, "superior-object-function too many elements for tagged superior-object-function: %d",
                                p14 -> pe_cardinal);
                        return NOTOK;
                    }
                    p13 = first_member (p14);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p13, "superior-object-function");
#endif

                    if (parse_ISRD3_Object__Id__Expression (p13, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 4):	/* current-instance-function */
            {
                register PE p15 = pe;

                {	/* current-instance-function TAG PULLUP */
                    register PE p16;

                    if ((p16 = prim2set (p15)) == NULLPE) {
                        advise (NULLCP, "current-instance-function bad current-instance-function: %s",
                                pe_error (p15 -> pe_errno));
                        return NOTOK;
                    }
                    if (p16 -> pe_cardinal != 1) {
                        advise (NULLCP, "current-instance-function too many elements for tagged current-instance-function: %d",
                                p16 -> pe_cardinal);
                        return NOTOK;
                    }
                    p15 = first_member (p16);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p15, "current-instance-function");
#endif

                    if (parse_ISRD3_Current__Instance__Function (p15, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;

        default:
            advise (NULLCP, "Object-Id-Expression has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Numeric__Expression (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Numeric-Expression");
#endif

    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* numeric-literal */
            {
#ifdef DEBUG
                (void) testdebug (pe, "numeric-literal");
#endif

                if (prim2num (pe) == NOTOK
                        && pe -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "numeric-literal bad integer: %s",
                            pe_error (pe -> pe_errno));
                    return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* increment-application */
            {
                register PE p17 = pe;

                {	/* increment-application TAG PULLUP */
                    register PE p18;

                    if ((p18 = prim2set (p17)) == NULLPE) {
                        advise (NULLCP, "increment-application bad increment-application: %s",
                                pe_error (p17 -> pe_errno));
                        return NOTOK;
                    }
                    if (p18 -> pe_cardinal != 1) {
                        advise (NULLCP, "increment-application too many elements for tagged increment-application: %d",
                                p18 -> pe_cardinal);
                        return NOTOK;
                    }
                    p17 = first_member (p18);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p17, "increment-application");
#endif

                    if (parse_ISRD3_Numeric__Expression (p17, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 2):	/* decrement-application */
            {
                register PE p19 = pe;

                {	/* decrement-application TAG PULLUP */
                    register PE p20;

                    if ((p20 = prim2set (p19)) == NULLPE) {
                        advise (NULLCP, "decrement-application bad decrement-application: %s",
                                pe_error (p19 -> pe_errno));
                        return NOTOK;
                    }
                    if (p20 -> pe_cardinal != 1) {
                        advise (NULLCP, "decrement-application too many elements for tagged decrement-application: %d",
                                p20 -> pe_cardinal);
                        return NOTOK;
                    }
                    p19 = first_member (p20);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p19, "decrement-application");
#endif

                    if (parse_ISRD3_Numeric__Expression (p19, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* ordinal-application */
            {
                register PE p21 = pe;

                {	/* ordinal-application TAG PULLUP */
                    register PE p22;

                    if ((p22 = prim2set (p21)) == NULLPE) {
                        advise (NULLCP, "ordinal-application bad ordinal-application: %s",
                                pe_error (p21 -> pe_errno));
                        return NOTOK;
                    }
                    if (p22 -> pe_cardinal != 1) {
                        advise (NULLCP, "ordinal-application too many elements for tagged ordinal-application: %d",
                                p22 -> pe_cardinal);
                        return NOTOK;
                    }
                    p21 = first_member (p22);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p21, "ordinal-application");
#endif

                    switch (PE_ID (p21 -> pe_class, p21 -> pe_id)) {
                        case PE_ID (PE_CLASS_APPL, 1):	/* identifier */
                            {
#ifdef DEBUG
                                (void) testdebug (p21, "identifier");
#endif

                                if (parse_ISRD3_Object__or__Class__Identifier (p21, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                                    return NOTOK;
                            }
                            break;
                        case PE_ID (PE_CLASS_CONT, 0):
                        case PE_ID (PE_CLASS_CONT, 1):
                        case PE_ID (PE_CLASS_CONT, 3):
                        case PE_ID (PE_CLASS_CONT, 4):	/* expression */
                            {
#ifdef DEBUG
                                (void) testdebug (p21, "expression");
#endif

                                if (parse_ISRD3_Object__Id__Expression (p21, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                                    return NOTOK;
                            }
                            break;

                        default:
                            advise (NULLCP, "ordinal-application has unknown choice: %s/%d/0x%x",
                                    pe_classlist[p21 -> pe_class], p21 -> pe_form, p21 -> pe_id);
                            return NOTOK;
                    }
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 4):	/* binding-reference */
            {
#ifdef DEBUG
                (void) testdebug (pe, "binding-reference");
#endif

                if (parse_ISRD3_Binding__Reference (pe, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
            break;

        default:
            advise (NULLCP, "Numeric-Expression has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Binding__Reference (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p23_count = 0;
    register PE p23;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Binding-Reference");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Binding-Reference bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Binding-Reference bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p23 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Binding-Reference bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p23;

    if ( (p23 = set_find (pe, PE_CLASS_APPL, 1))
        || (p23 = set_find (pe, PE_CLASS_CONT, 0))
        || (p23 = set_find (pe, PE_CLASS_CONT, 1))
        || (p23 = set_find (pe, PE_CLASS_CONT, 3))
        || (p23 = set_find (pe, PE_CLASS_CONT, 4)) ) {
#ifdef DEBUG
        (void) testdebug (p23, "object-reference");
#endif

        switch (PE_ID (p23 -> pe_class, p23 -> pe_id)) {
            case PE_ID (PE_CLASS_APPL, 1):	/* identifier */
                {
#ifdef DEBUG
                    (void) testdebug (p23, "identifier");
#endif

                    if (parse_ISRD3_Object__or__Class__Identifier (p23, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;
            case PE_ID (PE_CLASS_CONT, 0):
            case PE_ID (PE_CLASS_CONT, 1):
            case PE_ID (PE_CLASS_CONT, 3):
            case PE_ID (PE_CLASS_CONT, 4):	/* expression */
                {
#ifdef DEBUG
                    (void) testdebug (p23, "expression");
#endif

                    if (parse_ISRD3_Binding__Selection__Function (p23, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;

            default:
                advise (NULLCP, "object-reference has unknown choice: %s/%d/0x%x",
                        pe_classlist[p23 -> pe_class], p23 -> pe_form, p23 -> pe_id);
                return NOTOK;
        }
        p23_count ++;
    }
    else {
        advise (NULLCP, "object-reference missing object-reference member");
        return NOTOK;
    }

    if (p23 = set_find (pe, PE_CLASS_UNIV, 19)) {
#ifdef DEBUG
        (void) testdebug (p23, "binding-identifier");
#endif

        if (parse_ISRD3_Binding__Name (p23, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p23_count ++;
    }
    else {
        advise (NULLCP, "binding-identifier missing binding-identifier member");
        return NOTOK;
    }

    if (p23_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Binding__Selection__Function (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Binding-Selection-Function");
#endif

    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* current-object-function */
            {
#ifdef DEBUG
                (void) testdebug (pe, "current-object-function");
#endif

            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* preceding-function */
            {
                register PE p24 = pe;

                {	/* preceding-function TAG PULLUP */
                    register PE p25;

                    if ((p25 = prim2set (p24)) == NULLPE) {
                        advise (NULLCP, "preceding-function bad preceding-function: %s",
                                pe_error (p24 -> pe_errno));
                        return NOTOK;
                    }
                    if (p25 -> pe_cardinal != 1) {
                        advise (NULLCP, "preceding-function too many elements for tagged preceding-function: %d",
                                p25 -> pe_cardinal);
                        return NOTOK;
                    }
                    p24 = first_member (p25);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p24, "preceding-function");
#endif

                    if (parse_ISRD3_Object__Id__Expression (p24, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* superior-function */
            {
                register PE p26 = pe;

                {	/* superior-function TAG PULLUP */
                    register PE p27;

                    if ((p27 = prim2set (p26)) == NULLPE) {
                        advise (NULLCP, "superior-function bad superior-function: %s",
                                pe_error (p26 -> pe_errno));
                        return NOTOK;
                    }
                    if (p27 -> pe_cardinal != 1) {
                        advise (NULLCP, "superior-function too many elements for tagged superior-function: %d",
                                p27 -> pe_cardinal);
                        return NOTOK;
                    }
                    p26 = first_member (p27);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p26, "superior-function");
#endif

                    if (parse_ISRD3_Object__Id__Expression (p26, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 4):	/* current-instance-function */
            {
                register PE p28 = pe;

                {	/* current-instance-function TAG PULLUP */
                    register PE p29;

                    if ((p29 = prim2set (p28)) == NULLPE) {
                        advise (NULLCP, "current-instance-function bad current-instance-function: %s",
                                pe_error (p28 -> pe_errno));
                        return NOTOK;
                    }
                    if (p29 -> pe_cardinal != 1) {
                        advise (NULLCP, "current-instance-function too many elements for tagged current-instance-function: %d",
                                p29 -> pe_cardinal);
                        return NOTOK;
                    }
                    p28 = first_member (p29);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p28, "current-instance-function");
#endif

                    if (parse_ISRD3_Current__Instance__Function (p28, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;

        default:
            advise (NULLCP, "Binding-Selection-Function has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Current__Instance__Function (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p30;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Current-Instance-Function");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Current-Instance-Function bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Current-Instance-Function bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p30 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Current-Instance-Function bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p30;

    {
        register PE p31;

        if ((p31 = first_member (pe)) != NULLPE) {
            p30 = p31;

            {	/* first-parameter */
#ifdef DEBUG
                (void) testdebug (p31, "first-parameter");
#endif

                switch (PE_ID (p31 -> pe_class, p31 -> pe_id)) {
                    case PE_ID (PE_CLASS_CONT, 0):	/* identifier */
                        {
#ifdef DEBUG
                            (void) testdebug (p31, "identifier");
#endif

                            if (parse_ISRD3_Object__or__Class__Identifier (p31, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                                return NOTOK;
                        }
                        break;
                    case PE_ID (PE_CLASS_CONT, 1):	/* layout-object-type */
                        {
#ifdef DEBUG
                            (void) testdebug (p31, "layout-object-type");
#endif

                            if (parse_ISRD4_Layout__Object__Type (p31, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                                return NOTOK;
                        }
                        break;
                    case PE_ID (PE_CLASS_CONT, 2):	/* logical-object-type */
                        {
#ifdef DEBUG
                            (void) testdebug (p31, "logical-object-type");
#endif

                            if (parse_ISRD5_Logical__Object__Type (p31, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                                return NOTOK;
                        }
                        break;

                    default:
                        advise (NULLCP, "first-parameter has unknown choice: %s/%d/0x%x",
                                pe_classlist[p31 -> pe_class], p31 -> pe_form, p31 -> pe_id);
                        return NOTOK;
                }
            }
        }
        else {
            advise (NULLCP, "Current-Instance-Function missing first-parameter element");
            return NOTOK;
        }

    }

    {
        register PE p32;

        if ((p32 = (pe != p30 ? next_member (pe, p30) : first_member (pe))) != NULLPE) {
            p30 = p32;

            {	/* second-parameter */
#ifdef DEBUG
                (void) testdebug (p32, "second-parameter");
#endif

                switch (PE_ID (p32 -> pe_class, p32 -> pe_id)) {
                    case PE_ID (PE_CLASS_APPL, 1):	/* identifier */
                        {
#ifdef DEBUG
                            (void) testdebug (p32, "identifier");
#endif

                            if (parse_ISRD3_Object__or__Class__Identifier (p32, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                                return NOTOK;
                        }
                        break;
                    case PE_ID (PE_CLASS_CONT, 0):
                    case PE_ID (PE_CLASS_CONT, 1):
                    case PE_ID (PE_CLASS_CONT, 3):
                    case PE_ID (PE_CLASS_CONT, 4):	/* expression */
                        {
#ifdef DEBUG
                            (void) testdebug (p32, "expression");
#endif

                            if (parse_ISRD3_Object__Id__Expression (p32, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                                return NOTOK;
                        }
                        break;

                    default:
                        advise (NULLCP, "second-parameter has unknown choice: %s/%d/0x%x",
                                pe_classlist[p32 -> pe_class], p32 -> pe_form, p32 -> pe_id);
                        return NOTOK;
                }
            }
        }
        else {
            advise (NULLCP, "Current-Instance-Function missing second-parameter element");
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Current-Instance-Function has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_String__Expression (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p33;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.String-Expression");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "String-Expression bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "String-Expression bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p33 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "String-Expression bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p33;

    for (p33 = first_member (pe); p33; p33 = next_member (pe, p33)) {
#ifdef DEBUG
        (void) testdebug (p33, "element");
#endif

        if (parse_ISRD3_Atomic__String__Expression (p33, 1, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD3_Atomic__String__Expression (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD3.Atomic-String-Expression");
#endif

    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* string-literal */
            {
#ifdef DEBUG
                (void) testdebug (pe, "string-literal");
#endif

            }
            break;
        case PE_ID (PE_CLASS_CONT, 2):	/* binding-reference */
            {
#ifdef DEBUG
                (void) testdebug (pe, "binding-reference");
#endif

                if (parse_ISRD3_Binding__Reference (pe, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* make-string-application */
            {
                register PE p34 = pe;

                {	/* make-string-application TAG PULLUP */
                    register PE p35;

                    if ((p35 = prim2set (p34)) == NULLPE) {
                        advise (NULLCP, "make-string-application bad make-string-application: %s",
                                pe_error (p34 -> pe_errno));
                        return NOTOK;
                    }
                    if (p35 -> pe_cardinal != 1) {
                        advise (NULLCP, "make-string-application too many elements for tagged make-string-application: %d",
                                p35 -> pe_cardinal);
                        return NOTOK;
                    }
                    p34 = first_member (p35);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p34, "make-string-application");
#endif

                    if (parse_ISRD3_Numeric__Expression (p34, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 4):	/* upper-alpha-application */
            {
                register PE p36 = pe;

                {	/* upper-alpha-application TAG PULLUP */
                    register PE p37;

                    if ((p37 = prim2set (p36)) == NULLPE) {
                        advise (NULLCP, "upper-alpha-application bad upper-alpha-application: %s",
                                pe_error (p36 -> pe_errno));
                        return NOTOK;
                    }
                    if (p37 -> pe_cardinal != 1) {
                        advise (NULLCP, "upper-alpha-application too many elements for tagged upper-alpha-application: %d",
                                p37 -> pe_cardinal);
                        return NOTOK;
                    }
                    p36 = first_member (p37);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p36, "upper-alpha-application");
#endif

                    if (parse_ISRD3_Numeric__Expression (p36, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 5):	/* lower-alpha-application */
            {
                register PE p38 = pe;

                {	/* lower-alpha-application TAG PULLUP */
                    register PE p39;

                    if ((p39 = prim2set (p38)) == NULLPE) {
                        advise (NULLCP, "lower-alpha-application bad lower-alpha-application: %s",
                                pe_error (p38 -> pe_errno));
                        return NOTOK;
                    }
                    if (p39 -> pe_cardinal != 1) {
                        advise (NULLCP, "lower-alpha-application too many elements for tagged lower-alpha-application: %d",
                                p39 -> pe_cardinal);
                        return NOTOK;
                    }
                    p38 = first_member (p39);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p38, "lower-alpha-application");
#endif

                    if (parse_ISRD3_Numeric__Expression (p38, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 6):	/* upper-roman-application */
            {
                register PE p40 = pe;

                {	/* upper-roman-application TAG PULLUP */
                    register PE p41;

                    if ((p41 = prim2set (p40)) == NULLPE) {
                        advise (NULLCP, "upper-roman-application bad upper-roman-application: %s",
                                pe_error (p40 -> pe_errno));
                        return NOTOK;
                    }
                    if (p41 -> pe_cardinal != 1) {
                        advise (NULLCP, "upper-roman-application too many elements for tagged upper-roman-application: %d",
                                p41 -> pe_cardinal);
                        return NOTOK;
                    }
                    p40 = first_member (p41);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p40, "upper-roman-application");
#endif

                    if (parse_ISRD3_Numeric__Expression (p40, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 7):	/* lower-roman-application */
            {
                register PE p42 = pe;

                {	/* lower-roman-application TAG PULLUP */
                    register PE p43;

                    if ((p43 = prim2set (p42)) == NULLPE) {
                        advise (NULLCP, "lower-roman-application bad lower-roman-application: %s",
                                pe_error (p42 -> pe_errno));
                        return NOTOK;
                    }
                    if (p43 -> pe_cardinal != 1) {
                        advise (NULLCP, "lower-roman-application too many elements for tagged lower-roman-application: %d",
                                p43 -> pe_cardinal);
                        return NOTOK;
                    }
                    p42 = first_member (p43);
                }
                {
#ifdef DEBUG
                    (void) testdebug (p42, "lower-roman-application");
#endif

                    if (parse_ISRD3_Numeric__Expression (p42, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            break;

        default:
            advise (NULLCP, "Atomic-String-Expression has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }

    return OK;
}
