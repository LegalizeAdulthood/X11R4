/* automatically generated by pepy 5.0 #1 (mss.andrew.cmu.edu), do not edit! */

#include <psap.h>

static char *pepyid = "pepy 5.0 #1 (mss.andrew.cmu.edu) of Mon May 22 20:44:32 EDT 1989";

#define	advise	PY_advise

void	advise ();

/* Generated from module ISPR4 */
# line 5 "ispr4.py"


/*
 *
 * (C) Copyright 1989 by Carnegie Mellon University
 *
 * Permission to use, copy, modify, and distribute these programs
 * and their documentation for any purpose and without fee is
 * hereby granted, provided that this copyright and permission
 * notice appear on all copies and supporting documentation, and
 * that the name of Carnegie Mellon University not be used in
 * advertising or publicity pertaining to distribution of the
 * programs without specific prior permission and notice be given
 * in supporting documentation that copying and distribution is
 * by permission of Carnegie Mellon University.
 *
 * Carnegie Mellon University makes no representations about the
 * suitability of this software for any purpose.  It is provided
 * as is, without express or implied warranty.
 *
 * Software by Ann Marks and James T. Lui,
 * Information Technology Center, Carnegie Mellon University,
 * except where noted.
 *
 */


#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	print_ISPR4_Position__Spec (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p0_count = 0;
    register PE p0;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Position-Spec bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Position-Spec bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p0 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Position-Spec bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p0;

    vpush ();
    if (p0 = set_find (pe, PE_CLASS_CONT, 0)) {
        int p1_count = 0;
        register PE p1;

        vname ("offset");
        if ((p1 = prim2set (p0)) == NULLPE) {
            advise (NULLCP, "offset bad set: %s",
                    pe_error (p0 -> pe_errno));
            return NOTOK;
        }
        p0 = p1;

        vpush ();
        if (p1 = set_find (p0, PE_CLASS_CONT, 0)) {
            register int p2;

            vname ("leading");
            if ((p2 = prim2num (p1)) == NOTOK
                    && p1 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "leading bad integer: %s",
                        pe_error (p1 -> pe_errno));
                return NOTOK;
            }
            vprint ("%d", p2);
            p1_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p1 = set_find (p0, PE_CLASS_CONT, 1)) {
            register int p3;

            vname ("trailing");
            if ((p3 = prim2num (p1)) == NOTOK
                    && p1 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "trailing bad integer: %s",
                        pe_error (p1 -> pe_errno));
                return NOTOK;
            }
            vprint ("%d", p3);
            p1_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p1 = set_find (p0, PE_CLASS_CONT, 2)) {
            register int p4;

            vname ("left-hand");
            if ((p4 = prim2num (p1)) == NOTOK
                    && p1 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "left-hand bad integer: %s",
                        pe_error (p1 -> pe_errno));
                return NOTOK;
            }
            vprint ("%d", p4);
            p1_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p1 = set_find (p0, PE_CLASS_CONT, 3)) {
            register int p5;

            vname ("right-hand");
            if ((p5 = prim2num (p1)) == NOTOK
                    && p1 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "right-hand bad integer: %s",
                        pe_error (p1 -> pe_errno));
                return NOTOK;
            }
            vprint ("%d", p5);
            p1_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p1_count != p0 -> pe_cardinal)
            advise (NULLCP, "warning: extra or duplicate members present in SET");
        vpop ();
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 1)) {
        int p6_count = 0;
        register PE p6;

        vname ("separation");
        if ((p6 = prim2set (p0)) == NULLPE) {
            advise (NULLCP, "separation bad set: %s",
                    pe_error (p0 -> pe_errno));
            return NOTOK;
        }
        p0 = p6;

        vpush ();
        if (p6 = set_find (p0, PE_CLASS_CONT, 0)) {
            register int p7;

            vname ("leading");
            if ((p7 = prim2num (p6)) == NOTOK
                    && p6 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "leading bad integer: %s",
                        pe_error (p6 -> pe_errno));
                return NOTOK;
            }
            vprint ("%d", p7);
            p6_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p6 = set_find (p0, PE_CLASS_CONT, 1)) {
            register int p8;

            vname ("trailing");
            if ((p8 = prim2num (p6)) == NOTOK
                    && p6 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "trailing bad integer: %s",
                        pe_error (p6 -> pe_errno));
                return NOTOK;
            }
            vprint ("%d", p8);
            p6_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p6 = set_find (p0, PE_CLASS_CONT, 2)) {
            register int p9;

            vname ("centre");
            if ((p9 = prim2num (p6)) == NOTOK
                    && p6 -> pe_errno != PE_ERR_NONE) {
                advise (NULLCP, "centre bad integer: %s",
                        pe_error (p6 -> pe_errno));
                return NOTOK;
            }
            vprint ("%d", p9);
            p6_count ++;
        }
        else {
            /* set default here using yp -> yp_default */
        }

        if (p6_count != p0 -> pe_cardinal)
            advise (NULLCP, "warning: extra or duplicate members present in SET");
        vpop ();
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 2)) {
        register int p10;

        vname ("alignment");
        if ((p10 = prim2num (p0)) == NOTOK
                && p0 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "alignment bad integer: %s",
                    pe_error (p0 -> pe_errno));
            return NOTOK;
        }
        switch (p10) {
            case 0:	/* right-hand */
                vprint ("right-hand");
                break;
            case 1:	/* centred */
                vprint ("centred");
                break;
            case 2:	/* left-hand */
                vprint ("left-hand");
                break;
            default:
                advise (NULLCP, "alignment has unknown component: %d", p10);
                return NOTOK;
        }
        p0_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p0 = set_find (pe, PE_CLASS_CONT, 3)) {
        register int p11;

        vname ("fill-order");
        if ((p11 = prim2num (p0)) == NOTOK
                && p0 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "fill-order bad integer: %s",
                    pe_error (p0 -> pe_errno));
            return NOTOK;
        }
        switch (p11) {
            case 0:	/* normal */
                vprint ("normal");
                break;
            case 1:	/* reverse */
                vprint ("reverse");
                break;
            default:
                advise (NULLCP, "fill-order has unknown component: %d", p11);
                return NOTOK;
        }
        p0_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p0_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Dimension__Pair (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p12;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Dimension-Pair bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Dimension-Pair bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p12 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Dimension-Pair bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p12;

    vpush ();
    {
        register PE p13;

        if ((p13 = first_member (pe)) != NULLPE) {
            p12 = p13;

            {	/* horizontal */
                register int p14;

                vname ("horizontal");
                if ((p14 = prim2num (p13)) == NOTOK
                        && p13 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "horizontal bad integer: %s",
                            pe_error (p13 -> pe_errno));
                    return NOTOK;
                }
                vprint ("%d", p14);
            }
        }
        else {
            advise (NULLCP, "Dimension-Pair missing horizontal element");
            return NOTOK;
        }

    }

    {
        register PE p15;

        if ((p15 = (pe != p12 ? next_member (pe, p12) : first_member (pe))) != NULLPE) {
            p12 = p15;

            {	/* vertical */
                vname ("vertical");
                vpush ();
                switch (PE_ID (p15 -> pe_class, p15 -> pe_id)) {
                    case PE_ID (PE_CLASS_CONT, 0):	/* fixed */
                        {
                            register int p16;

                            vname ("fixed");
                            if ((p16 = prim2num (p15)) == NOTOK
                                    && p15 -> pe_errno != PE_ERR_NONE) {
                                advise (NULLCP, "fixed bad integer: %s",
                                        pe_error (p15 -> pe_errno));
                                return NOTOK;
                            }
                            vprint ("%d", p16);
                        }
                        break;
                    case PE_ID (PE_CLASS_CONT, 1):	/* variable */
                        {
                            register int p17;

                            vname ("variable");
                            if ((p17 = prim2num (p15)) == NOTOK
                                    && p15 -> pe_errno != PE_ERR_NONE) {
                                advise (NULLCP, "variable bad integer: %s",
                                        pe_error (p15 -> pe_errno));
                                return NOTOK;
                            }
                            vprint ("%d", p17);
                        }
                        break;

                    default:
                        advise (NULLCP, "vertical has unknown choice: %s/%d/0x%x",
                                pe_classlist[p15 -> pe_class], p15 -> pe_form, p15 -> pe_id);
                        return NOTOK;
                }
                vpop ();
            }
        }
        else {
            advise (NULLCP, "Dimension-Pair missing vertical element");
            return NOTOK;
        }

    }

    vpop ();

    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Dimension-Pair has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Dimension__Spec (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p18;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Dimension-Spec bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Dimension-Spec bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p18 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Dimension-Spec bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p18;

    vpush ();
    {
        register PE p19;

        if ((p19 = first_member (pe)) != NULLPE) {
            p18 = p19;

            {	/* horizontal */
                vname ("horizontal");
                if (print_ISPR4_Dimension (p19, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Dimension-Spec missing horizontal element");
            return NOTOK;
        }

    }

    {
        register PE p20;

        if ((p20 = (pe != p18 ? next_member (pe, p18) : first_member (pe))) != NULLPE) {
            p18 = p20;

            {	/* vertical */
                vname ("vertical");
                if (print_ISPR4_Dimension (p20, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Dimension-Spec missing vertical element");
            return NOTOK;
        }

    }

    vpop ();

    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Dimension-Spec has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Dimension (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    vpush ();
    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):	/* fixed */
            {
                register int p21;

                vname ("fixed");
                if ((p21 = prim2num (pe)) == NOTOK
                        && pe -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "fixed bad integer: %s",
                            pe_error (pe -> pe_errno));
                    return NOTOK;
                }
                vprint ("%d", p21);
            }
            break;
        case PE_ID (PE_CLASS_CONT, 1):	/* rule-a */
            {
                int p22_count = 0;
                register PE p22;

                vname ("rule-a");
                if ((p22 = prim2set (pe)) == NULLPE) {
                    advise (NULLCP, "rule-a bad set: %s",
                            pe_error (pe -> pe_errno));
                    return NOTOK;
                }
                pe = p22;

                vpush ();
                if (p22 = set_find (pe, PE_CLASS_CONT, 0)) {
                    register int p23;

                    vname ("minimum-a");
                    if ((p23 = prim2num (p22)) == NOTOK
                            && p22 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "minimum-a bad integer: %s",
                                pe_error (p22 -> pe_errno));
                        return NOTOK;
                    }
                    vprint ("%d", p23);
                    p22_count ++;
                }
                else {
                    /* set default here using yp -> yp_default */
                }

                if (p22 = set_find (pe, PE_CLASS_CONT, 1)) {
                    register int p24;

                    vname ("maximum-a");
                    if ((p24 = prim2num (p22)) == NOTOK
                            && p22 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "maximum-a bad integer: %s",
                                pe_error (p22 -> pe_errno));
                        return NOTOK;
                    }
                    vprint ("%d", p24);
                    p22_count ++;
                }
                else {
                    /* set default here using yp -> yp_default */
                }

                if (p22_count != pe -> pe_cardinal)
                    advise (NULLCP, "warning: extra or duplicate members present in SET");
                vpop ();
            }
            break;
        case PE_ID (PE_CLASS_CONT, 2):	/* rule-b */
            {
                int p25_count = 0;
                register PE p25;

                vname ("rule-b");
                if ((p25 = prim2set (pe)) == NULLPE) {
                    advise (NULLCP, "rule-b bad set: %s",
                            pe_error (pe -> pe_errno));
                    return NOTOK;
                }
                pe = p25;

                vpush ();
                if (p25 = set_find (pe, PE_CLASS_CONT, 0)) {
                    register int p26;

                    vname ("minimum-b");
                    if ((p26 = prim2num (p25)) == NOTOK
                            && p25 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "minimum-b bad integer: %s",
                                pe_error (p25 -> pe_errno));
                        return NOTOK;
                    }
                    vprint ("%d", p26);
                    p25_count ++;
                }
                else {
                    /* set default here using yp -> yp_default */
                }

                if (p25 = set_find (pe, PE_CLASS_CONT, 1)) {
                    register int p27;

                    vname ("maximum-b");
                    if ((p27 = prim2num (p25)) == NOTOK
                            && p25 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "maximum-b bad integer: %s",
                                pe_error (p25 -> pe_errno));
                        return NOTOK;
                    }
                    vprint ("%d", p27);
                    p25_count ++;
                }
                else {
                    /* set default here using yp -> yp_default */
                }

                if (p25_count != pe -> pe_cardinal)
                    advise (NULLCP, "warning: extra or duplicate members present in SET");
                vpop ();
            }
            break;
        case PE_ID (PE_CLASS_CONT, 3):	/* maximum-size */
            {
                vname ("maximum-size");
                vprint ("NULL");
            }
            break;

        default:
            advise (NULLCP, "Dimension has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Transparency (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p28;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "Transparency bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "Transparency bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p28 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "Transparency bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p28;
    switch (p28) {
        case 0:	/* transparent */
            vprint ("transparent");
            break;
        case 1:	/* opaque */
            vprint ("opaque");
            break;
        default:
            advise (NULLCP, "Transparency has unknown component: %d", p28);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Comment__String (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register char *p29;
    int p29_len;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV || pe -> pe_id != PE_PRIM_OCTS) {
            advise (NULLCP, "Comment-String bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }

    if ((p29 = prim2str (pe, &p29_len)) == NULLCP) {
        advise (NULLCP, "Comment-String bad octetstring: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    vstring (pe);
    if (len)
        *len = p29_len;
    if (buffer)
        *buffer = p29;
    else
        if (p29)
            free (p29);

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Binding__Pair (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p30_count = 0;
    register PE p30;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Binding-Pair bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Binding-Pair bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p30 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Binding-Pair bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p30;

    vpush ();
    if (p30 = set_find (pe, PE_CLASS_CONT, 0)) {
        vname ("binding-identifier");
        if (print_ISPR3_Binding__Name (p30, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p30_count ++;
    }
    else {
        advise (NULLCP, "binding-identifier missing binding-identifier member");
        return NOTOK;
    }

    if ( (p30 = set_find (pe, PE_CLASS_CONT, 1))
        || (p30 = set_find (pe, PE_CLASS_CONT, 2))
        || (p30 = set_find (pe, PE_CLASS_CONT, 3))
        || (p30 = set_find (pe, PE_CLASS_CONT, 4))
        || (p30 = set_find (pe, PE_CLASS_CONT, 5))
        || (p30 = set_find (pe, PE_CLASS_CONT, 6)) ) {
        vname ("binding-value");
        vpush ();
        switch (PE_ID (p30 -> pe_class, p30 -> pe_id)) {
            case PE_ID (PE_CLASS_CONT, 1):
                {
                    register PE p31 = p30;

                    {	/* member TAG PULLUP */
                        register PE p32;

                        if ((p32 = prim2set (p31)) == NULLPE) {
                            advise (NULLCP, "member bad member: %s",
                                    pe_error (p31 -> pe_errno));
                            return NOTOK;
                        }
                        if (p32 -> pe_cardinal != 1) {
                            advise (NULLCP, "member too many elements for tagged member: %d",
                                    p32 -> pe_cardinal);
                            return NOTOK;
                        }
                        p31 = first_member (p32);
                    }
                    {
                        if (print_ISPR3_Object__Id__Expression (p31, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                            return NOTOK;
                    }
                }
                break;
            case PE_ID (PE_CLASS_CONT, 2):
                {
                    register PE p33 = p30;

                    {	/* member TAG PULLUP */
                        register PE p34;

                        if ((p34 = prim2set (p33)) == NULLPE) {
                            advise (NULLCP, "member bad member: %s",
                                    pe_error (p33 -> pe_errno));
                            return NOTOK;
                        }
                        if (p34 -> pe_cardinal != 1) {
                            advise (NULLCP, "member too many elements for tagged member: %d",
                                    p34 -> pe_cardinal);
                            return NOTOK;
                        }
                        p33 = first_member (p34);
                    }
                    {
                        if (print_ISPR3_Numeric__Expression (p33, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                            return NOTOK;
                    }
                }
                break;
            case PE_ID (PE_CLASS_CONT, 3):
                {
                    register PE p35 = p30;

                    {	/* member TAG PULLUP */
                        register PE p36;

                        if ((p36 = prim2set (p35)) == NULLPE) {
                            advise (NULLCP, "member bad member: %s",
                                    pe_error (p35 -> pe_errno));
                            return NOTOK;
                        }
                        if (p36 -> pe_cardinal != 1) {
                            advise (NULLCP, "member too many elements for tagged member: %d",
                                    p36 -> pe_cardinal);
                            return NOTOK;
                        }
                        p35 = first_member (p36);
                    }
                    {
                        if (print_ISPR3_String__Expression (p35, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                            return NOTOK;
                    }
                }
                break;
            case PE_ID (PE_CLASS_CONT, 4):
                {
                    if (print_ISPR3_Object__or__Class__Identifier (p30, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;
            case PE_ID (PE_CLASS_CONT, 5):
                {
                    register int p37;

                    if ((p37 = prim2num (p30)) == NOTOK
                            && p30 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "member bad integer: %s",
                                pe_error (p30 -> pe_errno));
                        return NOTOK;
                    }
                    vprint ("%d", p37);
                }
                break;
            case PE_ID (PE_CLASS_CONT, 6):
                {
                    vstring (p30);
                }
                break;

            default:
                advise (NULLCP, "binding-value has unknown choice: %s/%d/0x%x",
                        pe_classlist[p30 -> pe_class], p30 -> pe_form, p30 -> pe_id);
                return NOTOK;
        }
        vpop ();
        p30_count ++;
    }
    else {
        advise (NULLCP, "binding-value missing binding-value member");
        return NOTOK;
    }

    if (p30_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_One__Of__Four__Angles (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p38;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "One-Of-Four-Angles bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "One-Of-Four-Angles bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p38 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "One-Of-Four-Angles bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p38;
    switch (p38) {
        case 0:	/* d0 */
            vprint ("d0");
            break;
        case 1:	/* d90 */
            vprint ("d90");
            break;
        case 2:	/* d180 */
            vprint ("d180");
            break;
        case 3:	/* d270 */
            vprint ("d270");
            break;
        default:
            advise (NULLCP, "One-Of-Four-Angles has unknown component: %d", p38);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Measure__Pair (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p39;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Measure-Pair bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Measure-Pair bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p39 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Measure-Pair bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p39;

    vpush ();
    {
        register PE p40;

        if ((p40 = first_member (pe)) != NULLPE) {
            p39 = p40;

            {	/* horizontal */
                register int p41;

                vname ("horizontal");
                if ((p41 = prim2num (p40)) == NOTOK
                        && p40 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "horizontal bad integer: %s",
                            pe_error (p40 -> pe_errno));
                    return NOTOK;
                }
                vprint ("%d", p41);
            }
        }
        else {
            advise (NULLCP, "Measure-Pair missing horizontal element");
            return NOTOK;
        }

    }

    {
        register PE p42;

        if ((p42 = (pe != p39 ? next_member (pe, p39) : first_member (pe))) != NULLPE) {
            p39 = p42;

            {	/* vertical */
                register int p43;

                vname ("vertical");
                if ((p43 = prim2num (p42)) == NOTOK
                        && p42 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "vertical bad integer: %s",
                            pe_error (p42 -> pe_errno));
                    return NOTOK;
                }
                vprint ("%d", p43);
            }
        }
        else {
            advise (NULLCP, "Measure-Pair missing vertical element");
            return NOTOK;
        }

    }

    vpop ();

    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Measure-Pair has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Medium__Type (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p44;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Medium-Type bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Medium-Type bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p44 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Medium-Type bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p44;

    vpush ();
    {
        register PE p45;

        if ((p45 = first_member (pe)) != NULLPE
                && PE_ID (p45 -> pe_class, p45 -> pe_id)
                        != PE_ID (PE_CLASS_UNIV, 16))
            p45 = NULLPE;
        if (p45 != NULLPE) {
            p44 = p45;

            {	/* nominal-page-size */
                vname ("nominal-page-size");
                if (print_ISPR4_Measure__Pair (p45, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p46;

        if ((p46 = (pe != p44 ? next_member (pe, p44) : first_member (pe))) != NULLPE) {
            p44 = p46;

            {	/* side-of-sheet */
                register int p47;

                if (p46 -> pe_class != PE_CLASS_UNIV
                        || p46 -> pe_form != PE_FORM_PRIM
                        || p46 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "side-of-sheet bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p46 -> pe_class], p46 -> pe_form, p46 -> pe_id);
                    return NOTOK;
                }

                vname ("side-of-sheet");
                if ((p47 = prim2num (p46)) == NOTOK
                        && p46 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "side-of-sheet bad integer: %s",
                            pe_error (p46 -> pe_errno));
                    return NOTOK;
                }
                switch (p47) {
                    case 0:	/* unspecified */
                        vprint ("unspecified");
                        break;
                    case 1:	/* recto */
                        vprint ("recto");
                        break;
                    case 2:	/* verso */
                        vprint ("verso");
                        break;
                    default:
                        advise (NULLCP, "side-of-sheet has unknown component: %d", p47);
                        return NOTOK;
                }
            }
        }
    }

    vpop ();

    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Medium-Type has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Colour (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p48;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "Colour bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "Colour bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p48 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "Colour bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p48;
    switch (p48) {
        case 0:	/* colourless */
            vprint ("colourless");
            break;
        case 1:	/* white */
            vprint ("white");
            break;
        default:
            advise (NULLCP, "Colour has unknown component: %d", p48);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Border (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p49_count = 0;
    register PE p49;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Border bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Border bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p49 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Border bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p49;

    vpush ();
    if (p49 = set_find (pe, PE_CLASS_CONT, 0)) {
        vname ("left-hand-edge");
        if (print_ISPR4_Border__Edge (p49, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p49_count ++;
    }
    if (p49 = set_find (pe, PE_CLASS_CONT, 1)) {
        vname ("right-hand-edge");
        if (print_ISPR4_Border__Edge (p49, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p49_count ++;
    }
    if (p49 = set_find (pe, PE_CLASS_CONT, 2)) {
        vname ("trailing-edge");
        if (print_ISPR4_Border__Edge (p49, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p49_count ++;
    }
    if (p49 = set_find (pe, PE_CLASS_CONT, 3)) {
        vname ("leading-edge");
        if (print_ISPR4_Border__Edge (p49, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p49_count ++;
    }
    if (p49_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Border__Edge (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p50_count = 0;
    register PE p50;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Border-Edge bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Border-Edge bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p50 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Border-Edge bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p50;

    vpush ();
    if (p50 = set_find (pe, PE_CLASS_CONT, 0)) {
        register int p51;

        vname ("line-width");
        if ((p51 = prim2num (p50)) == NOTOK
                && p50 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "line-width bad integer: %s",
                    pe_error (p50 -> pe_errno));
            return NOTOK;
        }
        vprint ("%d", p51);
        p50_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p50 = set_find (pe, PE_CLASS_CONT, 1)) {
        register int p52;

        vname ("line-type");
        if ((p52 = prim2num (p50)) == NOTOK
                && p50 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "line-type bad integer: %s",
                    pe_error (p50 -> pe_errno));
            return NOTOK;
        }
        switch (p52) {
            case 0:	/* invisible */
                vprint ("invisible");
                break;
            case 1:	/* solid */
                vprint ("solid");
                break;
            case 2:	/* dashed */
                vprint ("dashed");
                break;
            case 3:	/* dot */
                vprint ("dot");
                break;
            case 4:	/* dash-dot */
                vprint ("dash-dot");
                break;
            case 5:	/* dash-dot-dot */
                vprint ("dash-dot-dot");
                break;
            default:
                advise (NULLCP, "line-type has unknown component: %d", p52);
                return NOTOK;
        }
        p50_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p50 = set_find (pe, PE_CLASS_CONT, 2)) {
        register int p53;

        vname ("freespace-width");
        if ((p53 = prim2num (p50)) == NOTOK
                && p50 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "freespace-width bad integer: %s",
                    pe_error (p50 -> pe_errno));
            return NOTOK;
        }
        vprint ("%d", p53);
        p50_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p50_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Layout__Object__Descriptor (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p54;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Layout-Object-Descriptor bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Layout-Object-Descriptor bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p54 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Layout-Object-Descriptor bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p54;

    vpush ();
    {
        register PE p55;

        if ((p55 = first_member (pe)) != NULLPE
                && PE_ID (p55 -> pe_class, p55 -> pe_id)
                        != PE_ID (PE_CLASS_UNIV, 2))
            p55 = NULLPE;
        if (p55 != NULLPE) {
            p54 = p55;

            {	/* object-type */
                vname ("object-type");
                if (print_ISPR4_Layout__Object__Type (p55, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p56;

        if ((p56 = (pe != p54 ? next_member (pe, p54) : first_member (pe))) != NULLPE) {
            p54 = p56;

            {	/* descriptor-body */
                vname ("descriptor-body");
                if (print_ISPR4_Layout__Object__Descriptor__Body (p56, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
    }

    vpop ();

    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Layout-Object-Descriptor has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Layout__Object__Type (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register int p57;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_PRIM
                || pe -> pe_id != PE_PRIM_INT) {
            advise (NULLCP, "Layout-Object-Type bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_PRIM) {
            advise (NULLCP, "Layout-Object-Type bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p57 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "Layout-Object-Type bad integer: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p57;
    switch (p57) {
        case 0:	/* document-layout-root */
            vprint ("document-layout-root");
            break;
        case 1:	/* page-set */
            vprint ("page-set");
            break;
        case 2:	/* page */
            vprint ("page");
            break;
        case 3:	/* frame */
            vprint ("frame");
            break;
        case 4:	/* block */
            vprint ("block");
            break;
        default:
            advise (NULLCP, "Layout-Object-Type has unknown component: %d", p57);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Layout__Object__Descriptor__Body (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p58_count = 0;
    register PE p58;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Layout-Object-Descriptor-Body bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Layout-Object-Descriptor-Body bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p58 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Layout-Object-Descriptor-Body bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p58;

    vpush ();
    if (p58 = set_find (pe, PE_CLASS_APPL, 1)) {
        vname ("object-identifier");
        if (print_ISPR3_Object__or__Class__Identifier (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 0)) {
        register PE p59;

        vname ("subordinates");
        if ((p59 = prim2seq (p58)) == NULLPE) {
            advise (NULLCP, "subordinates bad sequence: %s",
                    pe_error (p58 -> pe_errno));
            return NOTOK;
        }
        p58 = p59;

        vpush ();
        for (p59 = first_member (p58); p59; p59 = next_member (p58, p59)) {
            if (print_UNIV_NumericString (p59, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 1)) {
        register PE p60;

        vname ("content-portions");
        if ((p60 = prim2seq (p58)) == NULLPE) {
            advise (NULLCP, "content-portions bad sequence: %s",
                    pe_error (p58 -> pe_errno));
            return NOTOK;
        }
        p58 = p60;

        vpush ();
        for (p60 = first_member (p58); p60; p60 = next_member (p58, p60)) {
            if (print_UNIV_NumericString (p60, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 2)) {
        vname ("object-class");
        if (print_ISPR3_Object__or__Class__Identifier (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 3)) {
        vname ("position");
        if (print_ISPR4_Measure__Pair (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 4)) {
        vname ("dimensions");
        if (print_ISPR4_Dimension__Pair (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 5)) {
        vname ("transparency");
        if (print_ISPR4_Transparency (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 6)) {
        vname ("presentation-attributes");
        if (print_ISPR6_Presentation__Attributes (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 7)) {
        vname ("default-value-lists");
        if (print_ISPR7_Default__Value__Lists__Layout (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 8)) {
        vname ("user-readable-comments");
        if (print_ISPR4_Comment__String (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 9)) {
        register PE p61;

        vname ("bindings");
        if ((p61 = prim2set (p58)) == NULLPE) {
            advise (NULLCP, "bindings bad set: %s",
                    pe_error (p58 -> pe_errno));
            return NOTOK;
        }
        p58 = p61;

        vpush ();
        for (p61 = first_member (p58); p61; p61 = next_member (p58, p61)) {
            if (print_ISPR4_Binding__Pair (p61, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 11)) {
        vname ("layout-path");
        if (print_ISPR4_One__Of__Four__Angles (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 12)) {
        register PE p62;

        vname ("imaging-order");
        if ((p62 = prim2seq (p58)) == NULLPE) {
            advise (NULLCP, "imaging-order bad sequence: %s",
                    pe_error (p58 -> pe_errno));
            return NOTOK;
        }
        p58 = p62;

        vpush ();
        for (p62 = first_member (p58); p62; p62 = next_member (p58, p62)) {
            if (print_UNIV_NumericString (p62, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 13)) {
        register PE p63;

        vname ("permitted-categories");
        if ((p63 = prim2set (p58)) == NULLPE) {
            advise (NULLCP, "permitted-categories bad set: %s",
                    pe_error (p58 -> pe_errno));
            return NOTOK;
        }
        p58 = p63;

        vpush ();
        for (p63 = first_member (p58); p63; p63 = next_member (p58, p63)) {
            if (print_ISPR3_Layout__Category__Name (p63, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 14)) {
        vname ("user-visible-name");
        if (print_ISPR4_Comment__String (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 15)) {
        vname ("page-position");
        if (print_ISPR4_Measure__Pair (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 16)) {
        vname ("medium-type");
        if (print_ISPR4_Medium__Type (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 17)) {
        vname ("presentation-style");
        if (print_ISPR3_Style__Identifier (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 21)) {
        register PE p64;

        vname ("balance");
        if ((p64 = prim2set (p58)) == NULLPE) {
            advise (NULLCP, "balance bad set: %s",
                    pe_error (p58 -> pe_errno));
            return NOTOK;
        }
        p58 = p64;

        vpush ();
        for (p64 = first_member (p58); p64; p64 = next_member (p58, p64)) {
            if (print_ISPR3_Object__or__Class__Identifier (p64, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 22)) {
        vname ("colour");
        if (print_ISPR4_Colour (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 23)) {
        vname ("border");
        if (print_ISPR4_Border (p58, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p58_count ++;
    }
    if (p58 = set_find (pe, PE_CLASS_CONT, 25)) {
        vname ("application-comments");
        vstring (p58);
        p58_count ++;
    }
    if (p58_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Layout__Class__Descriptor (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p65;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Layout-Class-Descriptor bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Layout-Class-Descriptor bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p65 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Layout-Class-Descriptor bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p65;

    vpush ();
    {
        register PE p66;

        if ((p66 = first_member (pe)) != NULLPE) {
            p65 = p66;

            {	/* object-type */
                vname ("object-type");
                if (print_ISPR4_Layout__Object__Type (p66, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Layout-Class-Descriptor missing object-type element");
            return NOTOK;
        }

    }

    {
        register PE p67;

        if ((p67 = (pe != p65 ? next_member (pe, p65) : first_member (pe))) != NULLPE) {
            p65 = p67;

            {	/* descriptor-body */
                vname ("descriptor-body");
                if (print_ISPR4_Layout__Class__Descriptor__Body (p67, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Layout-Class-Descriptor missing descriptor-body element");
            return NOTOK;
        }

    }

    vpop ();

    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Layout-Class-Descriptor has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	print_ISPR4_Layout__Class__Descriptor__Body (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p68_count = 0;
    register PE p68;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Layout-Class-Descriptor-Body bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Layout-Class-Descriptor-Body bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p68 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Layout-Class-Descriptor-Body bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p68;

    vpush ();
    if (p68 = set_find (pe, PE_CLASS_APPL, 1)) {
        vname ("object-class-identifier");
        if (print_ISPR3_Object__or__Class__Identifier (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    else {
        advise (NULLCP, "object-class-identifier missing object-class-identifier member");
        return NOTOK;
    }

    if (p68 = set_find (pe, PE_CLASS_CONT, 0)) {
        register PE p69 = p68;

        {	/* generator-for-subordinates TAG PULLUP */
            register PE p70;

            if ((p70 = prim2set (p69)) == NULLPE) {
                advise (NULLCP, "generator-for-subordinates bad generator-for-subordinates: %s",
                        pe_error (p69 -> pe_errno));
                return NOTOK;
            }
            if (p70 -> pe_cardinal != 1) {
                advise (NULLCP, "generator-for-subordinates too many elements for tagged generator-for-subordinates: %d",
                        p70 -> pe_cardinal);
                return NOTOK;
            }
            p69 = first_member (p70);
        }
        {
            vname ("generator-for-subordinates");
            if (print_ISPR3_Construction__Expression (p69, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 1)) {
        register PE p71;

        vname ("content-portions");
        if ((p71 = prim2seq (p68)) == NULLPE) {
            advise (NULLCP, "content-portions bad sequence: %s",
                    pe_error (p68 -> pe_errno));
            return NOTOK;
        }
        p68 = p71;

        vpush ();
        for (p71 = first_member (p68); p71; p71 = next_member (p68, p71)) {
            if (print_UNIV_NumericString (p71, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p68_count ++;
    }
    if ( (p68 = set_find (pe, PE_CLASS_CONT, 3))
        || (p68 = set_find (pe, PE_CLASS_CONT, 26)) ) {
        vname ("position");
        vpush ();
        switch (PE_ID (p68 -> pe_class, p68 -> pe_id)) {
            case PE_ID (PE_CLASS_CONT, 3):	/* fixed-position */
                {
                    vname ("fixed-position");
                    if (print_ISPR4_Measure__Pair (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;
            case PE_ID (PE_CLASS_CONT, 26):	/* variable-position */
                {
                    vname ("variable-position");
                    if (print_ISPR4_Position__Spec (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;

            default:
                advise (NULLCP, "position has unknown choice: %s/%d/0x%x",
                        pe_classlist[p68 -> pe_class], p68 -> pe_form, p68 -> pe_id);
                return NOTOK;
        }
        vpop ();
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 4)) {
        vname ("dimensions");
        if (print_ISPR4_Dimension__Spec (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 5)) {
        vname ("transparency");
        if (print_ISPR4_Transparency (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 6)) {
        vname ("presentation-attributes");
        if (print_ISPR6_Presentation__Attributes (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 7)) {
        vname ("default-value-lists");
        if (print_ISPR7_Default__Value__Lists__Layout (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 8)) {
        vname ("user-readable-comments");
        if (print_ISPR4_Comment__String (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 9)) {
        register PE p72;

        vname ("bindings");
        if ((p72 = prim2set (p68)) == NULLPE) {
            advise (NULLCP, "bindings bad set: %s",
                    pe_error (p68 -> pe_errno));
            return NOTOK;
        }
        p68 = p72;

        vpush ();
        for (p72 = first_member (p68); p72; p72 = next_member (p68, p72)) {
            if (print_ISPR4_Binding__Pair (p72, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 10)) {
        vname ("content-generator");
        if (print_ISPR3_String__Expression (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 11)) {
        vname ("layout-path");
        if (print_ISPR4_One__Of__Four__Angles (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 13)) {
        register PE p73;

        vname ("permitted-categories");
        if ((p73 = prim2set (p68)) == NULLPE) {
            advise (NULLCP, "permitted-categories bad set: %s",
                    pe_error (p68 -> pe_errno));
            return NOTOK;
        }
        p68 = p73;

        vpush ();
        for (p73 = first_member (p68); p73; p73 = next_member (p68, p73)) {
            if (print_ISPR3_Layout__Category__Name (p73, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 14)) {
        vname ("user-visible-name");
        if (print_ISPR4_Comment__String (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 15)) {
        vname ("page-position");
        if (print_ISPR4_Measure__Pair (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 16)) {
        vname ("medium-type");
        if (print_ISPR4_Medium__Type (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 17)) {
        vname ("presentation-style");
        if (print_ISPR3_Style__Identifier (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 18)) {
        vname ("logical-source");
        if (print_ISPR3_Object__or__Class__Identifier (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 21)) {
        register PE p74;

        vname ("balance");
        if ((p74 = prim2set (p68)) == NULLPE) {
            advise (NULLCP, "balance bad set: %s",
                    pe_error (p68 -> pe_errno));
            return NOTOK;
        }
        p68 = p74;

        vpush ();
        for (p74 = first_member (p68); p74; p74 = next_member (p68, p74)) {
            if (print_ISPR3_Object__or__Class__Identifier (p74, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 22)) {
        vname ("colour");
        if (print_ISPR4_Colour (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 23)) {
        vname ("border");
        if (print_ISPR4_Border (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 24)) {
        vname ("resource");
        if (print_ISPR3_Resource__Name (p68, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p68_count ++;
    }
    if (p68 = set_find (pe, PE_CLASS_CONT, 25)) {
        vname ("application-comments");
        vstring (p68);
        p68_count ++;
    }
    if (p68_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}
