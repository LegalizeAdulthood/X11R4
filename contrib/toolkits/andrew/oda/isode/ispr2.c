/* automatically generated by pepy 5.0 #1 (mss.andrew.cmu.edu), do not edit! */

#include <psap.h>

static char *pepyid = "pepy 5.0 #1 (mss.andrew.cmu.edu) of Mon May 22 20:44:32 EDT 1989";

#define	advise	PY_advise

void	advise ();

/* Generated from module ISPR2 */
# line 5 "ispr2.py"


/*
 *
 * (C) Copyright 1989 by Carnegie Mellon University
 *
 * Permission to use, copy, modify, and distribute these programs
 * and their documentation for any purpose and without fee is
 * hereby granted, provided that this copyright and permission
 * notice appear on all copies and supporting documentation, and
 * that the name of Carnegie Mellon University not be used in
 * advertising or publicity pertaining to distribution of the
 * programs without specific prior permission and notice be given
 * in supporting documentation that copying and distribution is
 * by permission of Carnegie Mellon University.
 *
 * Carnegie Mellon University makes no representations about the
 * suitability of this software for any purpose.  It is provided
 * as is, without express or implied warranty.
 *
 * Software by Ann Marks and James T. Lui,
 * Information Technology Center, Carnegie Mellon University,
 * except where noted.
 *
 */


#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	print_ISPR2_Document__Profile__Descriptor (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p0_count = 0;
    register PE p0;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Document-Profile-Descriptor bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Document-Profile-Descriptor bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p0 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Document-Profile-Descriptor bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p0;

    vpush ();
    if (p0 = set_find (pe, PE_CLASS_CONT, 0)) {
        vname ("generic-layout-structure");
        if (print_UNIV_NumericString (p0, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 1)) {
        vname ("specific-layout-structure");
        if (print_UNIV_NumericString (p0, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 4)) {
        vname ("generic-logical-structure");
        if (print_UNIV_NumericString (p0, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 5)) {
        vname ("specific-logical-structure");
        if (print_UNIV_NumericString (p0, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 6)) {
        vname ("presentation-styles");
        if (print_UNIV_NumericString (p0, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 7)) {
        vname ("layout-styles");
        if (print_UNIV_NumericString (p0, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 9)) {
        register PE p1 = p0;

        {	/* external-document-class TAG PULLUP */
            register PE p2;

            if ((p2 = prim2set (p1)) == NULLPE) {
                advise (NULLCP, "external-document-class bad external-document-class: %s",
                        pe_error (p1 -> pe_errno));
                return NOTOK;
            }
            if (p2 -> pe_cardinal != 1) {
                advise (NULLCP, "external-document-class too many elements for tagged external-document-class: %d",
                        p2 -> pe_cardinal);
                return NOTOK;
            }
            p1 = first_member (p2);
        }
        {
            vname ("external-document-class");
            if (print_ISPR2_Document__Reference (p1, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 10)) {
        register PE p3 = p0;

        {	/* resource-document TAG PULLUP */
            register PE p4;

            if ((p4 = prim2set (p3)) == NULLPE) {
                advise (NULLCP, "resource-document bad resource-document: %s",
                        pe_error (p3 -> pe_errno));
                return NOTOK;
            }
            if (p4 -> pe_cardinal != 1) {
                advise (NULLCP, "resource-document too many elements for tagged resource-document: %d",
                        p4 -> pe_cardinal);
                return NOTOK;
            }
            p3 = first_member (p4);
        }
        {
            vname ("resource-document");
            if (print_ISPR2_Document__Reference (p3, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 11)) {
        register PE p5;

        vname ("resources");
        if ((p5 = prim2set (p0)) == NULLPE) {
            advise (NULLCP, "resources bad set: %s",
                    pe_error (p0 -> pe_errno));
            return NOTOK;
        }
        p0 = p5;

        vpush ();
        for (p5 = first_member (p0); p5; p5 = next_member (p0, p5)) {
            int p6_count = 0;
            register PE p6;

            if (p5 -> pe_class != PE_CLASS_UNIV
                    || p5 -> pe_form != PE_FORM_CONS
                    || p5 -> pe_id != PE_CONS_SET) {
                advise (NULLCP, "member bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p5 -> pe_class], p5 -> pe_form, p5 -> pe_id);
                return NOTOK;
            }

            if ((p6 = prim2set (p5)) == NULLPE) {
                advise (NULLCP, "member bad set: %s",
                        pe_error (p5 -> pe_errno));
                return NOTOK;
            }
            p5 = p6;

            vpush ();
            if (p6 = set_find (p5, PE_CLASS_UNIV, 19)) {
                vname ("resource-identifier");
                if (print_ISPR3_Resource__Name (p6, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p6_count ++;
            }
            else {
                advise (NULLCP, "resource-identifier missing resource-identifier member");
                return NOTOK;
            }

            if (p6 = set_find (p5, PE_CLASS_APPL, 1)) {
                vname ("object-class-identifier");
                if (print_ISPR3_Object__or__Class__Identifier (p6, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p6_count ++;
            }
            else {
                advise (NULLCP, "object-class-identifier missing object-class-identifier member");
                return NOTOK;
            }

            if (p6_count != p5 -> pe_cardinal)
                advise (NULLCP, "warning: extra or duplicate members present in SET");
            vpop ();
        }
        vpop ();
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 2)) {
        vname ("document-characteristics");
        if (print_ISPR2_Document__Characteristics (p0, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p0_count ++;
    }
    if (p0 = set_find (pe, PE_CLASS_CONT, 3)) {
        vname ("document-management-attributes");
        if (print_ISPR2_Document__Management__Attributes (p0, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p0_count ++;
    }
    if (p0_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Document__Characteristics (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p7_count = 0;
    register PE p7;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Document-Characteristics bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Document-Characteristics bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p7 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Document-Characteristics bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p7;

    vpush ();
    if ( (p7 = set_find (pe, PE_CLASS_CONT, 0))
        || (p7 = set_find (pe, PE_CLASS_CONT, 4)) ) {
        vname ("document-application-profile");
        vpush ();
        switch (PE_ID (p7 -> pe_class, p7 -> pe_id)) {
            case PE_ID (PE_CLASS_CONT, 0):
                {
                    register int p8;

                    if ((p8 = prim2num (p7)) == NOTOK
                            && p7 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "member bad integer: %s",
                                pe_error (p7 -> pe_errno));
                        return NOTOK;
                    }
                    switch (p8) {
                        case 2:	/* group-4-facsimile */
                            vprint ("group-4-facsimile");
                            break;
                        default:
                            advise (NULLCP, "member has unknown component: %d", p8);
                            return NOTOK;
                    }
                }
                break;
            case PE_ID (PE_CLASS_CONT, 4):
                {
                    register OID p9;

                    if ((p9 = prim2oid (p7)) == NULLOID) {
                        advise (NULLCP, "member bad object identifier: %s",
                                pe_error (p7 -> pe_errno));
                        return NOTOK;
                    }
                    vprint ("%s", oid2ode (p9));
                }
                break;

            default:
                advise (NULLCP, "document-application-profile has unknown choice: %s/%d/0x%x",
                        pe_classlist[p7 -> pe_class], p7 -> pe_form, p7 -> pe_id);
                return NOTOK;
        }
        vpop ();
        p7_count ++;
    }
    if (p7 = set_find (pe, PE_CLASS_CONT, 10)) {
        vname ("doc-appl-profile-defaults");
        if (print_ISPR2_Doc__Appl__Profile__Defaults (p7, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p7_count ++;
    }
    if (p7 = set_find (pe, PE_CLASS_CONT, 1)) {
        register int p10;

        vname ("document-architecture-class");
        if ((p10 = prim2num (p7)) == NOTOK
                && p7 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "document-architecture-class bad integer: %s",
                    pe_error (p7 -> pe_errno));
            return NOTOK;
        }
        switch (p10) {
            case 0:	/* formatted */
                vprint ("formatted");
                break;
            case 1:	/* processable */
                vprint ("processable");
                break;
            case 2:	/* formatted-processable */
                vprint ("formatted-processable");
                break;
            default:
                advise (NULLCP, "document-architecture-class has unknown component: %d", p10);
                return NOTOK;
        }
        p7_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p7 = set_find (pe, PE_CLASS_CONT, 5)) {
        register PE p11;

        vname ("content-architecture-classes");
        if ((p11 = prim2set (p7)) == NULLPE) {
            advise (NULLCP, "content-architecture-classes bad set: %s",
                    pe_error (p7 -> pe_errno));
            return NOTOK;
        }
        p7 = p11;

        vpush ();
        for (p11 = first_member (p7); p11; p11 = next_member (p7, p11)) {
            register OID p12;

            if (p11 -> pe_class != PE_CLASS_UNIV
                    || p11 -> pe_form != PE_FORM_PRIM
                    || p11 -> pe_id != PE_PRIM_OID) {
                advise (NULLCP, "member bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p11 -> pe_class], p11 -> pe_form, p11 -> pe_id);
                return NOTOK;
            }

            if ((p12 = prim2oid (p11)) == NULLOID) {
                advise (NULLCP, "member bad object identifier: %s",
                        pe_error (p11 -> pe_errno));
                return NOTOK;
            }
            vprint ("%s", oid2ode (p12));
        }
        vpop ();
        p7_count ++;
    }
    if (p7 = set_find (pe, PE_CLASS_CONT, 6)) {
        register int p13;

        vname ("interchange-format-class");
        if ((p13 = prim2num (p7)) == NOTOK
                && p7 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "interchange-format-class bad integer: %s",
                    pe_error (p7 -> pe_errno));
            return NOTOK;
        }
        switch (p13) {
            case 0:	/* if-a */
                vprint ("if-a");
                break;
            case 1:	/* if-b */
                vprint ("if-b");
                break;
            default:
                advise (NULLCP, "interchange-format-class has unknown component: %d", p13);
                return NOTOK;
        }
        p7_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p7 = set_find (pe, PE_CLASS_CONT, 8)) {
        register PE p14;

        vname ("oda-version");
        if ((p14 = prim2seq (p7)) == NULLPE) {
            advise (NULLCP, "oda-version bad sequence: %s",
                    pe_error (p7 -> pe_errno));
            return NOTOK;
        }
        p7 = p14;

        vpush ();
        {
            register PE p15;

            if ((p15 = first_member (p7)) != NULLPE) {
                p14 = p15;

                {	/* standard-or-recommendation */
                    vname ("standard-or-recommendation");
                    if (print_ISPR2_Character__Data (p15, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            else {
                advise (NULLCP, "oda-version missing standard-or-recommendation element");
                return NOTOK;
            }

        }

        {
            register PE p16;

            if ((p16 = (p7 != p14 ? next_member (p7, p14) : first_member (p7))) != NULLPE) {
                p14 = p16;

                {	/* publication-date */
                    vname ("publication-date");
                    if (print_ISPR2_Date__and__Time (p16, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
            }
            else {
                advise (NULLCP, "oda-version missing publication-date element");
                return NOTOK;
            }

        }

        vpop ();

        if (p7 -> pe_cardinal > 2) {
            advise (NULLCP, "oda-version has too many elements(2): %d",
                    p7 -> pe_cardinal);
            return NOTOK;
        }
        p7_count ++;
    }
    if (p7 = set_find (pe, PE_CLASS_CONT, 2)) {
        vname ("non-basic-doc-characteristics");
        if (print_ISPR2_Non__Basic__Doc__Characteristics (p7, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p7_count ++;
    }
    if (p7 = set_find (pe, PE_CLASS_CONT, 3)) {
        vname ("non-basic-struc-characteristics");
        if (print_ISPR2_Non__Basic__Struc__Characteristics (p7, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p7_count ++;
    }
    if (p7 = set_find (pe, PE_CLASS_CONT, 9)) {
        vname ("additional-doc-characteristics");
        if (print_ISPR2_Additional__Doc__Characteristics (p7, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p7_count ++;
    }
    if (p7_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Doc__Appl__Profile__Defaults (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p17_count = 0;
    register PE p17;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Doc-Appl-Profile-Defaults bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Doc-Appl-Profile-Defaults bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p17 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Doc-Appl-Profile-Defaults bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p17;

    vpush ();
    if (p17 = set_find (pe, PE_CLASS_CONT, 0)) {
        vname ("document-architecture-defaults");
        if (print_ISPR2_Document__Architecture__Defaults (p17, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p17_count ++;
    }
    if (p17 = set_find (pe, PE_CLASS_CONT, 1)) {
        vname ("character-content-defaults");
        if (print_ISPR11_Character__Content__Defaults (p17, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p17_count ++;
    }
    if (p17 = set_find (pe, PE_CLASS_CONT, 2)) {
        vname ("raster-gr-content-defaults");
        if (print_ISPR14_Raster__Gr__Content__Defaults (p17, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p17_count ++;
    }
    if (p17 = set_find (pe, PE_CLASS_CONT, 3)) {
        vname ("geo-gr-content-defaults");
        if (print_ISPR17_Geo__Gr__Content__Defaults (p17, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p17_count ++;
    }
    if (p17 = set_find (pe, PE_CLASS_CONT, 7)) {
        register PE p18;

        vname ("external-content-architecture-defaults");
        if ((p18 = prim2seq (p17)) == NULLPE) {
            advise (NULLCP, "external-content-architecture-defaults bad sequence: %s",
                    pe_error (p17 -> pe_errno));
            return NOTOK;
        }
        p17 = p18;

        vpush ();
        for (p18 = first_member (p17); p18; p18 = next_member (p17, p18)) {
            if (print_UNIV_EXTERNAL (p18, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p17_count ++;
    }
    if (p17_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Document__Architecture__Defaults (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p19_count = 0;
    register PE p19;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Document-Architecture-Defaults bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Document-Architecture-Defaults bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p19 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Document-Architecture-Defaults bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p19;

    vpush ();
    if (p19 = set_find (pe, PE_CLASS_CONT, 0)) {
        vname ("content-architecture-class");
        if (print_ISPR6_Content__Architecture__Class (p19, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p19_count ++;
    }
    if (p19 = set_find (pe, PE_CLASS_CONT, 1)) {
        vname ("content-type");
        if (print_ISPR6_Content__Type (p19, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p19_count ++;
    }
    if (p19 = set_find (pe, PE_CLASS_CONT, 2)) {
        vname ("page-dimensions");
        if (print_ISPR4_Measure__Pair (p19, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p19_count ++;
    }
    if (p19 = set_find (pe, PE_CLASS_CONT, 3)) {
        vname ("transparency");
        if (print_ISPR4_Transparency (p19, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p19_count ++;
    }
    if (p19 = set_find (pe, PE_CLASS_CONT, 4)) {
        vname ("colour");
        if (print_ISPR4_Colour (p19, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p19_count ++;
    }
    if (p19 = set_find (pe, PE_CLASS_CONT, 5)) {
        vname ("layout-path");
        if (print_ISPR4_One__Of__Four__Angles (p19, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p19_count ++;
    }
    if (p19 = set_find (pe, PE_CLASS_CONT, 6)) {
        vname ("medium-type");
        if (print_ISPR4_Medium__Type (p19, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p19_count ++;
    }
    if (p19 = set_find (pe, PE_CLASS_CONT, 7)) {
        vname ("block-alignment");
        if (print_ISPR6_Block__Alignment (p19, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p19_count ++;
    }
    if (p19 = set_find (pe, PE_CLASS_CONT, 8)) {
        vname ("border");
        if (print_ISPR4_Border (p19, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p19_count ++;
    }
    if (p19 = set_find (pe, PE_CLASS_CONT, 9)) {
        vname ("page-position");
        if (print_ISPR4_Measure__Pair (p19, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p19_count ++;
    }
    if (p19 = set_find (pe, PE_CLASS_CONT, 10)) {
        register PE p20 = p19;

        {	/* type-of-coding TAG PULLUP */
            register PE p21;

            if ((p21 = prim2set (p20)) == NULLPE) {
                advise (NULLCP, "type-of-coding bad type-of-coding: %s",
                        pe_error (p20 -> pe_errno));
                return NOTOK;
            }
            if (p21 -> pe_cardinal != 1) {
                advise (NULLCP, "type-of-coding too many elements for tagged type-of-coding: %d",
                        p21 -> pe_cardinal);
                return NOTOK;
            }
            p20 = first_member (p21);
        }
        {
            vname ("type-of-coding");
            if (print_ISPR8_Type__of__Coding (p20, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p19_count ++;
    }
    if (p19_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Non__Basic__Doc__Characteristics (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p22_count = 0;
    register PE p22;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Non-Basic-Doc-Characteristics bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Non-Basic-Doc-Characteristics bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p22 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Non-Basic-Doc-Characteristics bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p22;

    vpush ();
    if (p22 = set_find (pe, PE_CLASS_CONT, 5)) {
        vname ("profile-character-sets");
        vstring (p22);
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 1)) {
        vname ("comments-character-sets");
        vstring (p22);
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 6)) {
        vname ("alternative-reper-char-sets");
        vstring (p22);
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 2)) {
        register PE p23;

        vname ("page-dimensions");
        if ((p23 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "page-dimensions bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p23;

        vpush ();
        for (p23 = first_member (p22); p23; p23 = next_member (p22, p23)) {
            if (print_ISPR4_Measure__Pair (p23, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 8)) {
        register PE p24;

        vname ("medium-types");
        if ((p24 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "medium-types bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p24;

        vpush ();
        for (p24 = first_member (p22); p24; p24 = next_member (p22, p24)) {
            if (print_ISPR4_Medium__Type (p24, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 21)) {
        register PE p25;

        vname ("layout-paths");
        if ((p25 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "layout-paths bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p25;

        vpush ();
        for (p25 = first_member (p22); p25; p25 = next_member (p22, p25)) {
            if (print_ISPR4_One__Of__Four__Angles (p25, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 22)) {
        register PE p26;

        vname ("transparencies");
        if ((p26 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "transparencies bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p26;

        vpush ();
        for (p26 = first_member (p22); p26; p26 = next_member (p22, p26)) {
            if (print_ISPR4_Transparency (p26, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 23)) {
        register PE p27;

        vname ("protections");
        if ((p27 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "protections bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p27;

        vpush ();
        for (p27 = first_member (p22); p27; p27 = next_member (p22, p27)) {
            if (print_ISPR5_Protection (p27, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 24)) {
        register PE p28;

        vname ("block-alignments");
        if ((p28 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "block-alignments bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p28;

        vpush ();
        for (p28 = first_member (p22); p28; p28 = next_member (p22, p28)) {
            if (print_ISPR6_Block__Alignment (p28, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 25)) {
        register PE p29;

        vname ("fill-orders");
        if ((p29 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "fill-orders bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p29;

        vpush ();
        for (p29 = first_member (p22); p29; p29 = next_member (p22, p29)) {
            if (print_ISPR6_Fill__Order (p29, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 26)) {
        register PE p30;

        vname ("colours");
        if ((p30 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "colours bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p30;

        vpush ();
        for (p30 = first_member (p22); p30; p30 = next_member (p22, p30)) {
            if (print_ISPR4_Colour (p30, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 27)) {
        register PE p31;

        vname ("borders");
        if ((p31 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "borders bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p31;

        vpush ();
        for (p31 = first_member (p22); p31; p31 = next_member (p22, p31)) {
            if (print_ISPR4_Border (p31, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 28)) {
        register PE p32;

        vname ("page-positions");
        if ((p32 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "page-positions bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p32;

        vpush ();
        for (p32 = first_member (p22); p32; p32 = next_member (p22, p32)) {
            if (print_ISPR4_Measure__Pair (p32, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 29)) {
        register PE p33;

        vname ("types-of-coding");
        if ((p33 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "types-of-coding bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p33;

        vpush ();
        for (p33 = first_member (p22); p33; p33 = next_member (p22, p33)) {
            if (print_ISPR8_Type__of__Coding (p33, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 9)) {
        register PE p34;

        vname ("char-presentation-features");
        if ((p34 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "char-presentation-features bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p34;

        vpush ();
        for (p34 = first_member (p22); p34; p34 = next_member (p22, p34)) {
            if (print_ISPR11_Char__Presentation__Features (p34, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 4)) {
        register PE p35;

        vname ("ra-gr-presentation-features");
        if ((p35 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "ra-gr-presentation-features bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p35;

        vpush ();
        for (p35 = first_member (p22); p35; p35 = next_member (p22, p35)) {
            if (print_ISPR14_Ra__Gr__Presentation__Features (p35, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 12)) {
        register PE p36;

        vname ("geo-gr-presentation-features");
        if ((p36 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "geo-gr-presentation-features bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p36;

        vpush ();
        for (p36 = first_member (p22); p36; p36 = next_member (p22, p36)) {
            if (print_ISPR17_Geo__Gr__Presentation__Features (p36, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 16)) {
        register PE p37;

        vname ("character-coding-attributes");
        if ((p37 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "character-coding-attributes bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p37;

        vpush ();
        for (p37 = first_member (p22); p37; p37 = next_member (p22, p37)) {
            if (print_ISPR10_Character__Coding__Attributes (p37, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 3)) {
        register PE p38;

        vname ("ra-gr-coding-attributes");
        if ((p38 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "ra-gr-coding-attributes bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p38;

        vpush ();
        for (p38 = first_member (p22); p38; p38 = next_member (p22, p38)) {
            if (print_ISPR13_Raster__Gr__Coding__Attributes (p38, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 17)) {
        register PE p39;

        vname ("geo-gr-coding-attributes");
        if ((p39 = prim2set (p22)) == NULLPE) {
            advise (NULLCP, "geo-gr-coding-attributes bad set: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p39;

        vpush ();
        for (p39 = first_member (p22); p39; p39 = next_member (p22, p39)) {
            if (print_ISPR16_Geo__Gr__Coding__Attributes (p39, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 10)) {
        register PE p40;

        vname ("ext-non-basic-pres-features");
        if ((p40 = prim2seq (p22)) == NULLPE) {
            advise (NULLCP, "ext-non-basic-pres-features bad sequence: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p40;

        vpush ();
        for (p40 = first_member (p22); p40; p40 = next_member (p22, p40)) {
            if (print_UNIV_EXTERNAL (p40, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22 = set_find (pe, PE_CLASS_CONT, 11)) {
        register PE p41;

        vname ("ext-non-basic-coding-attributes");
        if ((p41 = prim2seq (p22)) == NULLPE) {
            advise (NULLCP, "ext-non-basic-coding-attributes bad sequence: %s",
                    pe_error (p22 -> pe_errno));
            return NOTOK;
        }
        p22 = p41;

        vpush ();
        for (p41 = first_member (p22); p41; p41 = next_member (p22, p41)) {
            if (print_UNIV_EXTERNAL (p41, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p22_count ++;
    }
    if (p22_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Non__Basic__Struc__Characteristics (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p42_count = 0;
    register PE p42;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Non-Basic-Struc-Characteristics bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Non-Basic-Struc-Characteristics bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p42 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Non-Basic-Struc-Characteristics bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p42;

    vpush ();
    if (p42 = set_find (pe, PE_CLASS_CONT, 0)) {
        register int p43;

        vname ("number-of-objects-per-page");
        if ((p43 = prim2num (p42)) == NOTOK
                && p42 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "number-of-objects-per-page bad integer: %s",
                    pe_error (p42 -> pe_errno));
            return NOTOK;
        }
        vprint ("%d", p43);
        p42_count ++;
    }
    if (p42_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Additional__Doc__Characteristics (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p44_count = 0;
    register PE p44;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Additional-Doc-Characteristics bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Additional-Doc-Characteristics bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p44 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Additional-Doc-Characteristics bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p44;

    vpush ();
    if (p44 = set_find (pe, PE_CLASS_CONT, 3)) {
        register PE p45;

        vname ("unit-scaling");
        if ((p45 = prim2seq (p44)) == NULLPE) {
            advise (NULLCP, "unit-scaling bad sequence: %s",
                    pe_error (p44 -> pe_errno));
            return NOTOK;
        }
        p44 = p45;

        vpush ();
        {
            register PE p46;

            if ((p46 = first_member (p44)) != NULLPE) {
                p45 = p46;

                {
                    register int p47;

                    if (p46 -> pe_class != PE_CLASS_UNIV
                            || p46 -> pe_form != PE_FORM_PRIM
                            || p46 -> pe_id != PE_PRIM_INT) {
                        advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                                pe_classlist[p46 -> pe_class], p46 -> pe_form, p46 -> pe_id);
                        return NOTOK;
                    }

                    if ((p47 = prim2num (p46)) == NOTOK
                            && p46 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "element bad integer: %s",
                                pe_error (p46 -> pe_errno));
                        return NOTOK;
                    }
                    vprint ("%d", p47);
                }
            }
            else {
                advise (NULLCP, "unit-scaling missing element");
                return NOTOK;
            }

        }

        {
            register PE p48;

            if ((p48 = (p44 != p45 ? next_member (p44, p45) : first_member (p44))) != NULLPE) {
                p45 = p48;

                {
                    register int p49;

                    if (p48 -> pe_class != PE_CLASS_UNIV
                            || p48 -> pe_form != PE_FORM_PRIM
                            || p48 -> pe_id != PE_PRIM_INT) {
                        advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                                pe_classlist[p48 -> pe_class], p48 -> pe_form, p48 -> pe_id);
                        return NOTOK;
                    }

                    if ((p49 = prim2num (p48)) == NOTOK
                            && p48 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "element bad integer: %s",
                                pe_error (p48 -> pe_errno));
                        return NOTOK;
                    }
                    vprint ("%d", p49);
                }
            }
            else {
                advise (NULLCP, "unit-scaling missing element");
                return NOTOK;
            }

        }

        vpop ();

        if (p44 -> pe_cardinal > 2) {
            advise (NULLCP, "unit-scaling has too many elements(2): %d",
                    p44 -> pe_cardinal);
            return NOTOK;
        }
        p44_count ++;
    }
    if (p44 = set_find (pe, PE_CLASS_CONT, 2)) {
        vname ("fonts-list");
        if (print_ISPR2_Fonts__List (p44, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p44_count ++;
    }
    if (p44_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Fonts__List (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p50;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Fonts-List bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Fonts-List bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p50 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Fonts-List bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p50;

    vpush ();
    for (p50 = first_member (pe); p50; p50 = next_member (pe, p50)) {
        if (print_ISPR2_Fonts__List__Prime (p50, 1, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Fonts__List__Prime (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p51_count = 0;
    register PE p51;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Fonts-List-Prime bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Fonts-List-Prime bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p51 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Fonts-List-Prime bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p51;

    vpush ();
    if (p51 = set_find (pe, PE_CLASS_UNIV, 2)) {
        register int p52;

        vname ("font-identifier");
        if ((p52 = prim2num (p51)) == NOTOK
                && p51 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "font-identifier bad integer: %s",
                    pe_error (p51 -> pe_errno));
            return NOTOK;
        }
        vprint ("%d", p52);
        p51_count ++;
    }
    else {
        advise (NULLCP, "font-identifier missing font-identifier member");
        return NOTOK;
    }

    if (p51 = set_find (pe, PE_CLASS_UNIV, 16)) {
        vname ("font-reference");
        if (print_ISPR18_Font__Reference (p51, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p51_count ++;
    }
    else {
        advise (NULLCP, "font-reference missing font-reference member");
        return NOTOK;
    }

    if (p51_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Document__Management__Attributes (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p53_count = 0;
    register PE p53;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Document-Management-Attributes bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Document-Management-Attributes bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p53 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Document-Management-Attributes bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p53;

    vpush ();
    if (p53 = set_find (pe, PE_CLASS_CONT, 7)) {
        vname ("document-description");
        if (print_ISPR2_Document__Description (p53, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p53_count ++;
    }
    if (p53 = set_find (pe, PE_CLASS_CONT, 0)) {
        vname ("dates-and-times");
        if (print_ISPR2_Dates__and__Times (p53, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p53_count ++;
    }
    if (p53 = set_find (pe, PE_CLASS_CONT, 1)) {
        vname ("originators");
        if (print_ISPR2_Originators (p53, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p53_count ++;
    }
    if (p53 = set_find (pe, PE_CLASS_CONT, 2)) {
        vname ("other-user-information");
        if (print_ISPR2_Other__User__Information (p53, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p53_count ++;
    }
    if (p53 = set_find (pe, PE_CLASS_CONT, 3)) {
        vname ("external-references");
        if (print_ISPR2_External__References (p53, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p53_count ++;
    }
    if (p53 = set_find (pe, PE_CLASS_CONT, 4)) {
        vname ("local-file-refernces");
        if (print_ISPR2_Local__File__References (p53, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p53_count ++;
    }
    if (p53 = set_find (pe, PE_CLASS_CONT, 5)) {
        vname ("content-attributes");
        if (print_ISPR2_Content__Attributes (p53, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p53_count ++;
    }
    if (p53 = set_find (pe, PE_CLASS_CONT, 6)) {
        vname ("security-information");
        if (print_ISPR2_Security__Information (p53, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p53_count ++;
    }
    if (p53_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Document__Description (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p54_count = 0;
    register PE p54;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Document-Description bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Document-Description bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p54 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Document-Description bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p54;

    vpush ();
    if (p54 = set_find (pe, PE_CLASS_CONT, 0)) {
        vname ("title");
        if (print_ISPR2_Character__Data (p54, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p54_count ++;
    }
    if (p54 = set_find (pe, PE_CLASS_CONT, 1)) {
        vname ("subject");
        if (print_ISPR2_Character__Data (p54, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p54_count ++;
    }
    if (p54 = set_find (pe, PE_CLASS_CONT, 2)) {
        vname ("document-type");
        if (print_ISPR2_Character__Data (p54, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p54_count ++;
    }
    if (p54 = set_find (pe, PE_CLASS_CONT, 3)) {
        vname ("abstract");
        if (print_ISPR2_Character__Data (p54, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p54_count ++;
    }
    if (p54 = set_find (pe, PE_CLASS_CONT, 4)) {
        register PE p55;

        vname ("keywords");
        if ((p55 = prim2set (p54)) == NULLPE) {
            advise (NULLCP, "keywords bad set: %s",
                    pe_error (p54 -> pe_errno));
            return NOTOK;
        }
        p54 = p55;

        vpush ();
        for (p55 = first_member (p54); p55; p55 = next_member (p54, p55)) {
            if (print_ISPR2_Character__Data (p55, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p54_count ++;
    }
    if (p54 = set_find (pe, PE_CLASS_CONT, 5)) {
        register PE p56 = p54;

        {	/* document-reference TAG PULLUP */
            register PE p57;

            if ((p57 = prim2set (p56)) == NULLPE) {
                advise (NULLCP, "document-reference bad document-reference: %s",
                        pe_error (p56 -> pe_errno));
                return NOTOK;
            }
            if (p57 -> pe_cardinal != 1) {
                advise (NULLCP, "document-reference too many elements for tagged document-reference: %d",
                        p57 -> pe_cardinal);
                return NOTOK;
            }
            p56 = first_member (p57);
        }
        {
            vname ("document-reference");
            if (print_ISPR2_Document__Reference (p56, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        p54_count ++;
    }
    if (p54_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Character__Data (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register char *p58;
    int p58_len;

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_APPL, 3)) {
        advise (NULLCP, "Character-Data bad class/id: %s/0x%x", 
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if ((p58 = prim2str (pe, &p58_len)) == NULLCP) {
        advise (NULLCP, "Character-Data bad octetstring: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    vstring (pe);
    if (len)
        *len = p58_len;
    if (buffer)
        *buffer = p58;
    else
        if (p58)
            free (p58);

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Document__Reference (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    vpush ();
    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_UNIV, 6):	/* unique-reference */
            {
                register OID p59;

                vname ("unique-reference");
                if ((p59 = prim2oid (pe)) == NULLOID) {
                    advise (NULLCP, "unique-reference bad object identifier: %s",
                            pe_error (pe -> pe_errno));
                    return NOTOK;
                }
                vprint ("%s", oid2ode (p59));
            }
            break;
        case PE_ID (PE_CLASS_APPL, 3):	/* descriptive-reference */
            {
                vname ("descriptive-reference");
                if (print_ISPR2_Character__Data (pe, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
            }
            break;

        default:
            advise (NULLCP, "Document-Reference has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Dates__and__Times (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p60_count = 0;
    register PE p60;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Dates-and-Times bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Dates-and-Times bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p60 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Dates-and-Times bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p60;

    vpush ();
    if (p60 = set_find (pe, PE_CLASS_CONT, 0)) {
        vname ("document-date-and-time");
        if (print_ISPR2_Date__and__Time (p60, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p60_count ++;
    }
    if (p60 = set_find (pe, PE_CLASS_CONT, 1)) {
        vname ("creation-date-and-time");
        if (print_ISPR2_Date__and__Time (p60, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p60_count ++;
    }
    if (p60 = set_find (pe, PE_CLASS_CONT, 2)) {
        register PE p61;

        vname ("local-filing-date-and-time");
        if ((p61 = prim2seq (p60)) == NULLPE) {
            advise (NULLCP, "local-filing-date-and-time bad sequence: %s",
                    pe_error (p60 -> pe_errno));
            return NOTOK;
        }
        p60 = p61;

        vpush ();
        for (p61 = first_member (p60); p61; p61 = next_member (p60, p61)) {
            if (print_ISPR2_Date__and__Time (p61, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p60_count ++;
    }
    if (p60 = set_find (pe, PE_CLASS_CONT, 3)) {
        vname ("expiry-date-and-time");
        if (print_ISPR2_Date__and__Time (p60, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p60_count ++;
    }
    if (p60 = set_find (pe, PE_CLASS_CONT, 4)) {
        vname ("start-date-and-time");
        if (print_ISPR2_Date__and__Time (p60, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p60_count ++;
    }
    if (p60 = set_find (pe, PE_CLASS_CONT, 5)) {
        vname ("purge-date-and-time");
        if (print_ISPR2_Date__and__Time (p60, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p60_count ++;
    }
    if (p60 = set_find (pe, PE_CLASS_CONT, 6)) {
        vname ("release-date-and-time");
        if (print_ISPR2_Date__and__Time (p60, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p60_count ++;
    }
    if (p60 = set_find (pe, PE_CLASS_CONT, 7)) {
        register PE p62;

        vname ("revision-history");
        if ((p62 = prim2seq (p60)) == NULLPE) {
            advise (NULLCP, "revision-history bad sequence: %s",
                    pe_error (p60 -> pe_errno));
            return NOTOK;
        }
        p60 = p62;

        vpush ();
        for (p62 = first_member (p60); p62; p62 = next_member (p60, p62)) {
            int p63_count = 0;
            register PE p63;

            if (p62 -> pe_class != PE_CLASS_UNIV
                    || p62 -> pe_form != PE_FORM_CONS
                    || p62 -> pe_id != PE_CONS_SET) {
                advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p62 -> pe_class], p62 -> pe_form, p62 -> pe_id);
                return NOTOK;
            }

            if ((p63 = prim2set (p62)) == NULLPE) {
                advise (NULLCP, "element bad set: %s",
                        pe_error (p62 -> pe_errno));
                return NOTOK;
            }
            p62 = p63;

            vpush ();
            if (p63 = set_find (p62, PE_CLASS_CONT, 0)) {
                vname ("revision-date-and-time");
                if (print_ISPR2_Date__and__Time (p63, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p63_count ++;
            }
            if (p63 = set_find (p62, PE_CLASS_CONT, 1)) {
                vname ("version-number");
                if (print_UNIV_NumericString (p63, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p63_count ++;
            }
            if (p63 = set_find (p62, PE_CLASS_CONT, 2)) {
                register PE p64;

                vname ("revisors");
                if ((p64 = prim2set (p63)) == NULLPE) {
                    advise (NULLCP, "revisors bad set: %s",
                            pe_error (p63 -> pe_errno));
                    return NOTOK;
                }
                p63 = p64;

                vpush ();
                for (p64 = first_member (p63); p64; p64 = next_member (p63, p64)) {
                    int p65_count = 0;
                    register PE p65;

                    if (p64 -> pe_class != PE_CLASS_UNIV
                            || p64 -> pe_form != PE_FORM_CONS
                            || p64 -> pe_id != PE_CONS_SET) {
                        advise (NULLCP, "member bad class/form/id: %s/%d/0x%x",
                                pe_classlist[p64 -> pe_class], p64 -> pe_form, p64 -> pe_id);
                        return NOTOK;
                    }

                    if ((p65 = prim2set (p64)) == NULLPE) {
                        advise (NULLCP, "member bad set: %s",
                                pe_error (p64 -> pe_errno));
                        return NOTOK;
                    }
                    p64 = p65;

                    vpush ();
                    if (p65 = set_find (p64, PE_CLASS_CONT, 0)) {
                        register PE p66;

                        vname ("names");
                        if ((p66 = prim2set (p65)) == NULLPE) {
                            advise (NULLCP, "names bad set: %s",
                                    pe_error (p65 -> pe_errno));
                            return NOTOK;
                        }
                        p65 = p66;

                        vpush ();
                        for (p66 = first_member (p65); p66; p66 = next_member (p65, p66)) {
                            if (print_ISPR2_Personal__Name (p66, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                                return NOTOK;
                        }
                        vpop ();
                        p65_count ++;
                    }
                    if (p65 = set_find (p64, PE_CLASS_CONT, 1)) {
                        vname ("position");
                        if (print_ISPR2_Character__Data (p65, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                            return NOTOK;
                        p65_count ++;
                    }
                    if (p65 = set_find (p64, PE_CLASS_CONT, 2)) {
                        vname ("organization");
                        if (print_ISPR2_Character__Data (p65, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                            return NOTOK;
                        p65_count ++;
                    }
                    if (p65_count != p64 -> pe_cardinal)
                        advise (NULLCP, "warning: extra or duplicate members present in SET");
                    vpop ();
                }
                vpop ();
                p63_count ++;
            }
            if (p63 = set_find (p62, PE_CLASS_CONT, 3)) {
                register PE p67 = p63;

                {	/* version-reference TAG PULLUP */
                    register PE p68;

                    if ((p68 = prim2set (p67)) == NULLPE) {
                        advise (NULLCP, "version-reference bad version-reference: %s",
                                pe_error (p67 -> pe_errno));
                        return NOTOK;
                    }
                    if (p68 -> pe_cardinal != 1) {
                        advise (NULLCP, "version-reference too many elements for tagged version-reference: %d",
                                p68 -> pe_cardinal);
                        return NOTOK;
                    }
                    p67 = first_member (p68);
                }
                {
                    vname ("version-reference");
                    if (print_ISPR2_Document__Reference (p67, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                p63_count ++;
            }
            if (p63 = set_find (p62, PE_CLASS_CONT, 4)) {
                vname ("user-comments");
                if (print_ISPR2_Character__Data (p63, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p63_count ++;
            }
            if (p63_count != p62 -> pe_cardinal)
                advise (NULLCP, "warning: extra or duplicate members present in SET");
            vpop ();
        }
        vpop ();
        p60_count ++;
    }
    if (p60_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Date__and__Time (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_APPL, 4)) {
        advise (NULLCP, "Date-and-Time bad class/id: %s/0x%x", 
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (print_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Originators (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p69_count = 0;
    register PE p69;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Originators bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Originators bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p69 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Originators bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p69;

    vpush ();
    if (p69 = set_find (pe, PE_CLASS_CONT, 0)) {
        register PE p70;

        vname ("organizations");
        if ((p70 = prim2set (p69)) == NULLPE) {
            advise (NULLCP, "organizations bad set: %s",
                    pe_error (p69 -> pe_errno));
            return NOTOK;
        }
        p69 = p70;

        vpush ();
        for (p70 = first_member (p69); p70; p70 = next_member (p69, p70)) {
            if (print_ISPR2_Character__Data (p70, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p69_count ++;
    }
    if (p69 = set_find (pe, PE_CLASS_CONT, 1)) {
        register PE p71;

        vname ("preparers");
        if ((p71 = prim2seq (p69)) == NULLPE) {
            advise (NULLCP, "preparers bad sequence: %s",
                    pe_error (p69 -> pe_errno));
            return NOTOK;
        }
        p69 = p71;

        vpush ();
        for (p71 = first_member (p69); p71; p71 = next_member (p69, p71)) {
            int p72_count = 0;
            register PE p72;

            if (p71 -> pe_class != PE_CLASS_UNIV
                    || p71 -> pe_form != PE_FORM_CONS
                    || p71 -> pe_id != PE_CONS_SET) {
                advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p71 -> pe_class], p71 -> pe_form, p71 -> pe_id);
                return NOTOK;
            }

            if ((p72 = prim2set (p71)) == NULLPE) {
                advise (NULLCP, "element bad set: %s",
                        pe_error (p71 -> pe_errno));
                return NOTOK;
            }
            p71 = p72;

            vpush ();
            if (p72 = set_find (p71, PE_CLASS_CONT, 0)) {
                vname ("personal-name");
                if (print_ISPR2_Personal__Name (p72, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p72_count ++;
            }
            if (p72 = set_find (p71, PE_CLASS_CONT, 1)) {
                vname ("organization");
                if (print_ISPR2_Character__Data (p72, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p72_count ++;
            }
            if (p72_count != p71 -> pe_cardinal)
                advise (NULLCP, "warning: extra or duplicate members present in SET");
            vpop ();
        }
        vpop ();
        p69_count ++;
    }
    if (p69 = set_find (pe, PE_CLASS_CONT, 2)) {
        register PE p73;

        vname ("owners");
        if ((p73 = prim2seq (p69)) == NULLPE) {
            advise (NULLCP, "owners bad sequence: %s",
                    pe_error (p69 -> pe_errno));
            return NOTOK;
        }
        p69 = p73;

        vpush ();
        for (p73 = first_member (p69); p73; p73 = next_member (p69, p73)) {
            int p74_count = 0;
            register PE p74;

            if (p73 -> pe_class != PE_CLASS_UNIV
                    || p73 -> pe_form != PE_FORM_CONS
                    || p73 -> pe_id != PE_CONS_SET) {
                advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p73 -> pe_class], p73 -> pe_form, p73 -> pe_id);
                return NOTOK;
            }

            if ((p74 = prim2set (p73)) == NULLPE) {
                advise (NULLCP, "element bad set: %s",
                        pe_error (p73 -> pe_errno));
                return NOTOK;
            }
            p73 = p74;

            vpush ();
            if (p74 = set_find (p73, PE_CLASS_CONT, 0)) {
                vname ("personal-name");
                if (print_ISPR2_Personal__Name (p74, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p74_count ++;
            }
            if (p74 = set_find (p73, PE_CLASS_CONT, 1)) {
                vname ("organization");
                if (print_ISPR2_Character__Data (p74, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p74_count ++;
            }
            if (p74_count != p73 -> pe_cardinal)
                advise (NULLCP, "warning: extra or duplicate members present in SET");
            vpop ();
        }
        vpop ();
        p69_count ++;
    }
    if (p69 = set_find (pe, PE_CLASS_CONT, 3)) {
        register PE p75;

        vname ("authors");
        if ((p75 = prim2seq (p69)) == NULLPE) {
            advise (NULLCP, "authors bad sequence: %s",
                    pe_error (p69 -> pe_errno));
            return NOTOK;
        }
        p69 = p75;

        vpush ();
        for (p75 = first_member (p69); p75; p75 = next_member (p69, p75)) {
            int p76_count = 0;
            register PE p76;

            if (p75 -> pe_class != PE_CLASS_UNIV
                    || p75 -> pe_form != PE_FORM_CONS
                    || p75 -> pe_id != PE_CONS_SET) {
                advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p75 -> pe_class], p75 -> pe_form, p75 -> pe_id);
                return NOTOK;
            }

            if ((p76 = prim2set (p75)) == NULLPE) {
                advise (NULLCP, "element bad set: %s",
                        pe_error (p75 -> pe_errno));
                return NOTOK;
            }
            p75 = p76;

            vpush ();
            if (p76 = set_find (p75, PE_CLASS_CONT, 0)) {
                vname ("personal-name");
                if (print_ISPR2_Personal__Name (p76, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p76_count ++;
            }
            if (p76 = set_find (p75, PE_CLASS_CONT, 1)) {
                vname ("organization");
                if (print_ISPR2_Character__Data (p76, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p76_count ++;
            }
            if (p76_count != p75 -> pe_cardinal)
                advise (NULLCP, "warning: extra or duplicate members present in SET");
            vpop ();
        }
        vpop ();
        p69_count ++;
    }
    if (p69_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Personal__Name (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p77_count = 0;
    register PE p77;

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_APPL, 6)) {
        advise (NULLCP, "Personal-Name bad class/id: %s/0x%x", 
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if ((p77 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Personal-Name bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p77;

    vpush ();
    if (p77 = set_find (pe, PE_CLASS_CONT, 0)) {
        vname ("surname");
        if (print_ISPR2_Character__Data (p77, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p77_count ++;
    }
    else {
        advise (NULLCP, "surname missing surname member");
        return NOTOK;
    }

    if (p77 = set_find (pe, PE_CLASS_CONT, 1)) {
        vname ("givenname");
        if (print_ISPR2_Character__Data (p77, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p77_count ++;
    }
    if (p77 = set_find (pe, PE_CLASS_CONT, 2)) {
        vname ("initials");
        if (print_ISPR2_Character__Data (p77, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p77_count ++;
    }
    if (p77 = set_find (pe, PE_CLASS_CONT, 3)) {
        vname ("title");
        if (print_ISPR2_Character__Data (p77, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p77_count ++;
    }
    if (p77_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Other__User__Information (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p78_count = 0;
    register PE p78;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Other-User-Information bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Other-User-Information bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p78 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Other-User-Information bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p78;

    vpush ();
    if (p78 = set_find (pe, PE_CLASS_CONT, 0)) {
        register PE p79;

        vname ("copyright");
        if ((p79 = prim2set (p78)) == NULLPE) {
            advise (NULLCP, "copyright bad set: %s",
                    pe_error (p78 -> pe_errno));
            return NOTOK;
        }
        p78 = p79;

        vpush ();
        for (p79 = first_member (p78); p79; p79 = next_member (p78, p79)) {
            int p80_count = 0;
            register PE p80;

            if (p79 -> pe_class != PE_CLASS_UNIV
                    || p79 -> pe_form != PE_FORM_CONS
                    || p79 -> pe_id != PE_CONS_SET) {
                advise (NULLCP, "member bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p79 -> pe_class], p79 -> pe_form, p79 -> pe_id);
                return NOTOK;
            }

            if ((p80 = prim2set (p79)) == NULLPE) {
                advise (NULLCP, "member bad set: %s",
                        pe_error (p79 -> pe_errno));
                return NOTOK;
            }
            p79 = p80;

            vpush ();
            if (p80 = set_find (p79, PE_CLASS_CONT, 0)) {
                register PE p81;

                vname ("copyright-information");
                if ((p81 = prim2set (p80)) == NULLPE) {
                    advise (NULLCP, "copyright-information bad set: %s",
                            pe_error (p80 -> pe_errno));
                    return NOTOK;
                }
                p80 = p81;

                vpush ();
                for (p81 = first_member (p80); p81; p81 = next_member (p80, p81)) {
                    if (print_ISPR2_Character__Data (p81, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                vpop ();
                p80_count ++;
            }
            if (p80 = set_find (p79, PE_CLASS_CONT, 1)) {
                register PE p82;

                vname ("copyright-dates");
                if ((p82 = prim2set (p80)) == NULLPE) {
                    advise (NULLCP, "copyright-dates bad set: %s",
                            pe_error (p80 -> pe_errno));
                    return NOTOK;
                }
                p80 = p82;

                vpush ();
                for (p82 = first_member (p80); p82; p82 = next_member (p80, p82)) {
                    if (print_ISPR2_Character__Data (p82, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                vpop ();
                p80_count ++;
            }
            if (p80_count != p79 -> pe_cardinal)
                advise (NULLCP, "warning: extra or duplicate members present in SET");
            vpop ();
        }
        vpop ();
        p78_count ++;
    }
    if (p78 = set_find (pe, PE_CLASS_CONT, 1)) {
        vname ("status");
        if (print_ISPR2_Character__Data (p78, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p78_count ++;
    }
    if (p78 = set_find (pe, PE_CLASS_CONT, 2)) {
        register PE p83;

        vname ("user-specific-codes");
        if ((p83 = prim2set (p78)) == NULLPE) {
            advise (NULLCP, "user-specific-codes bad set: %s",
                    pe_error (p78 -> pe_errno));
            return NOTOK;
        }
        p78 = p83;

        vpush ();
        for (p83 = first_member (p78); p83; p83 = next_member (p78, p83)) {
            if (print_ISPR2_Character__Data (p83, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p78_count ++;
    }
    if (p78 = set_find (pe, PE_CLASS_CONT, 3)) {
        register PE p84;

        vname ("distribution-list");
        if ((p84 = prim2seq (p78)) == NULLPE) {
            advise (NULLCP, "distribution-list bad sequence: %s",
                    pe_error (p78 -> pe_errno));
            return NOTOK;
        }
        p78 = p84;

        vpush ();
        for (p84 = first_member (p78); p84; p84 = next_member (p78, p84)) {
            int p85_count = 0;
            register PE p85;

            if (p84 -> pe_class != PE_CLASS_UNIV
                    || p84 -> pe_form != PE_FORM_CONS
                    || p84 -> pe_id != PE_CONS_SET) {
                advise (NULLCP, "element bad class/form/id: %s/%d/0x%x",
                        pe_classlist[p84 -> pe_class], p84 -> pe_form, p84 -> pe_id);
                return NOTOK;
            }

            if ((p85 = prim2set (p84)) == NULLPE) {
                advise (NULLCP, "element bad set: %s",
                        pe_error (p84 -> pe_errno));
                return NOTOK;
            }
            p84 = p85;

            vpush ();
            if (p85 = set_find (p84, PE_CLASS_CONT, 0)) {
                vname ("personal-name");
                if (print_ISPR2_Personal__Name (p85, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p85_count ++;
            }
            if (p85 = set_find (p84, PE_CLASS_CONT, 1)) {
                vname ("organization");
                if (print_ISPR2_Character__Data (p85, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                    return NOTOK;
                p85_count ++;
            }
            if (p85_count != p84 -> pe_cardinal)
                advise (NULLCP, "warning: extra or duplicate members present in SET");
            vpop ();
        }
        vpop ();
        p78_count ++;
    }
    if (p78 = set_find (pe, PE_CLASS_CONT, 5)) {
        register PE p86 = p78;

        {	/* additional-information TAG PULLUP */
            register PE p87;

            if ((p87 = prim2set (p86)) == NULLPE) {
                advise (NULLCP, "additional-information bad additional-information: %s",
                        pe_error (p86 -> pe_errno));
                return NOTOK;
            }
            if (p87 -> pe_cardinal != 1) {
                advise (NULLCP, "additional-information too many elements for tagged additional-information: %d",
                        p87 -> pe_cardinal);
                return NOTOK;
            }
            p86 = first_member (p87);
        }
        {
            vname ("additional-information");
            vunknown (p86);
        }
        p78_count ++;
    }
    if (p78_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_External__References (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p88_count = 0;
    register PE p88;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "External-References bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "External-References bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p88 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "External-References bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p88;

    vpush ();
    if (p88 = set_find (pe, PE_CLASS_CONT, 0)) {
        register PE p89;

        vname ("references-to-other-documents");
        if ((p89 = prim2set (p88)) == NULLPE) {
            advise (NULLCP, "references-to-other-documents bad set: %s",
                    pe_error (p88 -> pe_errno));
            return NOTOK;
        }
        p88 = p89;

        vpush ();
        for (p89 = first_member (p88); p89; p89 = next_member (p88, p89)) {
            if (print_ISPR2_Document__Reference (p89, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p88_count ++;
    }
    if (p88 = set_find (pe, PE_CLASS_CONT, 1)) {
        register PE p90;

        vname ("superseded-documents");
        if ((p90 = prim2set (p88)) == NULLPE) {
            advise (NULLCP, "superseded-documents bad set: %s",
                    pe_error (p88 -> pe_errno));
            return NOTOK;
        }
        p88 = p90;

        vpush ();
        for (p90 = first_member (p88); p90; p90 = next_member (p88, p90)) {
            if (print_ISPR2_Document__Reference (p90, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p88_count ++;
    }
    if (p88_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Local__File__References (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register PE p91;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Local-File-References bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Local-File-References bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p91 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Local-File-References bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p91;

    vpush ();
    for (p91 = first_member (pe); p91; p91 = next_member (pe, p91)) {
        int p92_count = 0;
        register PE p92;

        if (p91 -> pe_class != PE_CLASS_UNIV
                || p91 -> pe_form != PE_FORM_CONS
                || p91 -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "member bad class/form/id: %s/%d/0x%x",
                    pe_classlist[p91 -> pe_class], p91 -> pe_form, p91 -> pe_id);
            return NOTOK;
        }

        if ((p92 = prim2set (p91)) == NULLPE) {
            advise (NULLCP, "member bad set: %s",
                    pe_error (p91 -> pe_errno));
            return NOTOK;
        }
        p91 = p92;

        vpush ();
        if (p92 = set_find (p91, PE_CLASS_CONT, 0)) {
            vname ("filename");
            if (print_ISPR2_Character__Data (p92, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
            p92_count ++;
        }
        if (p92 = set_find (p91, PE_CLASS_CONT, 1)) {
            vname ("location");
            if (print_ISPR2_Character__Data (p92, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
            p92_count ++;
        }
        if (p92 = set_find (p91, PE_CLASS_CONT, 2)) {
            vname ("user-comments");
            if (print_ISPR2_Character__Data (p92, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
            p92_count ++;
        }
        if (p92_count != p91 -> pe_cardinal)
            advise (NULLCP, "warning: extra or duplicate members present in SET");
        vpop ();
    }
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Content__Attributes (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p93_count = 0;
    register PE p93;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Content-Attributes bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Content-Attributes bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p93 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Content-Attributes bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p93;

    vpush ();
    if (p93 = set_find (pe, PE_CLASS_CONT, 1)) {
        register int p94;

        vname ("document-size");
        if ((p94 = prim2num (p93)) == NOTOK
                && p93 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "document-size bad integer: %s",
                    pe_error (p93 -> pe_errno));
            return NOTOK;
        }
        vprint ("%d", p94);
        p93_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p93 = set_find (pe, PE_CLASS_CONT, 2)) {
        register int p95;

        vname ("number-of-pages");
        if ((p95 = prim2num (p93)) == NOTOK
                && p93 -> pe_errno != PE_ERR_NONE) {
            advise (NULLCP, "number-of-pages bad integer: %s",
                    pe_error (p93 -> pe_errno));
            return NOTOK;
        }
        vprint ("%d", p95);
        p93_count ++;
    }
    else {
        /* set default here using yp -> yp_default */
    }

    if (p93 = set_find (pe, PE_CLASS_CONT, 4)) {
        register PE p96;

        vname ("languages");
        if ((p96 = prim2set (p93)) == NULLPE) {
            advise (NULLCP, "languages bad set: %s",
                    pe_error (p93 -> pe_errno));
            return NOTOK;
        }
        p93 = p96;

        vpush ();
        for (p96 = first_member (p93); p96; p96 = next_member (p93, p96)) {
            if (print_ISPR2_Character__Data (p96, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p93_count ++;
    }
    if (p93_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}

/* ARGSUSED */

int	print_ISPR2_Security__Information (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    int p97_count = 0;
    register PE p97;

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Security-Information bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Security-Information bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p97 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Security-Information bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p97;

    vpush ();
    if ( (p97 = set_find (pe, PE_CLASS_CONT, 0))
        || (p97 = set_find (pe, PE_CLASS_CONT, 4)) ) {
        vname ("authorization");
        vpush ();
        switch (PE_ID (p97 -> pe_class, p97 -> pe_id)) {
            case PE_ID (PE_CLASS_CONT, 0):	/* person */
                {
                    vname ("person");
                    if (print_ISPR2_Personal__Name (p97, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;
            case PE_ID (PE_CLASS_CONT, 4):	/* organization */
                {
                    vname ("organization");
                    if (print_ISPR2_Character__Data (p97, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;

            default:
                advise (NULLCP, "authorization has unknown choice: %s/%d/0x%x",
                        pe_classlist[p97 -> pe_class], p97 -> pe_form, p97 -> pe_id);
                return NOTOK;
        }
        vpop ();
        p97_count ++;
    }
    if (p97 = set_find (pe, PE_CLASS_CONT, 1)) {
        vname ("security-classification");
        if (print_ISPR2_Character__Data (p97, 0, NULLIP, NULLVP, NullParm) == NOTOK)
            return NOTOK;
        p97_count ++;
    }
    if (p97 = set_find (pe, PE_CLASS_CONT, 2)) {
        register PE p98;

        vname ("access-rights");
        if ((p98 = prim2set (p97)) == NULLPE) {
            advise (NULLCP, "access-rights bad set: %s",
                    pe_error (p97 -> pe_errno));
            return NOTOK;
        }
        p97 = p98;

        vpush ();
        for (p98 = first_member (p97); p98; p98 = next_member (p97, p98)) {
            if (print_ISPR2_Character__Data (p98, 1, NULLIP, NULLVP, NullParm) == NOTOK)
                return NOTOK;
        }
        vpop ();
        p97_count ++;
    }
    if (p97_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    vpop ();

    return OK;
}
