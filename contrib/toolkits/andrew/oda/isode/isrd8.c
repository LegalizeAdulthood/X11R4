/* automatically generated by pepy 5.0 #1 (mss.andrew.cmu.edu), do not edit! */

#include <psap.h>

static char *pepyid = "pepy 5.0 #1 (mss.andrew.cmu.edu) of Mon May 22 20:44:32 EDT 1989";

#define	advise	PY_advise

void	advise ();

/* Generated from module ISRD8 */
# line 5 "isrd8.py"


/*
 *
 * (C) Copyright 1989 by Carnegie Mellon University
 *
 * Permission to use, copy, modify, and distribute these programs
 * and their documentation for any purpose and without fee is
 * hereby granted, provided that this copyright and permission
 * notice appear on all copies and supporting documentation, and
 * that the name of Carnegie Mellon University not be used in
 * advertising or publicity pertaining to distribution of the
 * programs without specific prior permission and notice be given
 * in supporting documentation that copying and distribution is
 * by permission of Carnegie Mellon University.
 *
 * Carnegie Mellon University makes no representations about the
 * suitability of this software for any purpose.  It is provided
 * as is, without express or implied warranty.
 *
 * Software by Ann Marks and James T. Lui,
 * Information Technology Center, Carnegie Mellon University,
 * except where noted.
 *
 */

#define TK_TKI_TKERR
#define TK_TKI_APIRT

#include <odatk.h>

#undef TK_TKI_TKERR
#undef TK_TKI_APIRT

#define TK_IMPL_ISRD

#include <isrd.h>

#undef TK_IMPL_ISRD

#define PEPYPARM struct isode2toolkit_t *

INT_type dummy;


#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	parse_ISRD8_Text__Unit (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct isode2toolkit_t *  parm;
{
# line 73 "isrd8.py"
    
    SEQUENCE_INT_type TypeOfCoding;

    STRING_type ContentLayoutIDString;
    STRING_type ContentLogicalIDString;

    INT_type ContentInfoLength;
    CHAR_type *ContentInfoChars;
    STRING_type ContentInfoString;
    SEQUENCE_BYTE_type ContentInfo;

    BOOL_type NoContentLayoutID;
    BOOL_type NoContentLogicalID;

    struct hash_t *HashStructure;

    CONSTITUENT_type TheConstituent;

    register PE p0;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD8.Text-Unit");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "Text-Unit bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Text-Unit bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p0 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Text-Unit bad sequence: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p0;

    {
        register PE p1;

        if ((p1 = first_member (pe)) != NULLPE
                && PE_ID (p1 -> pe_class, p1 -> pe_id)
                        != PE_ID (PE_CLASS_UNIV, 17))
            p1 = NULLPE;
        if (p1 != NULLPE) {
            p0 = p1;

            {	/* content-portion-attributes */
#ifdef DEBUG
                (void) testdebug (p1, "content-portion-attributes");
#endif

                if (parse_ISRD8_Content__Portion__Attributes (p1, 1, NULLIP, NULLVP, parm ) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p2;

        if ((p2 = (pe != p0 ? next_member (pe, p0) : first_member (pe))) != NULLPE) {
            p0 = p2;

            {	/* content-information */
#ifdef DEBUG
                (void) testdebug (p2, "content-information");
#endif

                if (parse_ISRD8_Content__Information (p2, 1, &( ContentInfoLength ), &(ContentInfoChars ), NullParm) == NOTOK)
                    return NOTOK;
                {
# line 104 "isrd8.py"

	    ContentInfoString = MakeString(ContentInfoLength);
	    if ( ContentInfoString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD8_Text__Unit]: can not make string for attribute at_CONTENT_INFORMATION" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ContentInfoString->sequence_value.chars = ContentInfoChars;
	    ContentInfo = String2Bytes(ContentInfoString);
	    if ( ContentInfo == ERROR_SEQUENCE) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD8_Text__Unit]: can not make byte sequence for attribute at_CONTENT_INFORMATION" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    if ( SetAttr( parm->constituent,
			  at_CONTENT_INFORMATION,
			  (POINTER_type) ContentInfo,
			  /* mask */ (PARM_MASK_type) 0
		        ) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD8_Text__Unit]: can not set attribute at_CONTENT_INFORMATION" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
                }
            }
        }
        else {
            advise (NULLCP, "Text-Unit missing content-information element");
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 2) {
        advise (NULLCP, "Text-Unit has too many elements(2): %d",
                pe -> pe_cardinal);
        return NOTOK;
    }
    {
# line 134 "isrd8.py"

    if ( GetAttr( parm->constituent,
		  at_CONTENT_ID_LAYOUT,
		  (POINTER_type) &ContentLayoutIDString,
		  /* default */ BOOL_false,
		  /* mask */ (PARM_MASK_type *) 0
	        ) != ERROR_INT ) {
	NoContentLayoutID = BOOL_false;
	if ( ISODE_FillInConstituent ( parm->constituent,
				       ContentLayoutIDString
				     ) == ERROR_INT ) {
	    return ( NOTOK );
	}
    } else {
	NoContentLayoutID = BOOL_true;
    }
    if ( GetAttr( parm->constituent,
		  at_CONTENT_ID_LOGICAL,
		  (POINTER_type) &ContentLogicalIDString,
		  /* default */ BOOL_false,
		  /* mask */ (PARM_MASK_type *) 0
	        ) != ERROR_INT ) {
	NoContentLogicalID = BOOL_false;
	if ( NoContentLayoutID ) {
	    TheConstituent = parm->constituent;
	} else {
	    HashStructure =
		ISODE_GetHashStructure(ContentLayoutIDString,parm->document);
	    TheConstituent = HashStructure->constituent;
	}
	if( ISODE_AddToHash( TheConstituent,
			     ContentLogicalIDString
			   ) == ERROR_INT ) {
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[parse_ISRD8_Text__Unit]: can not add content portion under the logical id found" );
	    dummy = TKERR_EndErrMsg();
	    return ( NOTOK);
	}
    } else {
	NoContentLogicalID = BOOL_true;
    }
    if ( NoContentLayoutID && NoContentLogicalID) {
	dummy = TKERR_StartErrMsg();
	dummy = TKERR_Format("[parse_ISRD8_Text__Unit]: can not find content logical or layout id" );
	dummy = TKERR_EndErrMsg();
	return ( NOTOK );
    }
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD8_Content__Portion__Attributes (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct isode2toolkit_t *  parm;
{
# line 186 "isrd8.py"
    
    CHAR_type *ContentLayoutIDChars;
    STRING_type ContentLayoutIDString;

    CHAR_type *ContentLogicalIDChars;
    STRING_type ContentLogicalIDString;

    struct OIDentifier *TypeOfCodingObjectID;
    SEQUENCE_INT_type TypeOfCoding;
    VALUE_type ContentType;

    INT_type AltRepLength;
    CHAR_type *AltRepChars;
    STRING_type AltRepString;

    BOOL_type ContentLayoutIDFound;
    BOOL_type ContentLogicalIDFound;
    BOOL_type TypeOfCodingFound;
    BOOL_type AltRepFound;

    int p3_count = 0;
    register PE p3;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD8.Content-Portion-Attributes");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SET) {
            advise (NULLCP, "Content-Portion-Attributes bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "Content-Portion-Attributes bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    {
# line 209 "isrd8.py"

    ContentLayoutIDFound = BOOL_false;
    ContentLogicalIDFound = BOOL_false;
    TypeOfCodingFound = BOOL_false;
    AltRepFound = BOOL_false;
    }
    if ((p3 = prim2set (pe)) == NULLPE) {
        advise (NULLCP, "Content-Portion-Attributes bad set: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p3;

    if (p3 = set_find (pe, PE_CLASS_APPL, 0)) {
#ifdef DEBUG
        (void) testdebug (p3, "content-identifier-layout");
#endif

        if (parse_ISRD3_Content__Portion__Identifier (p3, 0, NULLIP, &(ContentLayoutIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 222 "isrd8.py"

	    ContentLayoutIDString = Chars2String(ContentLayoutIDChars);
	    if ( ContentLayoutIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: can not convert content layout id to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ContentLayoutIDFound = BOOL_true;
	
        }
        p3_count ++;
    }
    if (p3 = set_find (pe, PE_CLASS_CONT, 4)) {
#ifdef DEBUG
        (void) testdebug (p3, "content-identifier-logical");
#endif

        if (parse_ISRD3_Content__Portion__Identifier (p3, 0, NULLIP, &(ContentLogicalIDChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 239 "isrd8.py"

	    ContentLogicalIDString = Chars2String(ContentLogicalIDChars);
	    if ( ContentLogicalIDString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: can not convert content logical id to a string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    ContentLogicalIDFound = BOOL_true;
	
        }
        p3_count ++;
    }
    if ( (p3 = set_find (pe, PE_CLASS_CONT, 0))
        || (p3 = set_find (pe, PE_CLASS_CONT, 6)) ) {
#ifdef DEBUG
        (void) testdebug (p3, "type-of-coding");
#endif

        switch (PE_ID (p3 -> pe_class, p3 -> pe_id)) {
            case PE_ID (PE_CLASS_CONT, 0):
                {
                    register int p4;

#ifdef DEBUG
                    (void) testdebug (p3, "member");
#endif

                    if ((p4 = prim2num (p3)) == NOTOK
                            && p3 -> pe_errno != PE_ERR_NONE) {
                        advise (NULLCP, "member bad integer: %s",
                                pe_error (p3 -> pe_errno));
                        return NOTOK;
                    }
                    switch (p4) {
                        case 0:	/* iso2022 */
                            break;
                        case 1:	/* t6 */
                            break;
                        default:
                            advise (NULLCP, "member has unknown component: %d", p4);
                            return NOTOK;
                    }
                    {
# line 262 "isrd8.py"

		    dummy = TKERR_StartErrMsg();
		    dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: This type of coding format not supported");
		    dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: Type of coding must be an object identifier");
		    dummy = TKERR_EndErrMsg();
		    return( NOTOK );
		
                    }
                }
                break;
            case PE_ID (PE_CLASS_CONT, 6):
                {
                    register OID p5;

#ifdef DEBUG
                    (void) testdebug (p3, "member");
#endif

                    if ((p5 = prim2oid (p3)) == NULLOID) {
                        advise (NULLCP, "member bad object identifier: %s",
                                pe_error (p3 -> pe_errno));
                        return NOTOK;
                    }
                    TypeOfCodingObjectID  = oid_cpy (p5);
                    {
# line 273 "isrd8.py"

		    TypeOfCoding = OID2Ints(TypeOfCodingObjectID);
		    if ( TypeOfCoding == ERROR_SEQUENCE ) {
			dummy = TKERR_StartErrMsg();
			dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: can not convert type of coding to integer sequence" );
			dummy = TKERR_EndErrMsg();
			return( NOTOK );
		    }
		    if ( MatchInts(TypeOfCoding,at_TYPE_OF_CODING_cc) ) {
			ContentType = CHARACTER_CONTENT;
		    } else if ( MatchInts(TypeOfCoding,at_TYPE_OF_CODING_gg) ) {
			ContentType = GEOMETRIC_GRAPHICS_CONTENT;
		    } else if ( (MatchInts(TypeOfCoding,
					   at_TYPE_OF_CODING_T6)) ||
				(MatchInts(TypeOfCoding,
					   at_TYPE_OF_CODING_T4_1)) ||
				(MatchInts(TypeOfCoding,
					   at_TYPE_OF_CODING_T4_2)) ||
				(MatchInts(TypeOfCoding,
					   at_TYPE_OF_CODING_bitmap)) ) {
			ContentType = RASTER_GRAPHICS_CONTENT;
		    } else {
			dummy = TKERR_StartErrMsg();
			dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: Type of coding invalid" );
			dummy = TKERR_EndErrMsg();
			return( NOTOK );
		    }
		    TypeOfCodingFound = BOOL_true;
		
                    }
                }
                break;

            default:
                advise (NULLCP, "type-of-coding has unknown choice: %s/%d/0x%x",
                        pe_classlist[p3 -> pe_class], p3 -> pe_form, p3 -> pe_id);
                return NOTOK;
        }
        p3_count ++;
    }
    if ( (p3 = set_find (pe, PE_CLASS_CONT, 1))
        || (p3 = set_find (pe, PE_CLASS_CONT, 2))
        || (p3 = set_find (pe, PE_CLASS_CONT, 7))
        || (p3 = set_find (pe, PE_CLASS_CONT, 11)) ) {
#ifdef DEBUG
        (void) testdebug (p3, "coding-attributes");
#endif

        switch (PE_ID (p3 -> pe_class, p3 -> pe_id)) {
            case PE_ID (PE_CLASS_CONT, 1):	/* character-coding-attributes */
                {
#ifdef DEBUG
                    (void) testdebug (p3, "character-coding-attributes");
#endif

                    if (parse_ISRD10_Character__Coding__Attributes (p3, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;
            case PE_ID (PE_CLASS_CONT, 2):	/* raster-gr-coding-attributes */
                {
#ifdef DEBUG
                    (void) testdebug (p3, "raster-gr-coding-attributes");
#endif

                    if (parse_ISRD13_Raster__Gr__Coding__Attributes (p3, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;
            case PE_ID (PE_CLASS_CONT, 7):	/* geo-gr-coding-attributes */
                {
#ifdef DEBUG
                    (void) testdebug (p3, "geo-gr-coding-attributes");
#endif

                    if (parse_ISRD16_Geo__Gr__Coding__Attributes (p3, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;
            case PE_ID (PE_CLASS_CONT, 11):	/* ext-cont-arch-coding-attributes */
                {
#ifdef DEBUG
                    (void) testdebug (p3, "ext-cont-arch-coding-attributes");
#endif

                    if (parse_UNIV_EXTERNAL (p3, 0, NULLIP, NULLVP, NullParm) == NOTOK)
                        return NOTOK;
                }
                break;

            default:
                advise (NULLCP, "coding-attributes has unknown choice: %s/%d/0x%x",
                        pe_classlist[p3 -> pe_class], p3 -> pe_form, p3 -> pe_id);
                return NOTOK;
        }
        p3_count ++;
    }
    if (p3 = set_find (pe, PE_CLASS_CONT, 3)) {
#ifdef DEBUG
        (void) testdebug (p3, "alternative-representation");
#endif

        if (parse_ISRD8_Alternative__Representation (p3, 0, &( AltRepLength ), &(AltRepChars ), NullParm) == NOTOK)
            return NOTOK;
        {
# line 343 "isrd8.py"

	    AltRepString = MakeString(AltRepLength);
	    if ( AltRepString == ERROR_STRING ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: can not make string" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	    AltRepString->sequence_value.chars = AltRepChars;
	    AltRepFound = BOOL_true;
	
        }
        p3_count ++;
    }
    if (p3_count != pe -> pe_cardinal)
        advise (NULLCP, "warning: extra or duplicate members present in SET");
    {
# line 359 "isrd8.py"

    if ( TypeOfCodingFound ) {
	parm->constituent = MakeContent(parm->document,ContentType);
	if ( parm->constituent == ERROR_CONSTITUENT ) {
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: can not make content portion" );
	    dummy = TKERR_EndErrMsg();
	    return( NOTOK );
	}
	if ( SetAttr( parm->constituent,
		      at_TYPE_OF_CODING,
		      (POINTER_type) TypeOfCoding,
		      /* mask */ (PARM_MASK_type) 0
		    ) == ERROR_INT ) {
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: can not set attribute at_TYPE_OF_CODING" );
	    dummy = TKERR_EndErrMsg();
	    return( NOTOK );
	}
    } else {
	dummy = TKERR_StartErrMsg();
	dummy = TKERR_Format("[parse_ISRD8_Text__Unit]: can not find attribute at_TYPE_OF_CODING");
	dummy = TKERR_Format("[parse_ISRD8_Text__Unit]: Assuming CHARACTER_CONTENT by default");
	dummy = TKERR_EndErrMsg();
	parm->constituent =
	    MakeContent(parm->document, CHARACTER_CONTENT);
	if ( parm->constituent == ERROR_CONSTITUENT ) {
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: can not make content portion" );
	    dummy = TKERR_EndErrMsg();
	    return( NOTOK );
	}
    }
    if ( ContentLayoutIDFound ) {
	if ( SetAttr( parm->constituent,
		      at_CONTENT_ID_LOGICAL,
		      (POINTER_type) ContentLogicalIDString,
		      /* mask */ (PARM_MASK_type) 0
		    ) == ERROR_INT ) {
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: can not set attribute at_CONTENT_ID_LOGICAL" );
	    dummy = TKERR_EndErrMsg();
	    return( NOTOK );
	}
    }
    if ( ContentLogicalIDFound ) {
	if ( SetAttr( parm->constituent,
		      at_CONTENT_ID_LAYOUT,
		      (POINTER_type) ContentLayoutIDString,
		      /* mask */ (PARM_MASK_type) 0
		    ) == ERROR_INT ) {
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: can not set attribute at_CONTENT_ID_LAYOUT" );
	    dummy = TKERR_EndErrMsg();
	    return( NOTOK );
	}
    }
    if ( AltRepFound ) {
	if ( SetAttr( parm->constituent,
		      at_ALT_REP,
		      (POINTER_type) AltRepString,
		      /* mask */ (PARM_MASK_type) 0
		    ) == ERROR_INT ) {
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[parse_ISRD8_Content__Portion__Attributes]: can not set attribute at_ALT_REP" );
	    dummy = TKERR_EndErrMsg();
	    return( NOTOK );
	}
    }
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD8_Content__Information (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register char *p6;
    int p6_len;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD8.Content-Information");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV || pe -> pe_id != PE_PRIM_OCTS) {
            advise (NULLCP, "Content-Information bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }

    if ((p6 = prim2str (pe, &p6_len)) == NULLCP) {
        advise (NULLCP, "Content-Information bad octetstring: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p6_len;
    if (buffer)
        *buffer = p6;
    else
        if (p6)
            free (p6);

    return OK;
}

/* ARGSUSED */

int	parse_ISRD8_Type__of__Coding (pe, explicit, len, buffer, parm)
PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "ISRD8.Type-of-Coding");
#endif

    switch (PE_ID (pe -> pe_class, pe -> pe_id)) {
        case PE_ID (PE_CLASS_CONT, 0):
            {
                register int p7;

#ifdef DEBUG
                (void) testdebug (pe, "member");
#endif

                if ((p7 = prim2num (pe)) == NOTOK
                        && pe -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "member bad integer: %s",
                            pe_error (pe -> pe_errno));
                    return NOTOK;
                }
                switch (p7) {
                    case 0:	/* iso2022 */
                        break;
                    case 1:	/* t6 */
                        break;
                    default:
                        advise (NULLCP, "member has unknown component: %d", p7);
                        return NOTOK;
                }
            }
            break;
        case PE_ID (PE_CLASS_CONT, 6):
            {
#ifdef DEBUG
                (void) testdebug (pe, "member");
#endif

                if (prim2oid (pe) == NULLOID) {
                    advise (NULLCP, "member bad object identifier: %s",
                            pe_error (pe -> pe_errno));
                    return NOTOK;
                }
            }
            break;

        default:
            advise (NULLCP, "Type-of-Coding has unknown choice: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	parse_ISRD8_Alternative__Representation (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
PEPYPARM parm;
{
    register char *p8;
    int p8_len;

#ifdef DEBUG
    (void) testdebug (pe, "ISRD8.Alternative-Representation");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV || pe -> pe_id != PE_PRIM_OCTS) {
            advise (NULLCP, "Alternative-Representation bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }

    if ((p8 = prim2str (pe, &p8_len)) == NULLCP) {
        advise (NULLCP, "Alternative-Representation bad octetstring: %s",
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    if (len)
        *len = p8_len;
    if (buffer)
        *buffer = p8;
    else
        if (p8)
            free (p8);

    return OK;
}
