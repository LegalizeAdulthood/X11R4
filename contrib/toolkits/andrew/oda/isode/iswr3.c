/* automatically generated by pepy 5.0 #1 (mss.andrew.cmu.edu), do not edit! */

#include <psap.h>

static char *pepyid = "pepy 5.0 #1 (mss.andrew.cmu.edu) of Mon May 22 20:44:32 EDT 1989";

#define	advise	PY_advise

void	advise ();

/* Generated from module ISWR3 */
# line 5 "iswr3.py"


/*
 *
 * (C) Copyright 1989 by Carnegie Mellon University
 *
 * Permission to use, copy, modify, and distribute these programs
 * and their documentation for any purpose and without fee is
 * hereby granted, provided that this copyright and permission
 * notice appear on all copies and supporting documentation, and
 * that the name of Carnegie Mellon University not be used in
 * advertising or publicity pertaining to distribution of the
 * programs without specific prior permission and notice be given
 * in supporting documentation that copying and distribution is
 * by permission of Carnegie Mellon University.
 *
 * Carnegie Mellon University makes no representations about the
 * suitability of this software for any purpose.  It is provided
 * as is, without express or implied warranty.
 *
 * Software by Ann Marks and James T. Lui,
 * Information Technology Center, Carnegie Mellon University,
 * except where noted.
 *
 */

#define TK_TKI_TKERR
#define TK_TKI_APIRT

#include <odatk.h>

#undef TK_TKI_TKERR
#undef TK_TKI_APIRT

#define TK_IMPL_ISWR

#include <iswr.h>

#undef TK_IMPL_ISWR

#define PEPYPARM struct isode2toolkit_t *

INT_type dummy;


#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	build_ISWR3_Content__Portion__Identifier (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{
    if (build_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;
    (*pe) -> pe_class = PE_CLASS_APPL;
    (*pe) -> pe_id = 0;

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Content-Portion-Identifier");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Object__or__Class__Identifier (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{
    if (build_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;
    (*pe) -> pe_class = PE_CLASS_APPL;
    (*pe) -> pe_id = 1;

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Object-or-Class-Identifier");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Style__Identifier (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{
    if (build_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;
    (*pe) -> pe_class = PE_CLASS_APPL;
    (*pe) -> pe_id = 5;

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Style-Identifier");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Layout__Category__Name (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{
    if (build_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Layout-Category-Name");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Resource__Name (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{
    if (build_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Resource-Name");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Binding__Name (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{
    if (build_UNIV_PrintableString (pe, 0, len, buffer, NullParm) == NOTOK)
        return NOTOK;

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Binding-Name");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Construction__Expression (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CONSTRUCTION_EXPR_type *  parm;
{
# line 118 "iswr3.py"
    
    INT_type selection;

    int	p0;

    {
# line 124 "iswr3.py"

    switch (parm->construction_tag) {
	case TERM_tag:
	    selection = (INT_type) 2;
	    break;
	case SEQUENCE_tag:
	case AGGREGATE_tag:
	case CHOICE_tag:
	    selection = (INT_type) 1;
	    break;
	default:
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[build_ISWR3_Construction__Expression]: bad tag for construction expression" );
	    dummy = TKERR_EndErrMsg();
	    return( NOTOK );
    }
    }
    switch (p0 = ( selection )) {
        case 1:	/* construction-type */
            {
                if (build_ISWR3_Construction__Type (pe, 0, 0, NULLCP, parm ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "construction-type");
#endif

            }
            break;
        case 2:	/* single-term-construction */
            {
                if (build_ISWR3_Construction__Term (pe, 0, 0, NULLCP, &(parm->construction_value.term) ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "single-term-construction");
#endif

                {	/* single-term-construction TAG PUSHDOWN */
                    PE p1_z;
                    register PE *p1 = &p1_z;

                    if ((*p1 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                        advise (NULLCP, "single-term-construction: out of memory");
                        return NOTOK;
                    }
                    (*p1) -> pe_cons = (*pe);
                    (*pe) = *p1;
                }
            }
            break;

        default:
            advise (NULLCP, "Construction-Expression invalid choice selected: %d",
                    p0);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Construction-Expression");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Construction__Type (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CONSTRUCTION_EXPR_type *  parm;
{
# line 157 "iswr3.py"
    
    INT_type selection;

    int	p2;

    {
# line 163 "iswr3.py"

    switch (parm->construction_tag) {
	case SEQUENCE_tag:
	    selection = (INT_type) 1;
	    break;
	case AGGREGATE_tag:
	    selection = (INT_type) 2;
	    break;
	case CHOICE_tag:
	    selection = (INT_type) 3;
	    break;
    }
    }
    switch (p2 = ( selection )) {
        case 1:	/* sequence-construction */
            {
                if (build_ISWR3_Term__Sequence (pe, 0, 0, NULLCP, parm->construction_value.construction ) == NOTOK)
                    return NOTOK;
                (*pe) -> pe_class = PE_CLASS_CONT;
                (*pe) -> pe_id = 0;

#ifdef DEBUG
                (void) testdebug ((*pe), "sequence-construction");
#endif

            }
            break;
        case 2:	/* aggregate-construction */
            {
                if (build_ISWR3_Term__Sequence (pe, 0, 0, NULLCP, parm->construction_value.construction ) == NOTOK)
                    return NOTOK;
                (*pe) -> pe_class = PE_CLASS_CONT;
                (*pe) -> pe_id = 1;

#ifdef DEBUG
                (void) testdebug ((*pe), "aggregate-construction");
#endif

            }
            break;
        case 3:	/* choice-construction */
            {
                if (build_ISWR3_Term__Sequence (pe, 0, 0, NULLCP, parm->construction_value.construction ) == NOTOK)
                    return NOTOK;
                (*pe) -> pe_class = PE_CLASS_CONT;
                (*pe) -> pe_id = 2;

#ifdef DEBUG
                (void) testdebug ((*pe), "choice-construction");
#endif

            }
            break;

        default:
            advise (NULLCP, "Construction-Type invalid choice selected: %d",
                    p2);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Construction-Type");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Term__Sequence (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
SEQUENCE_CONSTRUCTION_TERM_type  parm;
{
# line 200 "iswr3.py"
    
    INT_type count;

    PE	p3 = NULLPE;
    PE	p4_z = NULLPE;
    register PE *p4 = &p4_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Term-Sequence: out of memory");
        return NOTOK;
    }
    for ( count=0; count<parm->length; count++ ) {
        if (build_ISWR3_Construction__Term (p4, 0, 0, NULLCP, &(parm->sequence_value.construction_terms[count]) ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p4), "element");
#endif

        seq_addon ((*pe), p3, (*p4));
        p3 = (*p4);
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Term-Sequence");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Construction__Term (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CONSTRUCTION_TERM_type *  parm;
{
# line 212 "iswr3.py"
    
    INT_type selection;

    int	p5;

    {
# line 218 "iswr3.py"

    switch (parm->term_tag) {
	case REQ_tag:
	    selection = (INT_type) 1;
	    break;
	case OPT_tag:
	    selection = (INT_type) 2;
	    break;
	case REP_tag:
	    selection = (INT_type) 3;
	    break;
	case OPT_REP_tag:
	    selection = (INT_type) 4;
	    break;
	default:
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[build_ISWR3_Construction__Term]: bad tag for construction term" );
	    dummy = TKERR_EndErrMsg();
	    return( NOTOK );
    }
    }
    switch (p5 = ( selection )) {
        case 1:	/* required-construction-factor */
            {
                if (build_ISWR3_Construction__Factor (pe, 0, 0, NULLCP, &(parm->factor) ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "required-construction-factor");
#endif

                {	/* required-construction-factor TAG PUSHDOWN */
                    PE p6_z;
                    register PE *p6 = &p6_z;

                    if ((*p6 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                        advise (NULLCP, "required-construction-factor: out of memory");
                        return NOTOK;
                    }
                    (*p6) -> pe_cons = (*pe);
                    (*pe) = *p6;
                }
            }
            break;
        case 2:	/* optional-construction-factor */
            {
                if (build_ISWR3_Construction__Factor (pe, 0, 0, NULLCP, &(parm->factor) ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "optional-construction-factor");
#endif

                {	/* optional-construction-factor TAG PUSHDOWN */
                    PE p7_z;
                    register PE *p7 = &p7_z;

                    if ((*p7 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {
                        advise (NULLCP, "optional-construction-factor: out of memory");
                        return NOTOK;
                    }
                    (*p7) -> pe_cons = (*pe);
                    (*pe) = *p7;
                }
            }
            break;
        case 3:	/* repetitive-construction-factor */
            {
                if (build_ISWR3_Construction__Factor (pe, 0, 0, NULLCP, &(parm->factor) ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "repetitive-construction-factor");
#endif

                {	/* repetitive-construction-factor TAG PUSHDOWN */
                    PE p8_z;
                    register PE *p8 = &p8_z;

                    if ((*p8 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 2)) == NULLPE) {
                        advise (NULLCP, "repetitive-construction-factor: out of memory");
                        return NOTOK;
                    }
                    (*p8) -> pe_cons = (*pe);
                    (*pe) = *p8;
                }
            }
            break;
        case 4:	/* optional-repetitive-factor */
            {
                if (build_ISWR3_Construction__Factor (pe, 0, 0, NULLCP, &(parm->factor) ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "optional-repetitive-factor");
#endif

                {	/* optional-repetitive-factor TAG PUSHDOWN */
                    PE p9_z;
                    register PE *p9 = &p9_z;

                    if ((*p9 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 3)) == NULLPE) {
                        advise (NULLCP, "optional-repetitive-factor: out of memory");
                        return NOTOK;
                    }
                    (*p9) -> pe_cons = (*pe);
                    (*pe) = *p9;
                }
            }
            break;

        default:
            advise (NULLCP, "Construction-Term invalid choice selected: %d",
                    p5);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Construction-Term");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Construction__Factor (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
CONSTRUCTION_FACTOR_type *  parm;
{
# line 263 "iswr3.py"
    
    INT_type selection;

    STRING_type ObjectClassIDString;
    CHAR_type *ObjectClassIDChars;

    int	p10;

    {
# line 272 "iswr3.py"

    switch (parm->factor_tag) {
	case OBJECT_CLASS_ID_tag:
	    selection = (INT_type) 1;
	    break;
	case EXPR_tag:
	    selection = (INT_type) 2;
	    break;
	default:
	    dummy = TKERR_StartErrMsg();
	    dummy = TKERR_Format("[build_ISWR3_Construction__Term]: bad tag for construction factor" );
	    dummy = TKERR_EndErrMsg();
	    return( NOTOK );
    }
    }
    switch (p10 = ( selection )) {
        case 1:	/* object-class-identifier */
            {
                {
# line 292 "iswr3.py"

	    if ( GetAttr( parm->factor_value.object_class_id,
			  at_OBJECT_CLASS_IDENTIFIER,
			  (POINTER_type) &ObjectClassIDString,
			  /* default */ BOOL_false,
			  /* mask */ (PARM_MASK_type *) 0
			) == ERROR_INT ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[build_ISWR3_Construction__Factor]: can not get attribute at_OBJECT_CLASS_IDENTIFIER" );
		dummy = TKERR_EndErrMsg();
		return ( NOTOK );
	    }
	    ObjectClassIDChars = String2Chars(ObjectClassIDString);
	    if ( ObjectClassIDChars == ERROR_CHARS ) {
		dummy = TKERR_StartErrMsg();
		dummy = TKERR_Format("[build_ISWR3_Construction__Factor]: can not convert string to object-class-identifier chars" );
		dummy = TKERR_EndErrMsg();
		return( NOTOK );
	    }
	
                }
                if (build_ISWR3_Object__or__Class__Identifier (pe, 0, 0, ObjectClassIDChars , NullParm) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "object-class-identifier");
#endif

            }
            break;
        case 2:	/* construction-expression */
            {
                if (build_ISWR3_Construction__Expression (pe, 0, 0, NULLCP, parm->factor_value.expr ) == NOTOK)
                    return NOTOK;

#ifdef DEBUG
                (void) testdebug ((*pe), "construction-expression");
#endif

            }
            break;

        default:
            advise (NULLCP, "Construction-Factor invalid choice selected: %d",
                    p10);
            return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Construction-Factor");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Object__Id__Expression (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Object-Id-Expression");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Numeric__Expression (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Numeric-Expression");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Binding__Reference (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{
    PE	p11_z = NULLPE;
    register PE *p11 = &p11_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SET)) == NULLPE) {
        advise (NULLCP, "Binding-Reference: out of memory");
        return NOTOK;
    }
    (*p11) = NULLPE;

    {

#ifdef DEBUG
        (void) testdebug ((*p11), "object-reference");
#endif

    }
    if ((*p11) != NULLPE)
        if (set_add ((*pe), (*p11)) == NOTOK) {
            advise (NULLCP, "Binding-Reference bad set: %s",
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p11) = NULLPE;

    {
        if (build_ISWR3_Binding__Name (p11, 0, 0, NULLCP, NullParm) == NOTOK)
            return NOTOK;
        (*p11) -> pe_class = PE_CLASS_UNIV;
        (*p11) -> pe_id = 19;

#ifdef DEBUG
        (void) testdebug ((*p11), "binding-identifier");
#endif

    }
    if ((*p11) != NULLPE)
        if (set_add ((*pe), (*p11)) == NOTOK) {
            advise (NULLCP, "Binding-Reference bad set: %s",
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Binding-Reference");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Binding__Selection__Function (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Binding-Selection-Function");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Current__Instance__Function (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{
    PE	p12_z = NULLPE;
    register PE *p12 = &p12_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "Current-Instance-Function: out of memory");
        return NOTOK;
    }
    (*p12) = NULLPE;

    {	/* first-parameter */

#ifdef DEBUG
        (void) testdebug ((*p12), "first-parameter");
#endif

    }

    if ((*p12) != NULLPE)
        if (seq_add ((*pe), (*p12), -1) == NOTOK) {
            advise (NULLCP, "Current-Instance-Function bad sequence: %s",
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p12) = NULLPE;

    {	/* second-parameter */

#ifdef DEBUG
        (void) testdebug ((*p12), "second-parameter");
#endif

    }

    if ((*p12) != NULLPE)
        if (seq_add ((*pe), (*p12), -1) == NOTOK) {
            advise (NULLCP, "Current-Instance-Function bad sequence: %s",
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Current-Instance-Function");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_String__Expression (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{
    PE	p13 = NULLPE;
    PE	p14_z = NULLPE;
    register PE *p14 = &p14_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, PE_CONS_SEQ)) == NULLPE) {
        advise (NULLCP, "String-Expression: out of memory");
        return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.String-Expression");
#endif


    return OK;
}

/* ARGSUSED */

int	build_ISWR3_Atomic__String__Expression (pe, explicit, len, buffer, parm)
PE     *pe;
int	explicit;
int	len;
char   *buffer;
PEPYPARM parm;
{

#ifdef DEBUG
    (void) testdebug ((*pe), "ISWR3.Atomic-String-Expression");
#endif


    return OK;
}
