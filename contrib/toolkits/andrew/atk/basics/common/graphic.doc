\begindata{text,270048644}
\textdsversion{12}
\template{be2guide}
\define{bold
menu:[Font~1,Bold~10]
attr:[FontFace Bold Int Set]}
\define{section
menu:[Title~3,Section~21]
attr:[Justification LeftJustified Point 0]
attr:[Flags KeepPriorNL Int Set]
attr:[Flags KeepNextNL Int Set]
attr:[FontFace Bold Int Set]
attr:[FontFamily AndySans Int 0]
attr:[FontSize ConstantFontSize Point 14]}
\define{underline
menu:[Font~1,Underline~41]
attr:[Flags Underline Int Set]}
\define{index
menu:[Title,Index~91]
attr:[FontFace Italic Int Set]}
\define{indexi
menu:[Title,InvisibleIndex~92]
attr:[Script PreviousScriptMovement Point -2]
attr:[Flags Hidden Int Set]
attr:[FontFace Italic Int Set]}
\define{itemize
}
\define{fixedtext
menu:[Region~4,Fixedtext]
attr:[Justification LeftJustified Point 0]
attr:[FontFace FixedFace Int Set]
attr:[FontFamily AndyType Int 0]
attr:[FontSize ConstantFontSize Point 10]}
\define{fixedindent
menu:[Region~4,Fixedindent]
attr:[LeftMargin LeftMargin Cm 83230]
attr:[Justification LeftJustified Point 0]
attr:[FontFace FixedFace Int Set]
attr:[FontFamily AndyType Int 0]
attr:[FontSize ConstantFontSize Point 10]}
\define{paramname
menu:[Font~1,Paramname]
attr:[FontFace Italic Int Set]}
\formatnote{\chapter{Graphic}}\indexi{Graphic}


You should use instances of the class \italic{graphic} to do output to 
workstation displays.  For example, to draw text and put box around it, you 
would make calls to the methods and class procedures provided by the class 
\italic{graphic}.  The class graphic provides methods for drawing lines, 
shapes, and text.  It also provides methods for transferring entire blocks of 
bits. 


The class \italic{graphic} provides an output interface to hardware-dependent 
window management systems.  As an application programmer, you should 
understand why application programs should not display their pictures directly 
to an underlying window management system:  application programs must often be 
ported to other workstations that will eventually be deployed.  The 
workstations often have similar, but not identical display capabilities and 
the hardware can be significantly different; the underlying window manager may 
be different.  To insure portability of your application, you should never 
make direct calls to an underlying window management system; you should always 
use the \italic{graphic} class procedures and methods;  doing so will maximize 
the device independence and portabilty of your application program. 


Other Andrew Toolkit classes use the class \italic{graphic} to do output, and 
if you use them, you will be using \italic{graphic} indirectly to do your 
output.  For example, if your application uses the \italic{textview/text} 
classes, then your application will also be using graphic to do text 
output--only indirectly. 



\section{Quick reference list for Graphic}



\fixedtext{void \bold{graphic_}BitBltSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{srcX}, long \paramname{srcY}, long 
\paramname{dstX}, long \paramname{dstY}, long \paramname{Width}, long 
\paramname{Height}, struct graphic *\paramname{DstGraphic}, long 
\paramname{clipX}, long \paramname{clipY}, long \paramname{clipWidth}, long 
\paramname{clipHeight});} 

\fixedtext{void \bold{graphic_}BitBlt }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{SrcRect}, struct graphic 
*\paramname{DestGraphic}, struct point *\paramname{DstOrigin}, struct 
rectangle *\paramname{ClipRectList});} 

\fixedtext{struct graphic *\bold{graphic_}BlackPattern }\fixedindent{(struct 
graphic *\paramname{graphic});} 

\fixedtext{void \bold{graphic_}ClearClippingRect }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{struct graphic *\bold{graphic_}ColorPattern }\fixedindent{(struct 
graphic *\paramname{graphic}, long \paramname{red}, long \paramname{blue}, 
long \paramname{green});} 

\fixedtext{struct graphic *\bold{graphic_}CreateGraphic }\fixedindent{();} 

\fixedtext{void \bold{graphic_}DrawArcSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, short \paramname{StartAngle}, 
short \paramname{OffsetAngle});} 

\fixedtext{void \bold{graphic_}DrawArc }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{EnclRect}, short 
\paramname{StartAngle}, short \paramname{OffsetAngle});} 

\fixedtext{void \bold{graphic_}DrawLineToPt }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{LineEnd});} 

\fixedtext{void \bold{graphic_}DrawLineTo }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{XEnd}, long \paramname{YEnd});} 

\fixedtext{void \bold{graphic_}DrawLine }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{DeltaX}, long \paramname{DeltaY});} 

\fixedtext{void \bold{graphic_}DrawOvalSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height});} 

\fixedtext{void \bold{graphic_}DrawOval }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect});} 

\fixedtext{void \bold{graphic_}DrawPath }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{PointArray}, short 
\paramname{PointCount});} 

\fixedtext{void \bold{graphic_}DrawPolygon }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{PointArray}, short 
\paramname{PointCount});} 

\fixedtext{void \bold{graphic_}DrawRectSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height});} 

\fixedtext{void \bold{graphic_}DrawRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect});} 

\fixedtext{void \bold{graphic_}DrawRgn }\fixedindent{(struct graphic 
*\paramname{graphic}, struct region *\paramname{Rgn});} 

\fixedtext{void \bold{graphic_}DrawRRectSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, long \paramname{cornerWidth}, long 
\paramname{cornerHeight});} 

\fixedtext{void \bold{graphic_}DrawRRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{OuterBox}, struct rectangle 
*\paramname{InnerBox});} 

\fixedtext{void \bold{graphic_}DrawString }\fixedindent{(struct graphic 
*\paramname{graphic}, char *\paramname{Text}, short \paramname{Operation});} 

\fixedtext{void \bold{graphic_}DrawText }\fixedindent{(struct graphic 
*\paramname{graphic}, char *\paramname{Text}, long \paramname{TextLength}, 
short \paramname{Operation});} 

\fixedtext{void \bold{graphic_}DrawTrapezoid }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{topX}, long \paramname{topY}, long 
\paramname{topWidth}, long \paramname{bottomX}, long \paramname{bottomY}, long 
\paramname{bottomWidth});} 

\fixedtext{void \bold{graphic_}EraseRectSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height});} 

\fixedtext{void \bold{graphic_}EraseRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect});} 

\fixedtext{void \bold{graphic_}EraseVisualRect }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{void \bold{graphic_}FillArcSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, short \paramname{StartAngle}, 
short \paramname{OffsetAngle}, struct graphic *\paramname{Tile});} 

\fixedtext{void \bold{graphic_}FillArc }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{EnclRect}, short 
\paramname{StartAngle}, short \paramname{OffsetAngle}, struct graphic 
*\paramname{Tile});} 

\fixedtext{void \bold{graphic_}FillOvalSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, struct graphic *\paramname{Tile});} 




\fixedtext{void \bold{graphic_}FillOval }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect}, struct graphic 
*\paramname{Tile});} 

\fixedtext{void \bold{graphic_}FillPolygon }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{PointArray}, short 
\paramname{PointCount}, struct graphic *\paramname{Tile});} 

\fixedtext{void \bold{graphic_}FillRectSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, struct graphic *\paramname{Tile});} 



\fixedtext{void \bold{graphic_}FillRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect}, struct graphic 
*\paramname{Tile});} 

\fixedtext{void \bold{graphic_}FillRgn }\fixedindent{(struct graphic 
*\paramname{graphic}, struct region *\paramname{Rgn}, struct graphic 
*\paramname{Tile});} 

\fixedtext{void \bold{graphic_}FillRRectSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, long \paramname{cornerWidth}, long 
\paramname{cornerHeight}, struct graphic *\paramname{Tile});} 

\fixedtext{void \bold{graphic_}FillRRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{OuterBox}, struct rectangle 
*\paramname{InnerBox}, struct graphic *\paramname{Tile});} 

\fixedtext{void \bold{graphic_}FillTrapezoid }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{topX}, long \paramname{topY}, long 
\paramname{topWidth}, long \paramname{bottomX}, long \paramname{bottomY}, long 
\paramname{bottomWidth}, struct graphic *\paramname{Tile});} 

\fixedtext{void \bold{graphic_}FinalizeObject }\fixedindent{(struct graphic 
*\paramname{self});} 

\fixedtext{void \bold{graphic_}FlushGraphics }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{void \bold{graphic_}GetBackgroundColor }\fixedindent{(struct 
graphic *\paramname{graphic}, long *\paramname{red}, long *\paramname{blue}, 
long *\paramname{green});} 

\fixedtext{void \bold{graphic_}GetClippingRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect});} 

\fixedtext{void \bold{graphic_}GetCurrentPt }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{Pt});} 

\fixedtext{void \bold{graphic_}GetDefaultColors }\fixedindent{(char 
**\paramname{foreground}, char **\paramname{background});} 

\fixedtext{long \bold{graphic_}GetDevice }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{long \bold{graphic_}GetEnclosedBottom }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{void \bold{graphic_}GetEnclosedBounds }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect});} 

\fixedtext{\bold{graphic_}GetEnclosedHeight }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{\bold{graphic_}GetEnclosedLeft }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{long \bold{graphic_}GetEnclosedRight }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{\bold{graphic_}GetEnclosedTop }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{\bold{graphic_}GetEnclosedWidth }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{struct fontdesc *\bold{graphic_}GetFont }\fixedindent{(struct 
graphic *\paramname{graphic});} 

\fixedtext{void \bold{graphic_}GetForegroundColor }\fixedindent{(struct 
graphic *\paramname{graphic}, long *\paramname{red}, long *\paramname{blue}, 
long *\paramname{green});} 

\fixedtext{long \bold{graphic_}GetHorizontalResolution }\fixedindent{(struct 
graphic *\paramname{graphic});} \fixedtext{short \bold{graphic_}GetLineWidth 
}\fixedindent{(struct graphic *\paramname{graphic});} 

\fixedtext{long \bold{graphic_}GetLogicalBottom }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{void \bold{graphic_}GetLogicalBounds }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect});} 

\fixedtext{\bold{graphic_}GetLogicalHeight }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{\bold{graphic_}GetLogicalLeft }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{long \bold{graphic_}GetLogicalRight }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{\bold{graphic_}GetLogicalTop }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{\bold{graphic_}GetLogicalWidth }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{short \bold{graphic_}GetSpaceShim }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{short \bold{graphic_}GetTransferMode }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{long \bold{graphic_}GetVerticalResolution }\fixedindent{(struct 
graphic *\paramname{graphic});} 

\fixedtext{long \bold{graphic_}GetVisualBottom }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{void \bold{graphic_}GetVisualBounds }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect});} 

\fixedtext{\bold{graphic_}GetVisualHeight }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{\bold{graphic_}GetVisualLeft }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{long \bold{graphic_}GetVisualRight }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{\bold{graphic_}GetVisualTop }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{\bold{graphic_}GetVisualWidth }\fixedindent{(struct graphic 
*\paramname{graphic});} 

\fixedtext{char *\bold{graphic_}GetWindowManagerType }\fixedindent{(struct 
graphic *\paramname{graphic});} 

\fixedtext{struct graphic *\bold{graphic_}GrayPattern }\fixedindent{(struct 
graphic *\paramname{graphic}, short \paramname{IntensityNum}, 
\paramname{IntensityDenom});} 

\fixedtext{boolean \bold{graphic_}InitializeObject }\fixedindent{(struct 
graphic *\paramname{self});} 

\fixedtext{void \bold{graphic_}InsertGraphicSize }\fixedindent{(struct graphic 
*\paramname{graphic}, struct graphic *\paramname{EnclosingGraphic}, long 
\paramname{xOriginInParent}, long \paramname{yOriginInParent}, long 
\paramname{width}, long \paramname{height});} 

\fixedtext{void \bold{graphic_}InsertGraphic }\fixedindent{(struct graphic 
*\paramname{graphic}, struct graphic *\paramname{EnclosingGraphic}, struct 
rectangle *\paramname{EnclosedRectangle});} 

\fixedtext{void \bold{graphic_}MoveLogicalOrigin }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{DeltaX}, long \paramname{DeltaY});} 

\fixedtext{void \bold{graphic_}MoveToPt }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{Pt});} 

\fixedtext{void \bold{graphic_}MoveTo }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{NewX}, long \paramname{NewY});} 

\fixedtext{void \bold{graphic_}Move }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{DeltaX}, long \paramname{DeltaY});} 

\fixedtext{void \bold{graphic_}ReadPixImage }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{SrcX}, long \paramname{SrcY}, struct 
pixelimage *\paramname{DestPixels}, long \paramname{DestX}, long 
\paramname{DestY}, long \paramname{width}, long \paramname{height});} 

\fixedtext{void \bold{graphic_}RestoreGraphicsState }\fixedindent{(struct 
graphic *\paramname{graphic});} 

\fixedtext{void \bold{graphic_}SetBackgroundColor }\fixedindent{(struct 
graphic *\paramname{graphic}, char *\paramname{colorName}, long 
\paramname{red}, long \paramname{blue}, long \paramname{green});} 

\fixedtext{void \bold{graphic_}SetBitAtLoc }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{XPos}, long \paramname{YPos}, boolean 
\paramname{NewValue});} 

\fixedtext{void \bold{graphic_}SetClippingRectSize }\fixedindent{(struct 
graphic *\paramname{graphic}, long \paramname{x}, \paramname{y}, 
\paramname{w}, \paramname{h});} 

\fixedtext{void \bold{graphic_}SetClippingRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{AdditionalRect});} 

\fixedtext{void \bold{graphic_}SetDefaultColors }\fixedindent{(char 
*\paramname{foreground}, char *\paramname{background});} 

\fixedtext{void \bold{graphic_}SetFont }\fixedindent{(struct graphic 
*\paramname{graphic}, struct fontdesc *\paramname{ChosenFont});} 

\fixedtext{void \bold{graphic_}SetForegroundColor }\fixedindent{(struct 
graphic *\paramname{graphic}, char *\paramname{colorName}, long 
\paramname{red}, long \paramname{blue}, long \paramname{green});} 

\fixedtext{void \bold{graphic_}SetLineWidth }\fixedindent{(struct graphic 
*\paramname{graphic}, short \paramname{NewLineWidth});} 

\fixedtext{void \bold{graphic_}SetLogicalOriginPt }\fixedindent{(struct 
graphic *\paramname{graphic}, struct point *\paramname{Pt});} 

\fixedtext{void \bold{graphic_}SetLogicalOrigin }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{NewX}, long \paramname{NewY});} 

\fixedtext{void \bold{graphic_}SetSpaceShim }\fixedindent{(struct graphic 
*\paramname{graphic}, short \paramname{Amount});} 

\fixedtext{void \bold{graphic_}SetTransferMode }\fixedindent{(struct graphic 
*\paramname{graphic}, short \paramname{NewTransferMode});} 

\fixedtext{struct graphic *\bold{graphic_}WhitePattern }\fixedindent{(struct 
graphic *\paramname{graphic});} \fixedtext{void \bold{graphic_}WritePixImage 
}\fixedindent{(struct graphic *\paramname{graphic}, long \paramname{DestX}, 
long \paramname{DestY}, struct pixelimage *\paramname{SrcPixels}, long 
\paramname{SrcX}, long \paramname{SrcY}, long \paramname{width}, long 
\paramname{height});} 



\section{Overview of Graphic}


\subsection{A pixel map} \indexi{Pixel map} \indexi{Graphic++Pixel map}


The class \italic{graphic} provides a \italic{pixmap}, that is, a pixel map. 
 A pixel map is a \italic{rectangle} of bits together with a mapping function 
that maps the bits to picture elements, or pixels, on the workstation display. 
 The rectangle of bits provides graphic storage.  When an image is displayed, 
each bit in the rectangle is mapped to a corresponding pixel on the 
workstation display.  The value of each bit together with a transfer mode 
(explained below), determines how the bit's corresponding picture element is 
illuminated. 


The pixel map is associated with a \italic{graphic} object in one of two ways. 
 First,  the \italic{Interaction Manager} explicitly links its \italic{graphic} 
object, a \italic{window,} to a \italic{pixmap} when you set the 
\italic{Interaction Manager}'s view.   Second, the \italic{pixmap} is linked 
implicitly and relative to the parent when you insert a graphic object into 
its parent by calling \italic{graphic_InsertGraphic} before beginning to draw 
when setting up view hierarchies. You must use one of these methods to 
associate a newly created \italic{graphic} object with its pixel map. 


The class \italic{pixmap} manages any mapping that may be necessary from the 
graphic's coordinate system to the underlying window manager's coordinate 
system. The applications programmer should not need to use any of the methods 
or class procedures in pixmap. 


\begindata{bp,270045832}
\enddata{bp,270045832}
\view{bpv,270045832,150,0,0}
\subsection{The logical rectangle}  \indexi{Logical rectangle} 
\indexi{Rectangle++Logical}

\indexi{Graphic++Logical rectangle}


The class \italic{graphic} supplies a logical rectangle which defines a 
coordinate system.   The units are pixels.  The coordinates of the logical 
rectangle are initially given by (0,0) at the origin on the rectangle's top 
left to  2\superscript{32} - 1, 2\superscript{32}-1) at its bottom right.  You 
can draw anywhere in this logical unsigned 32-bit coordinate space. 


You can also move the logical origin from (0,0) to another point.  There are 
methods for getting the dimensions of the logical rectangle. 


\subsection{The visual rectangle} \indexi{Visual rectangle}

\indexi{Rectangle++Visual} 

\indexi{Graphic++Visual rectangle}The logical rectangle, \italic{lr}, gives 
the coordinates that you can scale your drawing to.  The class \italic{graphic} 
also provides a visual rectangle, \italic{vr},  that gives the coordinates for 
what is potentially visible in the window.  To understand \italic{lr} and 
\italic{vr}, suppose that a multi-media editor were displaying some text and a 
drawing,  and that the drawing happens to be at the very bottom of the window. 
 If the graphic's rectangle, \italic{lr}, falls outside the window boundary, 
and the drawing is relative to \italic{lr}, then the drawing will be clipped 
to the graphic's visual rectangle. 


The part of the drawing that falls within the coordinates given by the visual 
rectangle normally corresponds to what the user sees on the screen, except if 
another drawing were laid over the first (e.g., a message box could be 
temporarily laid on top of all or part of the drawing). 


You must attend to the visual rectangle if you wish to: 


\itemize{Scale the size of your drawing to the size of its visual region.  In 
this case, you would do your drawing relative to the visual rectangle rather 
than the rectangle. 


Produce a clipped drawing with maximum efficiency.  In this case, you would 
scale your drawing relative to \italic{lr}, but you would not actually draw 
except when the coordinates fell within \italic{vr}. 

}

Otherwise you can ignore \italic{vr} and simply draw within the dimensions 
given by \italic{lr}.  If you do, your drawing will automatically be clipped 
to \italic{vr}. 


\subsection{The enclosed rectangle}

\indexi{Rectangle++Enclosed} \indexi{Enclosed rectangle}

\indexi{Graphic++Enclosed rectangle}Finally, graphic supplies an enclosed 
rectangle.  The enclosed rectangle is the same as the logical rectangle, 
except that the coordinates are expressed in terms of the parent graphic's 
logical coordinate system.  The enclosed coordinate system is undefined if the 
graphic has not been inserted in a parent graphic or the Interaction Manager's 
view. 


When you draw your image, you do not have to pay attention to your object's 
enclosed rectangle coordinate system.  Its values are updated automatically 
when you insert the graphic inside its parent.  The values do not change 
unless the object changes position on the screen or the parent's logical 
origin changes, but to change the position of an object on the screen, you 
must reinsert the object inside its parent. 


If your object has children, then you may be interested in their enclosed 
rectangle coordinates.  The class graphic provides a method for getting their 
values. 


\subsection{The local graphic state} \indexi{Graphic++Local state}


Each instance of a graphic has the following elements in its graphic state: 


\description{Current point\formatnote{  --  }The point from which all line and 
text drawing will be done.  It is initialized to (0,0). 


Line width\formatnote{  --  }The line width determines the width, in pixels, 
of drawn lines. It is initialized to one pixel. 


Current font\formatnote{  --  }The current font determines the font drawing 
text. The initial value of the font is Andysans 12. 


Space shim \formatnote{  --  }The space shim controls the amount of space that 
will be added to the right of space characters.  It is initialized to 0 
pixels. 


Transfer mode \formatnote{  --  }The transfer mode determines how bits will be 
turned on and off on the screen when drawing lines, writing text, transferring 
blocks of bits or filling figures.  It is initialized to 
\smaller{graphic_COPY}. 


Clipping rectangle \formatnote{  --  }The clipping rectangle allows you to use 
drawing methods more efficiently.  It is initially \smaller{NULL}, that is, 
the drawing methods do no clipping. 

}

The class graphic provides methods for setting these state variables and 
accessing their values.  The values are local to the graphic object. 


\subsection{The global graphic state} \indexi{Graphic++Global state}


The underlying window management system maintains a global graphics state. 
 The values of the global state determine actual output.  The values of your 
object's graphic state remain local to the object until the object requests 
that its graphics state be restored to the global state.  The request sets the 
global graphic state to your object's local graphic state. 


\subsection{Protocols} \indexi{Graphic++Protocols}


\paragraph{Initialization}  \indexi{Graphic++Initializing}


If you are creating a subclass of the class \italic{graphic} and want to 
override the default initial values for the \italic{graphic} state, then you 
should initialize the graphic state in the \italic{InitializeObject} 
procedure. 

\begindata{bp,269987448}
\enddata{bp,269987448}
\view{bpv,269987448,151,0,0}
\paragraph{Before drawing}  \indexi{Graphic++Drawing}


If you create an object that is an instance of any subclass of 
\italic{graphic,} then it will inherit the graphic data structures and methods 
and you will be able to draw on the screen.  Before doing any drawing, 
however, you must do one of the following: 


\leftindent{a) Call \italic{im_SetView} \indexi{ \italic{im_SetView}}

 to insert the object into the the \italic{Interaction Manager}'s window (see 
\bold{Interaction Manager}), or


(b) call \italic{graphic_InsertGraphic}

\indexi{ \italic{graphic_InsertGraphic}} 

to insert the object into its parent's graphic (see \bold{View}). 

}

If you fail to insert the object, the mapping from the logical coordinate 
system to the underlying window management system will be undefined. 


The graphic object does not store any drawing that you may do, so it is not 
useful to draw in a graphic that is not inserted. 


\paragraph{Setting the global graphic state} \indexi{Graphic++Global state}


Since other objects will also potentially be setting the global graphic state, 
you must restore your objects's graphic state any time another object may have 
had an opportunity to set the global graphic state since the last time you 
did.  The restore will set the global graphic state to your local graphic 
state. 


\paragraph{Redraw requests} \indexi{Graphic++Redraw requests}


Normally, you will not use graphics directly but will work with view, a 
subclass of graphics that provides methods for input, including redrawing 
requests (see section \bold{View}). 


\begindata{bp,269771680}
\enddata{bp,269771680}
\view{bpv,269771680,152,0,0}
\subsection{Creating and initializing graphics} \paragraph{Creating an 
instance of a graphic} \indexi{Graphic++Creating}

\indexi{ \italic{graphic_CreateGraphic}}

\example{struct graphic *graphic_CreateGraphic() 

}
\leftindent{\bold{Class procedure description.}  Creates an instance of the 
class \italic{graphic} and initializes it. 

}

\paragraph{Inserting a graphic} \indexi{Graphic++Inserting}


\example{void graphic_InsertGraphic(EnclosedGraphic, EnclosingGraphic, 
EnclosedRectangle) 

struct graphic *EnclosedGraphic;  

struct graphic *EnclosingGraphic;  

struct rectangle *EnclosedRectangle;} 


\leftindent{\bold{Method description.  }\italic{graphic_InsertGraphic} inserts 
the graphic \italic{EnclosedGraphic} into \italic{EnclosingGraphic}. 


\bold{Side effects.}  \italic{EnclosedGraphic'}s logical, visual, and enclosed 
rectangles are set to the values provided by \italic{EnclosedRectangle}.  The 
enclosed graphic clipping rectangle is set to \smaller{NULL}. 


\bold{Usage.}  When you create a new graphic object, you should insert it into 
its parent's graphic.  To move a graphic object, you must reinsert it. 

}

\paragraph{Restoring the graphic state} \indexi{Graphic++Restoring state}

\indexi{ \italic{graphic_RestoreGraphicsState}}

\example{void graphic_RestoreGraphicsState(grphc) 

struct graphic *grphc;} 


\leftindent{\bold{Method description. } \italic{graphic_RestoreGraphicsState} 
sets the global graphic state variables to the values of  \italic{grphc}'s 
global state variables.  The state variables include the line width for 
drawing lines, the font for drawing text, the clipping rectangle, the current 
point for drawing lines and text, the  space shims, and for drawing. 


\bold{Usage.}  Before drawing, you should call 
\italic{graphic_RestoreGraphicsState} in order to set the global graphic state 
variables.  Since other objects will also potentially be setting the global 
graphic state, you must restore your objects's graphic state any time another 
object may have had an opportunity to set the global graphic state since the 
last time you did.  The restore will set the global graphic state to your 
local graphic state. 

}
\begindata{bp,269759300}
\enddata{bp,269759300}
\view{bpv,269759300,153,0,0}
\subsection{The current point} \indexi{Graphic++Current point}


Many drawing methods use a \italic{current point} as a reference point. For 
example, lines are drawn from the \italic{current point} to one of the 
following: 

\itemize{
a point relative to (0,0) in the logical rectangle \indexi{Logical rectangle}


an (x,y) coordinate relative to (0,0) in the logical rectangle


a coordinate relative to the current point}


The \italic{current point} is defined after line-drawing methods, but is 
undefined after all other drawing methods and after a window changes size. 


For efficiency reasons, a \italic{point} is not an object. \indexi{Point} To 
use points, you must \italic{#include point.h} from the Andrew Toolkit 
library.  A point can be thought of as an (x,y) coordinate. 
\indexi{Coordinates}



\paragraph{Moving the current point to a new point} \indexi{Graphic++Moving}

\indexi{ \italic{graphic_MoveToPt}}

\example{void graphic_MoveToPt(grphc,NewPosition) 

struct graphic *grphc;  

struct point *NewPosition;} 


\leftindent{\bold{Method description.  }\italic{graphic_MoveToPt}  sets the 
\italic{current point} to the point, \italic{NewPosition}. 


\bold{Example.} 


\example{#include "point.h"


struct point *pt;  struct graphic *go;   /* a graphic object */


go = graphic_New ():  \bold{...}  \description{pt = 
point_CreatePoint(graphic_GetVisualLeft (go), graphic_GetVisualTop(go);} 
 graphic_MoveToPt (grphc, pt); 

}

The call to \italic{point_CreatePoint} assigns \italic{pt} to the graphic 
object's visual origin.  Then the call to \italic{graphic_MoveToPt} sets the 
current point to \italic{pt}. 

}\
\begindata{bp,270325268}
\enddata{bp,270325268}
\view{bpv,270325268,154,0,0}
\paragraph{Moving the current point to a new (x,y) coordinate} 
\indexi{Graphic++Moving}

\indexi{ \italic{graphic_MoveTo}}

\example{void graphic_MoveTo(grphc, NewX, NewY) 

struct graphic *grphc;  

long NewY;  

long NewX;} 


\leftindent{\bold{Method description.  }\italic{graphic_MoveTo} moves the 
\italic{current point} to \italic{(NewX, Newy) }where the 32-bit integer 
\italic{NewX} is the horizontal coordinate and \italic{NewY} the vertical. 


}
\paragraph{Moving the current point relative to the current point} 
\indexi{Graphic++Moving}

\indexi{ \italic{graphic_Move}}

\example{void graphic_Move(grphc, DeltaX, DeltaY) 

struct graphic *grphc;  

long DeltaX;  long DeltaY;} 


\leftindent{\bold{Method description.}   \italic{graphic_Move} moves the 
\italic{current point} to \italic{(current x + DeltaX, current y + DeltaY)} 
where the 32-bit integer \italic{DeltaX} is the horizontal distance from the 
current point to the desired point, \italic{DeltaY} the vertical distance. 


\bold{Example.} 

\example{
struct graphic *go;   /* a graphic object */


go = graphic_New (); 


\bold{...} 


graphic_MoveTo (grphc, 20,30);  

graphic_Move (grphc, 5, 10);} 


\italic{graphic_MoveTo (grphc, 20, 30)} moves the current point to the logical 
coordinate (20,30).  Then \italic{graphic_Move (grphc, 5, 10)} moves the 
current point to (20+5, 30+10), that is, (25,40). 

}



\paragraph{Getting the current point location} \indexi{Graphic++Getting 
location}

\indexi{ \italic{graphic_GetCurrent}}

\example{void graphic_GetCurrentPt(grphc, Pt) 

struct graphic *grphc;  

struct point *Pt;} 


\leftindent{\bold{Method description.  }\italic{graphic_GetCurrentPt}  gets 
the current point location. 


\bold{Example.} 


\example{#include "point.h"


struct point *pt;  

struct graphic *go;   /* a graphic object */


go = graphic_New ();  


\bold{...}  


graphic_MoveToPt (grphc, 20,30);  graphic_GetCurrentPt (grphc, &pt); 

}

The call to \italic{point_CreatePoint} assigns \italic{pt} to the graphic 
object's visual origin.  Then the call to \italic{graphic_MoveToPt} sets the 
current point to \italic{pt}. 

}

\begindata{bp,270000728}
\enddata{bp,270000728}
\view{bpv,270000728,155,0,0}
\subsection{Drawing Lines}


Lines are drawn with black "points" using the current transfer mode and line 
width. 


\paragraph{Drawing a line from the current point to another point} 
\indexi{Graphic++Drawing lines} \indexi{ \italic{graphic_DrawLineToPt}}

\example{void graphic_DrawLineToPt(grphc,LineEnd) 

struct graphic *grphc;  

struct point *LineEnd;} 


\leftindent{\bold{Method description.  }\italic{graphic_DrawLineToPt} draws a 
line from the current point to the point \italic{LineEnd}.   The width of the 
line is determined by the graphic state \italic{LineWidth}; the default width 
is one pixel. 


\bold{Side effect.}  The current point is moved to \italic{LineEnd}. 


}
\paragraph{Drawing a line from the current point to a  (x,y) coordinate} 
\indexi{Graphic++Drawing lines}

\indexi{ \italic{graphic_DrawLineTo}}

\example{void graphic_DrawLineTo(grphc, XEnd, YEnd) 

struct graphic *grphc;  

long YEnd;  

long XEnd;} 


\leftindent{\bold{Method description.  }\italic{graphic_DrawLineTo} draws a 
line from the current point to the coordinate (XEnd, YEnd).  The width of the 
line is determined by the graphic state \italic{LineWidth}; the default width 
is one pixel. 


\bold{Side effect.}  Moves the current point to (\italic{XEnd, YEnd}). 

}


\paragraph{Drawing a line from the current point to a coordinate relative to 
the current point}

\indexi{Graphic++Drawing lines} 

\indexi{ \italic{graphic_DrawLine}}

\example{void graphic_DrawLine(grphc, DeltaX, DeltaY) 

struct graphic *grphc;  

long DeltaY;  

long DeltaX;} 


\leftindent{\bold{Method description.  }\italic{ graphic_DrawLine} draws a 
line from the current point (CurrentX, CurrentY) to the coordinate 
(CurrentX+\italic{DeltaX}, CurrentY+\italic{DeltaY}).  The width of the line 
is determined by the graphic state \italic{LineWidth};  the default width is 
one pixel. 


\bold{Side effect.}  Moves the current point to (CurrentX+\italic{DeltaX}, 
CurrentY+\italic{DeltaY}). 

}
\begindata{bp,268762084}
\enddata{bp,268762084}
\view{bpv,268762084,156,0,0}
\subsection{The current line width}


The graphic state variable, \italic{Line Width}, controls the width of drawn 
lines.  Its default value is one pixel wide.  There is method for setting the 
\italic{Line Width} and for getting its current value. 


\paragraph{Setting the line width}\italic{\index{graphic_SetLineWidth}}


\example{void graphic_SetLineWidth(grphc,NewLineWidth)  \indexi{Graphic++Set 
line width}

struct graphic *grphc;  

short NewLineWidth;}  \indexi{ }

\leftindent{\bold{Method description.}   \italic{graphic_SetLineWidth} sets 
the line width to NewLineWidth.  The unit is pixels and the value can range 
from 0 pixels to 2\formatnote{@+}[8}-1.  Other values are undefined. 


\paragraph{Getting the line width} \indexi{Graphic++Get line width}

\indexi{ \italic{graphic_GetLineWidth}}

\example{short graphic_GetLineWidth(grphc) 

struct graphic *grphc;} 


\leftindent{\bold{Method description.}  \italic{graphic_GetLineWidth} returns 
the current line width, which can range from 0 to 28-1 pixels.  The default 
value for the line width is one pixel. 


\bold{Example.} 


\example{short CLineWidth;  

struct graphic *grphc; 


grphc = graphic_New ();


... 


CLineWidth = graphic_GetLineWidth(grphc);

graphic_SetLineWidth (CLineWidth+CLineWidth); 

}
\italic{CLineWidth = graphic_GetLineWidth} stores the current line width in 
the short variable \italic{CLineWidth}; then \italic{graphic_SetLineWidth 
(CLineWidth+CLineWidth)} doubles the current line width. 

}
\begindata{bp,270145588}
\enddata{bp,270145588}
\view{bpv,270145588,157,0,0}
\subsection{The current font} \indexi{Graphic++Fonts}


Text output appears in the currently selected font.  Fonts are named by 
strings,  for example "Andy12i" (Andy,12-point, italic) or "Andysans14b" 
(Andysans, 14-point,  bold).  You can find out what fonts are available by 
using \italic{ls} to examine the contents of the directory 
/usr/andrewX11/fonts.  If you want your program to be portable to other Andrew 
environments, you should use the \italic{andy}, \italic{andysans}, 
\italic{andytype} font families.  To see what a specific font looks like, use 
the X program \bold{xfd} (see the online help). 



When you request a font, the Andrew Toolkit returns a handle representing its 
best effort at supplying the font you specify.  The values of a font may 
change at redraw time  because a user with multiple displays might move an 
existing window to a display with different hardware characteristics.  So if 
your program examines font structures, you must reassign values when a redraw 
is requested. 



\paragraph{Setting the current font} \indexi{Graphic++Set font}

\indexi{ \italic{graphic_SetFont}}

\example{void graphic_SetFont(grphc, ChosenFont) 

struct graphic *grphc;  

struct fontdesc *ChosenFont;} 


\leftindent{
\bold{Method description.  }\italic{graphic_SetFont} sets the current font for 
the graphic object \italic{grphc} to the font descriptor \italic{ChosenFont.} 
  The default current font is \italic{AndySans12}


\bold{Usage.}  You must call \italic{fontdesc_Create} to get a pointer to a 
font descriptor (see the chapter, Font Descriptors), then call 
\italic{graphic_SetFont} to set the graphic object's current font to the font 
descriptor. 


\bold{Example.} 


\example{struct graphic *grphc; 


grphc = graphic_New(); 


\bold{...} 


graphic_SetFont (grphc, fontdesc_Create ("andysans", fontdesc_PLAIN, 12));} 


sets the graphic object \italic{grphc}'s current font to \italic{Andysans12}. 

}



\paragraph{Getting the current font} \indexi{Graphic++Get font}

\indexi{ \italic{graphic_GetFont}}

\example{struct fontdesc *graphic_GetFont(grphc) 

struct graphic *grphc;} 


\leftindent{\bold{Method description.}   \italic{graphic_GetFont} returns 
\italic{grphc}'s current font. 

}


\begindata{bp,269945448}
\enddata{bp,269945448}
\view{bpv,269945448,158,0,0}
\subsection{Drawing Text} \indexi{Graphic++Text}


\paragraph{Drawing a string} \indexi{Graphic++Draw text string}

\indexi{ \italic{graphic_DrawString}}

\example{void graphic_DrawString(grphc, String, Operation) 

struct graphic *grphc;  

char *String;  

long Operation;} 


\leftindent{
\bold{Method description.}  Text is drawn by "spraying" black through a 
character stencil and combining it with the pixels on the screen using the 
current transfer function. \italic{graphic_DrawString} draws the string 
\italic{String} in the \italic{grphc}'s current font at \italic{grphc}'s 
current point \italic{(cx, cy)}.  The relationship between the string and the 
current position is specified by the parameter \italic{Operation}.  Values for 
\italic{Operation} are constructed by or-ing together a horizontal and a 
vertical alignment option. 


The horizontal alignment options are: 


\formatnote{\italic{graphic_\smaller{NOMOVEMENT}}\formatnote{  --  }the origin 
of the string will be at \italic{cx}.


\italic{graphic_\smaller{ATRIGHT}}\formatnote{  --  }the rightmost part of the 
string will be at \italic{cx}.


\italic{graphic_\smaller{ATLEFT}}\formatnote{  --  }the leftmost part of the 
string will be at \italic{cx}.


\italic{graphic_\smaller{BETWEENLEFTANDRIGHT}}\formatnote{  --  }the center of 
the string will be at \italic{cx}.



}The vertical alignment options are: 


\formatnote{\italic{graphic_\smaller{NOMOVEMENT}}\formatnote{  --  }the origin 
of the string will be at \italic{cy}.


\italic{graphic_\smaller{ATTOP}}\formatnote{  --  }the topmost part of the 
string will be at \italic{cy}.


\italic{graphic_\smaller{ATBOTTOM}}\formatnote{  --  }the bottommost part of 
the string, including any descenders, will be at \italic{cy}.


\italic{graphic_\smaller{ATBASELINE}}\formatnote{  --  }the baseline of the 
string will be at \italic{cy}.


\italic{graphic_\smaller{BETWEENTOPANDBASELINE}}\formatnote{  --  }the center 
point of the string will be at \italic{cy}.  The center is calculated from the 
topmost part of the string to the bottomost part, which will include 
descenders.


\italic{graphic_\smaller{BETWEENTOPANDBOTTOM}}\formatnote{  --  }the center of 
the string will be at \italic{cy}.  The center is calculated from the topmost 
part of the string to the baseline of the string.  No account is taken of 
descenders. This is likely to look better than 
\italic{graphic_\smaller{BETWEENTOPANDBASELINE}} in most cases.



}Either option (horizontal or vertical alignment) may be omitted. 
 \italic{graphic_\smaller{ATBASELINE}} and \italic{graphic_\smaller{ATLEFT}} 
will be used as defaults. 

}
\begindata{bp,269855964}
\enddata{bp,269855964}
\view{bpv,269855964,159,0,0}
\paragraph{Drawing text} \indexi{Graphic++Draw text}

\indexi{ \italic{graphic_DrawText}}

\example{void graphic_DrawText(grphc, Text, TextLength, Operation) struct 
graphic *grphc;  

char *Text;  

long TextLength;  

long Operation;} 


\leftindent{\bold{Method description.  }\italic{graphic_DrawText}  draws 
\italic{TextLength} number of characters from the string \italic{Text}.  In 
contrast, \italic{graphic_DrawString} draws all the characters in the string 
(i.e., it draws until it encounters a \smaller{NULL} character).  Except for 
this difference, the two methods are alike. 

}


\paragraph{Setting a shim value for spaces} \indexi{Graphic++Set space shim}

\indexi{ \italic{graphic_SetSpaceShim}}

\example{void graphic_SetSpaceShim(grphc,n) 

struct graphic *grphc;  

short n;} 


\leftindent{\bold{Method description.  }\italic{graphic_SetSpaceShim} sets the 
amount of space that will be added to the right of space characters (after the 
character shim) to \italic{n} pixels.  The default value is 0 pixels. 


\bold{Usage.}  This method has its primary use in the Andrew Toolkit system 
applications like the object \italic{text}. 


}
\paragraph{Getting the shim value for spaces} \indexi{Graphic++Get space shim}

\indexi{ \italic{graphic_GetSpaceShim}}

\example{short graphic_GetSpaceShim(grphc) 

struct graphic *grphc; }


\leftindent{\bold{Method description.}  \italic{graphic_GetSpaceShim} gets the 
space shim value. 

}\
\begindata{bp,270079408}
\enddata{bp,270079408}
\view{bpv,270079408,160,0,0}
\subsection{Drawing regions} \paragraph{Drawing a rectangle} 
\indexi{Graphic++Draw rectangle}

\indexi{ \italic{graphic_DrawRect}}

\example{void graphic_DrawRect(grphc, Rect) 

struct graphic *grphc;  

struct rectangle *Rect;} 


\leftindent{\bold{Method description.  }\italic{graphic_DrawRect} draws a 
rectangle in \italic{grphc} at the coordinates specified by the rectangle 
\italic{Rect}. 


\bold{Usage.}  For efficiency reasons, a \italic{rectangle} is not an object. 
 To use rectangles, you must #include \italic{rectangle.h} from the Andrew 
Toolkit library.  A rectangle can be specified by an (x,y) coordinate, a 
\italic{width} and a \italic{height} (see Rectangles), or by an upper left and 
a lower right corner.   The rectangle specifications conform to the X 
standard.



}\paragraph{Drawing a polygon} \indexi{Graphic++Draw polygon}

\indexi{ \italic{graphic_DrawPolygon}}

\example{void graphic_DrawPolygon(grphc, PointArray, PointCount) struct 
graphic *grphc;  

struct point *PointArray;  

short PointCount;} 


\leftindent{\bold{Method description.}   \italic{graphic_DrawPolygon} provides 
a placeholder for functions drawing sided, enclosed figures that are not 
rectangles.  It is assumed that the last point is connected to the first 
point. 


}
\paragraph{Drawing an oval} \indexi{Graphic++Draw oval}

\indexi{ \italic{graphic_DrawOval}}

\example{void graphic_DrawOval(grphc, Rect) 

struct graphic *grphc;  

struct rectangle *Rect;} 


\leftindent{\bold{Method description.}   \italic{graphic_DrawOval} is the same 
as \italic{graphic_DrawPolygon }except it is used for drawing oval figures.} 

\begindata{bp,270383836}
\enddata{bp,270383836}
\view{bpv,270383836,161,0,0}
\paragraph{Drawing arcs} \indexi{Graphic++Draw arc}

\indexi{ \italic{graphic_DrawArc}}

\example{void graphic_DrawArc(grphc, EnclRect, StartAngle, OffsetAngle) 

struct graphic *grphc;  

struct rectangle *EnclRect;  

short StartAngle;  

short OffsetAngle;} 


\leftindent{\bold{Method description.}   \italic{graphic_DrawArc} is the same 
as \italic{graphic_DrawPolygon }except it is used for drawing arcs. 


\bold{Usage.}  Angles are degrees from 12 o'clock, with clockwise the positive 
direction. 



}\paragraph{Drawing a rounded rectangle} \indexi{Graphic++Draw rounded 
rectangle}

\indexi{ \italic{graphic_DrawRRect}}

\example{void graphic_DrawRRect(grphc,OuterBox, InnerBox) 

struct graphic *grphc;  

struct rectangle *OuterBox;  

struct rectangle *InnerBox;} 


\leftindent{\bold{Method description.}   \italic{graphic_DrawRRect} is the 
same as \italic{graphic_DrawPolygon }except it is used for drawing a rounded 
rectangle, that is, a rectangle with rounded corners. 


}
\paragraph{Drawing a region} \indexi{Graphic++Draw region}

\indexi{ \italic{graphic_DrawRgn}}

\example{void graphic_DrawRgn(grphc,Rgn) 

struct graphic *grphc;  

struct region *Rgn;} 


\leftindent{\bold{Method description.}   \italic{graphic_DrawRgn} is the same 
as \italic{graphic_DrawPolygon }except it is used for drawing regions. 


}
\subsection{Filling regions} \paragraph{Filling a rectangle} 
\indexi{Graphic++Fill rectangle}

\indexi{ \italic{graphic_FillRect}}

\example{void graphic_FillRect(grphc, Rect, Tile) 

struct graphic *grphc;  

struct rectangle *Rect;  

struct pixmap *Tile;} 


\leftindent{\bold{Method description.}   \italic{graphic_FillRect} fills a 
rectangle in grphc with the specified pixmap, \italic{Tile}. 


\bold{Usage.}  If Tile is 1, then black; if 0, then white.} 




\paragraph{Filling a polygon} \indexi{Graphic++Fill polygon}

\indexi{ \italic{graphic_FillPolygon}}

\example{void graphic_FillPolygon(grphc,PointArray, PointCount, Tile) 

struct graphic *grphc;  

struct point *PointArray;  

short PointCount;  

struct pixmap *Tile;} 


\leftindent{\bold{Method description.}   \italic{graphic_FillPolygon} is used 
to fill polygon regions. 


}
\paragraph{Filling an oval} \indexi{Graphic++Fill oval}

\indexi{ \italic{graphic_FillOval}}

\example{void graphic_FillOval(grphc, Rect, Tile) 

struct graphic *grphc;  

struct rectangle *Rect;  

struct pixmap *Tile;} 


\leftindent{\bold{Method description.}   \italic{graphic_FillOval} is used to 
fill oval regions.} 



\paragraph{Filling in an arc} \indexi{Graphic++Fill arc}

\indexi{ \italic{graphic_FillArc}}

\example{void graphic_FillArc(grphc, EnclRect,StartAngle, OffsetAngle,Tile) 

struct graphic *grphc;  

struct rectangle *EnclRect;  

short StartAngle;  short OffsetAngle;  

struct pixmap *Tile;} 


\leftindent{\bold{Method description.}   \italic{graphic_FillArc} fills arc 
regions. 


\bold{Usage.}  This method is used to fill in pie chart regions. 



}\paragraph{Filling rounded rectangles} \indexi{Graphic++Fill rounded 
rectangle}

\indexi{ \italic{graphic_FillRRect}}

\example{void graphic_FillRRect(grphc,OuterBox,InnerBox,Tile) struct graphic 
*grphc;  

struct rectangle *OuterBox;  

struct rectangle *InnerBox;  

struct pixmap *Tile;} 


\leftindent{\bold{Method description.}   \italic{graphic_FillRRect} fills 
rectangles regions created by \italic{DrawRRect}. }

\begindata{bp,270325224}
\enddata{bp,270325224}
\view{bpv,270325224,162,0,0}
\subsection{Bit block transfers}


\paragraph{Doing a block transfer of bits} \indexi{Graphic++Bit block transfer}

\indexi{ \italic{graphic_BitBlt}}

\example{void graphic_BitBlt(grphc, SrcRect, DstPixMap, DstOrigin, ClipRect) 

struct graphic *grphc;  

struct rectangle *SrcRect;  

struct graphic *DstPixMap;  

struct point *DstOrigin;  

struct rectangle *ClipRect; 

}
\leftindent{\bold{Method description.  }\italic{graphic_BitBlt} performs the 
transfer of bits from a source pixel map to a destination pixel map.  The 
source pixel map is formed from \italic{grphc}'s \italic{SrcRect}.  The 
destination pixel map is specified by \italic{DstPixMap} and the destination 
rectangle has origin \italic{DstOrigin} and is the same size as the 
\italic{SrcRect}.  The dimensions of the source rectangle and destination 
rectangles must be the same.  The Clipping rectangle, \italic{ClipRect}, 
limits the region of the destination that can be affected by the block 
transfer; if any parts of the destination fall outside the bounds specified by 
the clipping rectangle, they will be clipped.  (Clip Rect not yet 
implemented.) 


}
\paragraph{Setting the location of a bit} \indexi{Graphic++Set bit location}

\indexi{ \italic{graphic_SetBitAtBitLoc}}

\example{void graphic_SetBitAtLoc(grphc,XPos,YPos, Value) 

struct graphic *grphc;  

long YPos;  

long XPos;  

boolean Value;} 


\leftindent{\bold{Method description.}   \italic{graphic_SetBitAtLoc }sets the 
bit at \italic{grphc}'s (\italic{Xpos, Ypos}) coordinate to the value 
\italic{Value}.  Value should be 1 (black) or 0 (white). 

}
\begindata{bp,269952820}
\enddata{bp,269952820}
\view{bpv,269952820,163,0,0}
\subsection{The logical rectangle}


\paragraph{Getting the logical bounds} \indexi{Graphic++Get logical bounds}

\indexi{ \italic{graphic_GetLogicalBounds}}

\example{void graphic_GetLogicalBounds(grphc,rect) 

struct graphic *grphc;  

struct rectangle *rect; }


\leftindent{\bold{Method description.  }\italic{graphic_GetLogicalBounds }sets 
the rectangle \italic{rect}'s left, top, width and height state variables to 
the values of \italic{grphc}'s logical rectangle. 


\bold{Example.} 


\example{struct rectangle *rect;  

struct graphic *go; 


go = graphic_New(); 


graphic_GetLogicalBounds (go, &rect);} 


sets \italic{rect'}s state variables to \italic{go}'s logical rectangle. 

}


\paragraph{Getting the logical right} \indexi{Graphic++Get logical right}

\indexi{ \italic{graphic_GetLogicalRight}}

\example{long graphic_GetLogicalRight(grphc) 

struct graphic *grphc; }


\leftindent{\bold{Method description.}   \italic{graphic_GetLogicalRight} 
returns the \italic{x} coordinate for the right side of the \italic{grphc}'s 
logical rectangle. 


}
\paragraph{Getting the logical bottom} \indexi{Graphic++Get logical bottom}

\indexi{ \italic{graphic_GetLogicalBottom}}

\example{long graphic_GetLogicalBottom(grphc) 

struct graphic *grphc;} 


\leftindent{\bold{Method description.}   \italic{graphic_GetLogicalBottom 
}returns the \italic{y} coordinate for the bottom side of the \italic{grphc}'s 
logical rectangle.} 


\begindata{bp,270128164}
\enddata{bp,270128164}
\view{bpv,270128164,164,0,0}
\paragraph{Getting the enclosed bounds} \indexi{Graphic++Get enclosed bounds}

\indexi{ \italic{graphic_GetEnclosedBounds}}

\example{void graphic_GetEnclosedBounds(grphc,rect) 

struct graphic *grphc;  

struct rectangle *rect;} 


\leftindent{\bold{Method description.}   \italic{graphic_GetEnclosedBounds} 
sets the rectangle \italic{rect}'s left, top, width and height state variables 
to the values of \italic{grphc}'s enclosed rectangle. 



}\paragraph{Getting the enclosed right} \indexi{Graphic++Get enclosed right}

\indexi{ \italic{graphic_GetEnclosedRight}}

\example{long graphic_GetEnclosedRight(grphc) 

struct graphic *grphc; }


\leftindent{\bold{Method description.}   \italic{graphic_GetEnclosedRight} 
returns the \italic{grphc}'s \italic{x} coordinate for the right side of the 
\italic{grphc}'s enclosed rectangle. 

}


\paragraph{Getting the enclosed bottom} \indexi{Graphic++Get enclosed bottom}

\indexi{ \italic{graphic_GetEnclosedBottom}}

\example{long graphic_GetEnclosedBottom(grphc) 

struct graphic *grphc;} 


\leftindent{\bold{Method description.}   \italic{graphic_GetEnclosedBottom} 
returns the \italic{grphc}'s \italic{y} coordinate for the right side of the 
\italic{grphc}'s enclosed rectangle.} 


\subsection{The visual rectangle} \paragraph{Getting the visual rectangle 
bounds} \indexi{Graphic++Get visual bounds}

\indexi{ \italic{graphic_GetVisualBounds}}

\example{void graphic_GetVisualBounds(grphc,rect) s

truct graphic *grphc;  

struct rectangle *rect;} 


\leftindent{\bold{Method description.}   \italic{graphic_GetVisualBounds} gets 
the boundaries of the visual rectangle. 

}



\paragraph{Getting the visual right}

 \indexi{Graphic++Get visual right}\indexi{ \italic{graphic_GetVisualRight}}

\example{long graphic_GetVisualRight(grphc)

struct graphic *grphc;} 


\leftindent{\bold{Method description.}   \italic{graphic_GetVisualRight} gets 
the right of the visual rectangle.} 


\paragraph{Getting the visual bottom} \indexi{Graphic++Get visual bottom}

\indexi{ \italic{graphic_GetVisualBottom}}


\example{long graphic_GetVisualBottom(grphc) 

struct graphic *grphc;} 


\leftindent{\bold{Method description.}   \italic{graphic_GetVisualBottom} gets 
the bottom of the visual rectangle.} 




\begindata{bp,269855908}
\enddata{bp,269855908}
\view{bpv,269855908,165,0,0}
\subsection{The clipping rectangle} \paragraph{Setting the clipping rectangle} 
\indexi{Graphic++Set clipping rectangle}

\indexi{ \italic{graphic_SetClippingRect}}

\example{void graphic_SetClippingRect(grphc, rect) 

struct graphic *grphc;  

struct rectangle *rect;} 


\leftindent{\bold{Method description.}   \italic{graphic_SetClippingRect} sets 
\italic{grphc}'s clipping rectangle to \italic{rect}.} 


\paragraph{Clearing a clipping rectangle} \indexi{Graphic++Clear clipping 
rectangle}

\indexi{ \italic{graphic_ClearClippingRect}}

\example{void graphic_ClearClippingRect(grphc) 

struct graphic *grphc;} 


\leftindent{\bold{Method description.}   \italic{graphic_ClearClippingRect} 
clears \italic{grphc}'s clipping rectangle. 



}\paragraph{Getting the current clipping rectangle} \indexi{Graphic++Get 
clipping rectangle}

\indexi{ \italic{graphic_GetClippingRect}}

\example{void graphic_GetClippingRect(grphc,rect) 

struct graphic *grphc;  

struct rectangle *rect;} 


\leftindent{\bold{Method description.}   \italic{graphic_GetClippingRect} sets 
\italic{rect} to \italic{grphc}'s clipping rectangle.  If \italic{grphc} has 
not set a clipping rectangle, \italic{rect} is set to \italic{grphc}'s visual 
rectangle.} 



\begindata{bp,270191736}
\enddata{bp,270191736}
\view{bpv,270191736,166,0,0}
\subsection{The transfer mode}


\paragraph{Setting the transfer mode} \indexi{Graphic++Set transfer mode}

\indexi{Graphic++Drawing}

\indexi{ \italic{graphic_SetTransferMode}}

\example{void graphic_SetTransferMode(grphc,NewTransferMode) struct graphic 
*grphc;  

short NewTransferMode;} 


\leftindent{\bold{Method description.  }\italic{graphic_SetTransferMode} sets 
the transfer mode for drawing.  The default is 
\italic{graphic_}\smaller{COPY}.  The transfer mode specifies how each source 
element S and each destination element D should combine to produce the result. 
 The source and destination each have four elements, so there are sixteen 
possible ways to combine them. 


It is useful to think of the source and destination as forming a table of 
bits: 


\formatnote{
graphic_SOURCE\formatnote{  --  }1\formatnote{  --  }1\formatnote{  -- 
 }0\formatnote{  --  }0

graphic_DESTINATION\formatnote{  --  }1\formatnote{  --  }0\formatnote{  -- 
 }1\formatnote{  --  }0

}__________________________________________________________

\formatnote{Transfer mode result\formatnote{  --  }?\formatnote{  -- 
 }?\formatnote{  --  }?\formatnote{  --  }?

}

The transfer mode specifies the Result when S and D are both 1, when S is 1 
and D is 0, when S is 0 and D is 1 and when both S and D are 0.  When a bit is 
1, it is interpreted as black; when 0, as white.  For example, if you want the 
result to be 1 (that is black) only when both the source and destination are 1 
(black), you would AND together the source and destination 
(\italic{graphic_}\smaller{SOURCE} & 
\italic{graphic_}\smaller{\smaller{DEST}}) to form the transfer mode.  If you 
want the source to be copied directly without regard to the current value of 
the destination, you would use \italic{graphic_}\smaller{SOURCE} alone to form 
the transfer mode. 


You can construct the transfer mode by forming boolean combinations from the 
graphic constants graphic_SOURCE and graphic_DESTINATION directly.  For 
convenience, the following common combinations have been defined as well: 


\description{
\italic{graphic_}\smaller{COPY}\formatnote{  --  }the bit values are from the 
source


\italic{graphic_}\smaller{OR}\formatnote{  --  }the bit values result from 
\smaller{OR}-ing the source and the destination


\italic{graphic_}\smaller{XOR}\formatnote{  --  }the bit values result from an 
exclusive or of the source and the destination


\italic{graphic_}\smaller{AND}\formatnote{  --  }the bit values result from an 
\smaller{AND}-ing the source and destination


\italic{graphic_}\smaller{WHITE}\formatnote{  --  }the bit values are white


\italic{graphic_}\smaller{BLACK}\formatnote{  --  }the bit values are black


\italic{graphic_}\smaller{INVERT}\formatnote{  --  }the bit values are the 
opposite of the destination (if black, white; if white, black)

}
}
\begindata{bp,270045740}
\enddata{bp,270045740}
\view{bpv,270045740,167,0,0}
\paragraph{Getting the transfer mode} \indexi{Graphic++Get transfer mode}

\indexi{ \italic{graphic_GetTransferMode}}

\example{short graphic_GetTransferMode(grphc) 

struct graphic *grphc;} 


\leftindent{\bold{Method description.}   \italic{graphic_GetTransferMode} gets 
the transfer mode. 

}

\subsection{Buffered output} \paragraph{Flushing graphic output} 
 \indexi{Graphic++Flushing}

\indexi{ \italic{graphic_FlushGraphics}}

\example{void graphic_FlushGraphics(grphc) 

struct graphic *grphc;} 


\leftindent{\bold{Method description.}   \italic{graphic_FlushGraphics} 
insures that drawing commands are actually done (not buffered). 

}

\subsection{Patterns} \paragraph{Making white patterns} \indexi{Graphic++White 
patterns}

\indexi{ \italic{graphic_WhitePattern}}

\example{struct pixmap *graphic_WhitePattern(grphc) 

struct graphic *grphc;} 


\leftindent{\bold{Method description.}   \italic{graphic_WhitePattern }returns 
a white pixmap. }



\paragraph{Making black patterns} \indexi{Graphic++Black patterns}

\indexi{ \italic{graphic_BlackPattern}}

\example{struct pixmap *graphic_BlackPattern(grphc) 

struct graphic *grphc;} 


\leftindent{\bold{Method description.}   \italic{graphic_BlackPattern} returns 
a black pixmap. 


}
\paragraph{Making gray patterns} \indexi{Graphic++Gray patterns}

\indexi{ \italic{graphic_GrayPattern}}

\example{struct pixmap *graphic_GrayPattern(grphc,IntensityNum, 
IntensityDenom) 

struct graphic *grphc;  

long IntensityNum, IntensityDenom;} 


\leftindent{\bold{Method description.}   \italic{graphic_GrayPattern} returns 
a grey pixmap.} 

\begindata{bp,269937948}
\enddata{bp,269937948}
\view{bpv,269937948,168,0,0}
\subsection{Redirecting graphic output} \paragraph{Redirecting a graphic} 
\indexi{Graphic++Redirect}

\indexi{ \italic{graphic_RedirectGraphic}}

\example{void graphic_RedirectGraphic(grphc,SecondaryGraphic) struct graphic 
*grphc;  

struct graphic *SecondaryGraphic;} 


\leftindent{\bold{Method description.  }\italic{graphic_RedirectGraphic} is a 
private method intended for future expansion.   The intention is to provide a 
way to switch between graphics systems on the fly, such as generating 
PostScript by capturing graphics calls rather than via a print command. This 
method would redirect a graphic so that it went to a PS version instead. 


\bold{Usage.}  Should not be used by application programmers at this time. 

}

\enddata{text,270048644}
