\begindata{text,268667792}
\textdsversion{12}
\template{default}


\bold{\bigger{\bigger{\center{Tutorial on ADEW 


The Andrew Development Environment Workbench

}}}}	

\italic{\center{For Adew version 3.0

Release of November, 1989}



\center{\italic{Thomas Neuendorffer

Information Technology Center

Carnegie Mellon University

5000 Forbes Ave.

Pittsburgh, Pa. 15213

(412) 268-6108

tpn@andrew.cmu.edu}}



}The best way to learn about software is to play with it, and the purpose of 
this tutorial is to guide your play.  The tutorial moves from simple, basic 
concepts to more complex designs, finishing with a complete step-by-step 
example of a program that anyone (even a non-programmer!) can create.  Because 
later sections depend on information presented earlier, try and follow the 
steps in order.  Within each section, though, you are encouraged to do some 
experimenting.


This document assumes that you have passing familiarity with some ATK 
applications, like EZ and Fad, and (more importantly) have read the ADEW 
Overview file.  If you read the Overview file, but did not completely 
understand it, working through this tutorial will help make some of the 
concepts presented there more concrete.  It is a good idea to read back 
through the Overview when you come to convenient stopping places in this 
tutorial.  If you want, you can also read through the Reference Manual when 
you take a break.


The important thing at this point is to get started: bring up the Arbcon, 
fiddle with the switches, create a window and see what it does.  You might 
even have fun! 


Enjoy.


\begindata{bp,270461248}
\enddata{bp,270461248}
\view{bpv,270461248,66,0,0}
\chapter{1	Creating Multi-Object Files}



\section{1.1	Getting started}


For the benefit of some of the later examples, you might want to create an 
empty directory in which to do this Tutorial; it will make it easier to create 
sample applications later on. 


ADEW applications are created with a program called Arbcon.  To run Arbcon, 
move into the empty directory you created and type


\bold{\leftindent{arb}}


Once you have an Arbcon window up, you will want to bring up a work area to 
try some of the examples.  To do this, choose \bold{New Window} from the 
\italic{Arbcon} menu within the Arbcon window.   You are prompted for a file 
name in the message line.  Enter a name (like "scratch") and press Enter.


The window that appears has a text object in it, by default.  You can change 
what type of object appears in new windows by clicking in the \italic{Object 
<View>} panel before opening the window.   Try that now by clicking on "lset." 
 You should see the following in your Arbcon window:


\bold{\leftindent{Copying new lset object}}


This lets you know that Arbcon is copying something into the cutbuffer.  Now 
choose \bold{New Window}.  The filename prompt in the message line specifies 
that the default object in the window will be lset.  Complete the prompt by 
entering a filename, and press Enter.  Now you have two windows, a text window 
and an lset window.  (The lset window is completely dark.)


The \bold{New Window} option can be used to bring up existing files as well as 
creating new ones.  All of the standard commands for reading and saving files 
which are normally available from EZ are operational, though sometimes it may 
be necessary to click into an object to bring up the menus. 


If at any time you have to quit but don't want to lose what you have done, use 
the \bold{Save All} menu option in one of the new windows you have brought up 
to save the files you have created, as you would any normal text file. 


\section{1.2	Working with lset}


Lset lets you split a window up into rectangular regions of any size.  To do 
this, choose \bold{Split Horizontal} or \bold{Split Vertically} from the 
\italic{lset} menu.  This gives you a split cursor.  The next mouse hit in the 
lset will split it, creating one light region and one dark region.  The dark 
region is the one that is selected and will be split if you chose a 
\bold{Split} command again.  To change which rectangle is selected, click in a 
different rectangle.  Try splitting the window several different ways to 
create a bunch of rectangles.  


The divisions between the rectangles may be moved by dragging on a division. 
  Divisions may also be unsplit via the \bold{Unsplit lset} menu option.  Try 
moving the divisions, and unsplitting one or two divisions.


\section{1.3	Adding objects}


The basic notion behind using Arbcon is selecting an Object (that Arbcon 
copies into the cut buffer) and then pasting the object where you would like 
it to go.  In this section you can learn about pasting non-value objects.  (In 
part two of the tutorial, you can learn about value-objects.)


Try pasting a Fad object into an lset rectangle.  First, click on "fad" in the 
Arbcon window.  You should see the following in the Arbcon window:


\leftindent{\bold{Copying new fad object}}


Next, move to the lset window, click in the rectangle you want the Fad object 
to be in, and choose \bold{Paste} from the lset menu.   Two things happen.


One: in your lset window, there is now a Fad object. Just click in Fad once to 
give it the input focus (i.e. tell it that it is the thing you want to take 
commands) and then just click and drag to draw lines.  Draw a few things in 
the Fad object. 


Two: in your Arbcon window, you should see the following line:


\leftindent{\bold{fad-fadview Inset. Name} fad}


You do not need to do anything to this line.   Just notice that initially you 
were told that Arbcon was copying a new Fad object.  Now, Arbcon is displaying 
information about the object.  You will learn more about this line, and lines 
like it later in the Tutorial.


Now, try pasting a Fad object into the \italic{text} window.   Click on "fad" 
again, see that it is being copied into the cutbuffer, position the text caret 
in the text window, and choose \bold{Paste} from the front menu in the text 
window.  You need to click in the Fad object to give it input focus and see 
where it is. 


Notice that the Fad in the text expands to a bigger size, while the lset Fad 
won't.  This is because text adjusts to its children's size requests, while 
lset doesn't.  This is one of the considerations to take into account when 
deciding what parent object (in this case, text or lset) to use when creating 
applications.


Try \bold{Pasting} some of the other available objects into your lset or text 
window.


\section{1.4	Naming Objects}


Each file you create with Arbcon has associated with it an "arbiter."  The 
arbiters are, by default, named the same as the files they are associated 
with.  You can't change the name of an arbiter.  The primary function of an 
arbiter is to make sure that objects within its file do not have the same 
name, which would create name conflicts. 


Specific instances of objects are, by default, named after the object that is 
in them.   Like the name of the first Fad object you create is "fad."  You can 
see the name of an object in the Arbiter window by clicking on it.  Notice, 
that two cels can have the same name if they are in different files, because 
they have different arbiters.  This is the case with the two Fad objects you 
added to your text and lset files; they are both named "fad."  


Try Pasting another Fad object into an lset rectangle.  Once you choose 
\bold{Paste}, information about the object (its name) appears:


\leftindent{\bold{fad-fadview Inset. Name} fad_1}


The object you just added is named "fad_1," to prevent any name conflicts. 
 This is a unique name for the object, and so there is no need to change it. 
 However, if you want to, you can change the name of an object by editing the 
name as it appears ("fad_1") and pressing the "Save" button at the bottom of 
the Arbcon window.  Try it now.  After you have pressed Save, check to see 
that the name of fad_1 is changed by selecting a different object in the lset 
window.   Then, select the Fad object whose name you just changed.  The name 
should no longer be "fad_1," but what ever you changed it to.  Try creating 
some other objects and changing their names.


\section{1.5	The Application Switch}


In the Arbcon window there is a switch with the labels, "Application" and 
"Normal."  The position of this switch determines whether or not an object is 
brought up with its application layer.  Usually, as with the case of text, 
"application layer"  refers to the presence of the scroll bar.  


Try creating a text object in an lset rectangle.  Click in an empty rectangle 
to select it.  Then click on "text" in the Arbcon window.  Click on 
"Application" to move the switch.  You should see the following in the Arbcon 
window:


\leftindent{\bold{Copying new text object w/ application layer}}


Move to the lset window and choose \bold{Paste}.  Notice how text comes up 
with a scroll bar.  Try creating a Raster object in an lset cel.  Raster's 
application layer contains scroll bars in two dimensions.  Some objects, like 
lset, have no application layer; for them the switch has no effect.


\indent{Note: Bringing up application layers directly under the text parent is 
not recommended.  Often the scroll object will try and take too much space. 
 One way around this is to place an lset object in the text, and then place a 
single ojbect with the application layer in that lset.  It really isn't as 
complicated as it sounds.  Try it.

}
\section{1.6	Cutting  and Copying

}
By now, you have probably created a lot of objects and are perhaps are getting 
overloaded.   So lets get rid of some of them.   Most parents (like lset or 
text) provide some method for deleting the objects created under them.  In 
text you can cut them out or even just backspace over objects to destroy them 
(the later might be a misfeature).  The Arbcon provides the cut button as a 
means of destroying a cel and putting a copy of it and its child in the ATK 
cut buffer.   


Select one of your objects by clicking in it.  Click the cut button in the 
Arbcon window (the button with the scissors).  Poof!  The object is gone! 
 But, it's not forgotten.  By choosing\bold{ Paste} in any object that 
supports it, a new copy of the object is created.  Multiple copies may be 
created.  Objects may also be moved from one parent to another. 


\leftindent{Warning: the cut button function in Arbcon is currently not 
supported in all parent objects.  Don't try and cut objects out of any parents 
other than text and lset.  Instead, use \bold{Copy }and whatever delete 
function the parent in question provides.}


The Copy button in the Arbcon window places a copy of the cel in the cut 
buffer, without destroying the original object.  Try cutting and copying 
various objects around.  Note that name conflicts are resolved as above, by 
appending a '-' and a unique number to the name to make it unique. 


\section{1.7	Linking Cels}


As mentioned in the Overview document, ATK supports the notion of multiple 
views on a single piece of data.  The link button on the Arbcon provides an 
interface to this feature.  Here you can use it to link two Fad views to the 
same data, so when you draw in one object it will show up in the other.  


In your lset window, create an empty rectangle.  Now, select one of your 
existing Fad objects in the lset window and click on the link switch in the 
Arbcon window.  Note the following in the message line of Arbcon:


\leftindent{Copying new fadview link to fad}


By default, the object you want to link to is made the same as the object you 
want to link from.  Now select the empty target rectangle\bold{ }to link to 
\bold{in the same parent} (links may not extend across arbiters) and choose 
\bold{Paste}.  The new object will be another copy of the Fad object.  Notice 
if you go into the new Fad object and add a new line (or move an old one) that 
the other Fad object also changes.


\subsection{1.7.1	Write-Ins}


Occasionally, one may come across an object that you wish to create that is 
not on the default \italic{Objects <View>} list.  When you come across this 
situation, you can use the \bold{Add Object }option on the \italic{Arbcon} 
menu card.  This prompts you for a new object to add.  The syntax is the same 
as description that appears in the Arbcon window.  

\begindata{bp,270102768}
\enddata{bp,270102768}
\view{bpv,270102768,67,0,0}
\chapter{2	The Value Objects

}

In the previous section you created two Fad views on the same data, or object. 
 In this section, you can learn about creating different views on the same 
data by using "values."  Values are simple dataobjects designed to provide a 
simple and consistent interface for insets that share a common feature:


\leftindent{\italic{They only need to store an integer, string, and/or string 
array. }}


The value views are sliders, thumbwheels, buttons, bargraphs, and other 
objects that can be combined to create applications.


\section{2.1	Creating value objects}


In your Arbcon window, choose \bold{Init Value Window}.  This will bring up a 
window that has all the valueview objects in it.  Click on each of the 
objects.  Notice how the attributes of the object that is selected appear in 
the Arbcon window, like the following:


\leftindent{\bold{value-onoffV Inset. Name} onoff_0

\bold{long bodyfont-size} 10

\bold{string bodyfont} andy

\bold{string top label }on-off

\bold{string bottom label} switch}


Do not worry about the attributes now.  Simply notice that they change when 
you click on different objects.


(Notice to select  clicklist, menustrV and String Entry you need to click in a 
specific region within their box.)  


When you click on an object and its attributes appear in the Arbcon window, it 
is copied into the cutbuffer, just like for text, lset and Fad in the previous 
section.  You can then \bold{Paste} the object into your text or lset window. 
 Try Pasting a slider.  When you click and move the cursor on the slider, its 
value goes up and down.  Paste some other value objects into your text and 
lset windows.


\section{2.2	Editing the valueview's attributes}


Unlike text, lset, Fad, and other non-value objects, valueviews have user 
setable parameters (called attributes) to describe how they will display 
themselves.  More often that not, this will include a label and the font to 
display it.  These may be set via the Arbcon.  The attributes look like:


\leftindent{\bold{Type-of-field  Name of the field}  field contents}


The "field contents" is the user setable parameter. To set the parameters, 
just go into that area and type the desired values.  For example, \bold{Paste} 
an on-off switch somewhere.  You should see the attributes listed in the 
Arbcon window like those above.  Now, change them to look like the following:


\leftindent{\bold{value-onoffV Inset. Name} onoff_0

\bold{long bodyfont-size} 12

\bold{string bodyfont }andysans

\bold{string top label} ON

\bold{string bottom label} OFF}


When you are done, click the Save button.  The on-off switch should change to 
reflect its new values and labels.  Try creating and editing some of the other 
valueviews (ignore controlV for the moment).  Then try going back to an object 
already edited, select it, edit it, and change some of the parameters.


\section{2.3	Linking Values}


As with other objects, value objects may be linked.  Since they all use the 
same data object, valueviews of different types may also be linked.  


Create a sliderV valueview in your text window and then click the link button. 
 Notice in the message line of the Arbcon window:


\leftindent{Copying New sliderV link to slider_0}


As with Fad, the default object to link to is identical to the object you are 
linking from.  Now choose \bold{Paste} in your text window.  This Pastes 
another slider that is linked to the first one.  Slide one slider up and down 
and the other one moves, too.


Now, click on the first slider and flip the switch to link again.  This time, 
when you see the message in the message line, click on "value bargraphV" in 
the Arbcon window.  The message line should read:


\leftindent{Copying New bargraphV link to slider_0}


This tells you that a bargraph is being copied into the cut buffer.  Note that 
what is being copied into the cut buffer does not appear in the area of the 
window that it would normally appear in.  All you see is the notification in 
the message line.


Now, \bold{Paste} in your text window again.  If all went well, moving the 
slider should cause the graph to move as well.  Note how the graph only 
changes when you let up the mouse button on the slider.  This is because 
valueviews are 'up sensitive'.  What happens when you slide the slider and the 
move the mouse pointer outside of it?  This is the way one can change one's 
mind about changing the value before it gets changed.  Try changing the max 
and min values of the bargraph.  Note how they are not linked to the range of 
the slider.  


Try some other combinations of value pairs, like a sliderV and a bargraphV.


\section{2.4	EnterstrV}


As you may have noticed, enterstrV is a somewhat special value.  It is a 
combination of a button object and a special text object that lets you enter 
strings.  Try creating one.  Use the following attributes:


\leftindent{\bold{value enterstrV Inset Name} menterstr_0

\bold{long bodyfont-size} 10

\bold{string bodyfont} andy

\bold{string label} Click to enter value.}


Try linking this object to a "stringV" valueview.  What happens when a string 
is entered?  Make a third link to a bargraph and enter '50 beans' into the 
enterstrV.  Try other links.


\section{2.5	Notes}


You may have noticed that some different valueviews seem to act alike (sliderV 
and sliderstrV, thumbV and thumbstrV).  We have also avoided the controlV and 
menterstrV objects.  These are objects whose special qualities show up when 
creating applications.  For now, suffice it to say that the thumbstr and 
sliderstr objects can be used to display string arrays instead of numbers (the 
Objects and Views wheels are thumbstrVs); the controlV can be used to directly 
call a function; and menterstrV stands for multiple-enter-strings, and can be 
used to prompt the user for several parameters at once. 


This ends part 2 of the tutorial.  At this point you should know about all 
there is to know about constructing text and lset files with the Arbcon.  As 
mentioned, the Arbcon was designed to work with any ATK parent object, though 
it has been mostly tested in text and lset.  If you are familiar with Zip or 
Table, try using Arbcon with them (See the note in the Cut section, however.) 
 If you are unclear about any of the above operations, go back and review that 
area.  You also might want to re-read the Overview again at this point.


One last thing to try, if you haven't already, is objects within objects.  The 
Arbcon is not limited to one level.  Try creating a text object in an lset 
rectangle, then create an lset within that text, and so on.

 

\begindata{bp,270064488}
\enddata{bp,270064488}
\view{bpv,270064488,68,0,0}
\chapter{3	Creating Controllers}


\section{3.1	Controller Options

}
Creating files of buttons and switches is all well and fine, but what can you 
\italic{do} with them? Atk currently provides two options for binding together 
sets of objects into applications. 


\subsection{3.1.1	Createcon

}The first option, createcon, is described below. It requires some knowledge 
of the C programming language (including knowledge of structures, pointers, 
 and function calls), but knowledge of ATK programming is not required.  Tools 
are provided to greatly simplify the process of creating a dynamically loaded 
controller program using C and the Atk class preprocessor. The tutorial below 
demonstrates how a simple application can be created with one line of user 
written C code.


\subsection{3.1.2	Ness

}An alternative is provided by the interpreted language Ness. Ness is 
particularly suited to string-processing applications, and for creating 
applications that embed the controller information in the document itself, 
rather than in a separately loaded module. Readers who are unfamiliar with C 
or who prefer to work in an interpreted environment may wish to forego the 
following and instead refer to the NESS documentation for further information 
on how to create applications with NESS.


\section{3.2	A digital analog computer example.}


Remember analog computers, like the one you may have made for the science fair 
as a kid?  With two big dials or slider switches with numbers, and a meter? 
 You could set the dials to a numbers and the meter would show you their sum. 
 This part of the Tutorial takes you through how to use the ADEW tools to make 
a digital analog computer (or, to be precise, a digital computer analog of an 
analog computer :).


Teaching is by example.  If you haven't gone through the Tutorial Parts 1 and 
2, please do so before continuing. 


\subsection{3.2.1	Setting up}

The following will walk you through the creation of a dynamic object.  Before 
you begin there is one important step.  By default, EZ will only load dynamic 
objects from the system directory.  You have to tell it to load objects from 
one of your own directories if that is what you plan to do (and it is).  To 
set this up place the following in your ~/.cshrc:


if  ($?CLASSPATH) then 

	setenv CLASSPATH $\{CLASSPATH\}:. 

else if ($?ANDREWDIR) then 

	setenv CLASSPATH $\{ANDREWDIR\}/dlib/atk:. 

else 

	setenv CLASSPATH /usr/andrew/dlib/atk:. 

	setenv ANDREWDIR /usr/andrew

endif 


Now type "source ~/.cshrc".  Since .cshrc is always executed when the cshell 
starts up, this only has to be done once.  (This assumes you run the cshell.) 


\subsection{3.2.2	Create a new lset object}

Create an empty directory (or clear out the directory you used to do the 
examples above).  Start Arbcon and use \bold{New Window} to create an lset 
object.  It doesn't matter what you call the new file.  Split the lset into 
four rectangles and Paste in:


2 sliderVs (named \italic{sl_0} and \italic{sl_1}, min and max of 1 and 100)

1 bargraphV (named \italic{bg}, min and max of 0 and 200)

1 controlV (named \italic{go})


Setting the attributes for the controlV object requires a little explanation. 
 When we go to edit it in the Arbcon, we are presented with some attributes 
that we have not seen before: Auto-Init, function and class.


These attributes allow your application to call functions and actually do 
things.  ATK has what is called a "proctable," which is basically just a list 
of functions that can be looked up and called by name.  ControlV was designed 
to look up a function from this list and call it when clicked on.  You are 
going to use this controlV object  to create a button that will start your 
calculator.  Thus, it should have the following attributes:


\bold{value controlV Inset Name} go

\bold{string Auto-Init} true

\indent{This is a boolean flag to indicate if the function should be called 
once automatically the first time the controlV is drawn. Set this to 
\italic{true}.  NOTE: to make application creation easier, ControlV will only 
call the function automatically if the Arbcon is not present. 

}\bold{string function} start

\leftindent{This name is appended to the class name (with a '-') to produce 
the proctable function name to look up.  }\indent{

}\bold{string class} daccon

\indent{This is the object to load where the function is expected to be 
defined. For ADEW application, this is where you should specify the name for 
the controller you wish to create. Call it \italic{daccon}, for digital-analog 
computer controller. 

}\bold{long bodyfont-size} 12

\bold{string bodyfont} andy

\bold{string label} Go


At this point your window should look something like this:

\begindata{raster,270103260}
2 0 68266 68266 0 0 327 151
bits 270103260 327 151
ZZfe |
ZZfe |
80v0380pe0p06 |
80v0380pe0p06 |
80v039fOfee7P	f6 |
80m03n0397Ofa	e5Pd6 |
80m0480m0392o	12e480o96 |
80m0480m0392o	12e480o96 |
80m0480m0392o	12e480o96 |
80m0480m0392j	18j12e480i0180	j96 |
80m0480m0392j	24j12e480i0240	j96 |
80m0480m0392j	24j12e480i0240	j96 |
80m03n0392j24	j12e480i0240j	96 |
80v0392j24j12	e480i0240j96 |
80v0392j24j12	e480i0240j96 |
80v0392j24j12	e480i0240j96 |
80v0392j18j12	e480i0180j96 |
80v0392o12e480	o96 |
80v0392o12e480	o96 |
80v0392o12e480	o96 |
80v0392j3ej12	e480i03e0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80lIfal0392j2a	j12e480i02a0j	96 |
80l"555fl0392	j36j12e480i03	60j96 |
80l2a!aaa7l03	92j2aj12e480i	02a0j96 |
80l15!555fl03	92j36j12e480i	0360j96 |
80l0fI80k0392	j2aj12e480i02	a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
80v0392j36j12	e480i0360j96 |
80v0392j2aj12	e480i02a0j96 |
X92j36j12e480	i0360j96 |
X92j2aj12e480	i02a0j96 |
X92j36j12e480	i0360j96 |
a2/222392j2aj	12e480i02a0j96 |
/88888b92j36j	12e480i0360j96 |
a2/222392j2aj	12e480i02a0j96 |
/88888b92j36j	12e480i0360j96 |
a2/222392j2aj	12e480i02a0j96 |
/88888b92j36j	12e480i0360j96 |
a2/222392j2aj	12e480i02a0j96 |
/88888b92j36j	12e480i0360j96 |
a2%22Ja2$2223	92j2aj12e480i	02a0j96 |
&889fHfe%888b	92j36j12e480i	0360j96 |
a2%2288h08a2$22	2392j2aj12e480	i02a0j96 |
'88h08%888b92	j36j12e480i03	60j96 |
a2%2288h08a2$22	2392j2aj12e480	i02a0j96 |
'880f4008%888b	92j36j12e480i	0360j96 |
a2%228818c008	a2$222392j2aj	12e480i02a0j96 |
'88104008%888b	92j36j12e480i	0360j96 |
a2%2288200708	a2$222392j2aj	12e480i02a0j96 |
'88200d&888b92	j36j12e480i03	60j96 |
a2%228821e888	a2$222392i03G	j12e480i3ff0j	96 |
'882048&888b92	i07G80i12e480	i7ff8j96 |
a2%2288304888	a2$222392i0fG	c0i12e480iGfc	j96 |
'8818cd&888b92	i19Gc0i12e480	h019ffcj96 |
a2%22880f8708	a2$222392i33G	c0i12e480h033f	fcj96 |
'88h08%888b92	i67Gc0i12e480	h067ffcj96 |
a2%2288h08a2$22	2392iH80i12e4	80h0fGf8j96 |
'88h08%888b92	h01Hj12e480h1f	Gf0j96 |
a2%2288h08a2$22	2392h03g7ej12	e480h3007e0j96 |
'88h08%888b92	h06aabej12e480	h6aabe0j96 |
a2%228fHf8a2$22	2392h06aab8j12	e480h6aab80j96 |
&8890h04%888b	92h065530j12e4	80h6553k96 |
a2%2290h04a2$22	2392h03g60j12	e480h3006k96 |
&88a0h02%888b	92h01Gc0j12e4	80h1ffck96 |
a2%22a0h02a2$22	2392o12e480o96 |
&88c0h01%888b	92o12e480o96 |
a2%22c0h01a2$22	2393Of2e4P96 |
&88J%888b94o0a	e5p56 |
a2/222398o0ae6	p56 |
/88888b98o06e6	p36 |
a2/22239fOfee7	Pf6 |
/88888b80pe0p	06 |
a2/222380pe0p	06 |
/88888b80pe0p	06 |
ZZfe |
ZZfe |
zz02 |
\enddata{raster, 270103260}
\view{rasterview,270103260,69,0,0}
 

\subsection{3.2.3	Creating the application code

}
If all looks good, save the file from the lset window as \italic{adc}, enter 
the command window and type 


\leftindent{\bold{createcon adc}}


The output from this program will be as follows: 


\leftindent{Creating a controller for adc. Please wait...

running /usr/andy//lib/arbiters/conpros.awk adc

Creating daccon.ch

Creating daccon.c

Creating Imakefile

Creating makedaccon shellscript

Done

}

This indicates the new files created.  Take a brief look at the generated .c 
file (appendix 1).  At first glance, it will appear rather complex.  In fact, 
it \bold{is} rather complex.  However, take heart in the fact that Createcon 
has taken care of most all of the complexity for you.  You will have to edit 
this code slightly, but you can safely ignore most of it. 


\subsection{3.2.4	What these file have}

What Createcon has done is produce code for a dynamically loadable object that 
contains:


1. A proctable entry for an initialization function that is keyed to the 
controlV button.

2. A structure containing pointers to all of the dataobjects and views within 
the application. The dataobject pointers will be named the same as the object 
('-' and other strange characters are translated to '_'s), the view pointers 
will be the same, with the addition of the word view.

3. CallBack procedures set up to be called whenever a value stored in one of 
the value objects changes. These procedures are keyed to the names we gave the 
objects. A procedure name is the word CallBack appended to the object name.

4. All the files necessary for compiling a dynamic object.


Some feature of the Createcon produced code are:


1. If several values have the same name, differing only by a -<number>. Only 
one call back procedure will be set up for all of them. The third argument to 
the function (r1) will be set to the -<number> of the calling value.

2. The code contains many comments of the form

/* user code begins here for foo */

/* user code ends here for foo */

It is between the comments that all user written code should be added. The 
Createcon program uses these comment to determine what code it should preserve 
when creating new versions of the code. Thus, if you went back to adc and 
added a new button. The next running of Createcon will move the old c code to 
a backup file and merge in the additions you made into the new code. 

3. A .ch file, containing the class definition is also created. It also 
contains comments, as in 2. above, where the applications programmer may add 
additional fields to the structure he will always be passed in the call-back 
routines.


\subsection{3.2.5	Adding your code}

The next step is to edit daccon.c to produce the desired effect, in this case, 
cause the bargraph to display the sum of the two sliders. Since you want to be 
sensitive to any change in the sliders, and we named the sliders sl_0 and 
sl_1, we need to find slCallBack. It currently looks like this:


static void slCallBack(self,val,r1,r2)

struct daccon *self;

struct value *val;

long r1,r2;

\{

if(r2 == value_OBJECTDESTROYED) \{

	if(self->sl_0 == val) self->sl_0 = NULL;

	if(self->sl_1 == val) self->sl_1 = NULL;

\}

\{

/* user code begins here for slCallBack */

/* user code ends here for slCallBack */

\}

\}


Self points to the controller object, with pointers to all of the child 
objects.

Val is a pointer to the value object that changed.

r1 is a pointer to the index of the calling object (either 0 or 1 in this case 
for sl_0 and sl_1).

r2 is either  a constant that may be ignored, or the constant 
value_OBJECTDESTROYED to indicate that the value object has been destroyed. As 
seen above, createcon generates code to look for this constant and set the 
pointers to NULL if the objects are destroyed. 


To get and set the values, it is necessary to know the programmer interface to 
the value objects.  This is detailed in the ADEW Reference manual. There are 
only about 9 methods (i.e. functions), of which we currently need two:


value_GetValue(val) returns the long contents of a value.

value_SetValue(val,rock) sets the contents of a value. 


So our code will be functionally be:


\italic{/* user code begins here for slCallBack */}

int a,b,c ;

a = value_GetValue(self->sl_0);

b = value_GetValue(self->sl_1);

c = a + b;

value_SetValue(self->bg,c);

\italic{/* user code ends here for slCallBack */}


This, using value_GetValue and value_SetValue, would look like the following: 


\italic{/* user code begins here for slCallBack */}

value_SetValue(self->bg,value_GetValue(self->sl_0) + 
value_GetValue(self->sl_1));

\italic{/* user code ends here for slCallBack */}


This is what you should put in as your code.  And that is it.  A complete ATK 
application written with one line of code.


To be safe, it is good programming practice to ensure that both objects exist 
before calling their methods. So the best way to write this code would be:


\italic{/* user code begins here for slCallBack */}

if(self->sl_0 != NULL && self->sl_1 != NULL)

	value_SetValue(self->bg,value_GetValue(self->sl_0) + 
value_GetValue(self->sl_1));

\italic{/* user code ends here for slCallBack */}



\section{3.3	Completing the application}


Now that you have edited daccon.c, it may be compiled by running the 
makedaccon shellscript. 


\bold{\leftindent{makedaccon}}


This will produce something like the following output, depending on your 
machine type and local configuration:


##### Generating Makefile with Relative Path:

	./../../../andy

making dependencies

./../../../andy/config/depend.csh /usr/local/bin/makedepend /usr/amos 
//usr/include/X11  "hc" /usr/amos/bin/class "-I.  -I/usr/amos/include/atk 
-I/usr/amos/include -I//usr/include/X11"

/usr/amos/bin/class -s -I.  -I.  -I/usr/amos/include/atk -I/usr/amos/include 
-I//usr/include/X11 daccon.ch

Adding new delimiting line "##### DEPENDENCY LINE - DO NOT DELETE #####"

Adding dependencies...

rm -f daccon.o

cc -c -I.  -g -I/usr/amos/include/atk -I/usr/amos/include -I//usr/include/X11 
  daccon.c

w "daccon.c",L85/C16:    self: Variable is set but is never referenced.

<Note: don't worry about warnings of unused variables that some compilers 
display> 

/usr/amos/bin/makedo -g -d /usr/amos/lib -b /usr/amos/bin -o daccon.do 
daccon.o

doindex: indexing daccon.do ...OK


The first part of this output (up through the \italic{Appending...} line) is 
the result of the shell scripts use of the \bold{genmake} program to create a 
new makefile. This should only occur the first time you run makedaccon. 
Subsequent runs will use the Makefile that this run created. 


If all goes well the result will be a .do file, which is the dynamic module 
that is loaded into the EZ editor to make the adc work. Now go back and run 


\bold{\indent{ez adc}}


Slide the controllers and watch it work. 


\subsection{3.3.1	Trouble Shooting}

If it doesn't work, try checking the following.


1. Is the CLASSPATH set? Type


printenv CLASSPATH


and see if it includes the current directory.  If not, see Setting Up above.

2. Did the daccon.do file get produced

3. Did you remember to save the change back into daccon.c


\subsection{3.3.2	Note}

An interesting side effect of running applications within the Ez editor is the 
fact that the editor may think that it needs to tell the user quitting the 
application that the file has changed and needs saving.  To prevent this, you 
can add the following 'magic' line to the start function. 


arbiterview_SetIgnoreUpdates(v,TRUE);


so that the code will read 


daccon_start(v,dat)

struct view *v;

 long dat;

\{

struct daccon *self;

if((self = FindSelf(v)) == NULL) return;

/* user code begins here for daccon_start */

arbiterview_SetIgnoreUpdates(v,TRUE);

/* user code ends here for daccon_start */

\}


\subsection{3.3.3	New Features

}
	In responce to user feedback, some new features have been added to Adew. 
These include the ability to create applications without control buttons and 
run them outside of the ez editor environment. It is also possible to use the 
page object create panels that switch between different sets of objects under 
application control.  For details on these and other advanced features, please 
see the Adew Reference Manual.


\subsection{3.3.4	Modifying the application

}
	As mentioned above, createcon will preserve user written code across 
different versions of the appication. To try this, go back to adc and add 
another slider whose value should be subtracted from the total of the other 
two. Then run createcon again and modify the call back. Adew was designed to 
make this sort of updating as easy as possible.


\begindata{bp,269747820}
\enddata{bp,269747820}
\view{bpv,269747820,70,0,0}
\chapter{4	Epilogue

}
This is the basic scheme behind creating ADEW applications.  Now that this one 
is working, try adding a switch to indicate to add or multiply.  Then think 
about how these tools might be useful to some application you've been thinking 
about.  A prototype perhaps.  Remember, applications are not limited to calls 
on value objects.  Since you have the pointer to all the objects, any of their 
methods and class procedures are available.  The text and simpletext methods 
for manipulating documents have proven particularly useful.  See the ATK 
documentation for a description of these and others.  To see more advanced 
applications, look in the ATK controllers directory.  These demo applications 
have been installed in $ANDREWDIR/lib/arbiters and may be run as follows


ez $ANDREWDIR/lib/arbiters/calc.lset


This is a simple calculator and probably the best source code to look at for 
information on creating more complex applications. 


ez  $ANDREWDIR/lib/arbiters/helparb


This is a prototype help application that scans the /usr/andrew/help directory 
and provides help.


ez $ANDREWDIR/lib/arbiters/piano.lset 


If you are running on an IBM RT or 6152, this piano inset will allow you to 
play music. It has the distinction of being the first piano ever known to be 
sent in a completely functional via electronic mail. (it can be viewed, run, 
and played in the messages program itself).


Enjoy.

\begindata{bp,268701924}
\enddata{bp,268701924}
\view{bpv,268701924,71,0,0}
\section{4.1	Appendix 1

}
\subsection{4.1.1	daccon.c }

<annotations added in angled brackets>


/* user code begins here for HeaderInfo */

< This is a good place for Copyright notices and the like >

/* user code ends here for HeaderInfo */

#include <andrewos.h>

#include <class.h>

#include <proctbl.ih>

#include <view.ih>

#include <arbiterv.ih>

#include <daccon.eh>

#include <celv.ih>

#include <controlv.ih>

#include <cel.ih>

#include <bargrphv.ih>

#include <sliderv.ih>

#include <value.ih>

/* user code begins here for includes */

<additional includes may be placed here, along with global definitions and 
static functions>

/* user code ends here for includes */


static struct daccon *firstdaccon;

static struct daccon *FindSelf(v)

struct view *v;

\{

	struct daccon *self,*last = NULL;

	struct arbiterview *arbv =arbiterview_FindArb(v);

	for(self= firstdaccon; self != NULL; self = self->next)\{

		if(self->arbv == arbv) return self;

		last = self;

		\}

	self = daccon_New();

	self->arbv = arbv;

	initself(self,v);

	if(last == NULL) firstdaccon = self;

	else last->next = self;

	arbiterview_AddObserver(self->arbv,self);

	return self;

\}

static void bgCallBack(self,val,r1,r2)

struct daccon *self;

struct value *val;

long r1,r2;

\{

if(r2 == value_OBJECTDESTROYED) \{

	if(self->bg == val) self->bg = NULL;

\}

\{

/* user code begins here for bgCallBack */

< callback for the bargraph. This application ignores it >

/* user code ends here for bgCallBack */

\}

\}

static void slCallBack(self,val,r1,r2)

struct daccon *self;

struct value *val;

long r1,r2;

\{

if(r2 == value_OBJECTDESTROYED) \{

	if(self->sl_0 == val) self->sl_0 = NULL;

	if(self->sl_1 == val) self->sl_1 = NULL;

\}

\{

/* user code begins here for slCallBack */

<slider call back. See above for details> 

/* user code ends here for slCallBack */

\}

\}

static initself(self,v)

struct daccon *self;

struct view *v;

\{   < this is where initialization happens >

	self->v = v;

	self->bgView = (struct bargraphV *)arbiterview_GetNamedView(v,"bg");

	self->bg = (struct value *)arbiterview_GetNamedObject(v,"bg");

	if(self->bg) value_AddCallBackObserver(self->bg, self,bgCallBack,0);

	if(self->bgView) bargraphV_AddObserver(self->bgView,self);

	self->sl_0View = (struct sliderV *)arbiterview_GetNamedView(v,"sl_0");

	self->sl_0 = (struct value *)arbiterview_GetNamedObject(v,"sl_0");

	if(self->sl_0) value_AddCallBackObserver(self->sl_0, self,slCallBack,0);

	if(self->sl_0View) sliderV_AddObserver(self->sl_0View,self);

	self->sl_1View = (struct sliderV *)arbiterview_GetNamedView(v,"sl_1");

	self->sl_1 = (struct value *)arbiterview_GetNamedObject(v,"sl_1");

	if(self->sl_1) value_AddCallBackObserver(self->sl_1, self,slCallBack,1);

	if(self->sl_1View) sliderV_AddObserver(self->sl_1View,self);

\}

daccon_start(v,dat)

struct view *v;

 long dat;

\{

struct daccon *self;

if((self = FindSelf(v)) == NULL) return;

/* user code begins here for daccon_start */

<This is the place for any code to be called whenever the start button is 
clicked

 The findself routine above is responsible for finding the self structure and 
insuring

 that the initialization code is run once for each arbiter or file >

/* user code ends here for daccon_start */

\}

void daccon__ObservedChanged(self,observed,status)

struct daccon *self;

struct observable * observed;

long status;

\{

/* user code begins here for ObservedChanged */

< User code that needs to be informed when objects other than the values 
change

  should be placed here >

/* user code ends here for ObservedChanged */

if(observed == (struct observable *) self->arbv)\{

	if (status == observable_OBJECTDESTROYED) self->arbv = NULL;

	 else initself(self,self->v);

\}

if (status == observable_OBJECTDESTROYED) \{

	if (observed == (struct observable *) self->bgView) self->bgView=NULL;

	if (observed == (struct observable *) self->sl_0View) self->sl_0View=NULL;

	if (observed == (struct observable *) self->sl_1View) self->sl_1View=NULL;

\}

\}

boolean daccon__InitializeClass(ClassID)

struct classheader *ClassID;

\{

struct classinfo *viewtype = class_Load("view");

firstdaccon = NULL;

proctable_DefineProc("daccon-start",daccon_start, viewtype,NULL,"daccon 
start");

/* user code begins here for InitializeClass */

< This is the place for code to be run once when the application is loaded, 
but before any of

the pointers are initialized >

/* user code ends here for InitializeClass */

return TRUE;

\}

void daccon__FinalizeObject(ClassID,self)

struct classheader *ClassID;

struct daccon *self;

\{

	if(self->bg) value_RemoveCallBackObserver(self->bg, self);

	if(self->sl_0) value_RemoveCallBackObserver(self->sl_0, self);

	if(self->sl_1) value_RemoveCallBackObserver(self->sl_1, self);

/* user code begins here for FinalizeObject */

< This code is called when the daccon is destroyed. In practice, this is 

  unlikely to happen in the current atk. >

/* user code ends here for FinalizeObject */

\}

boolean daccon__InitializeObject(ClassID,self)

struct classheader *ClassID;

struct daccon *self;

\{

self->bg = NULL;

self->bgView = NULL;

self->sl_0 = NULL;

self->sl_0View = NULL;

self->sl_1 = NULL;

self->sl_1View = NULL;

self->v = NULL;

self->next = NULL;

/* user code begins here for InitializeObject */

< If one plans to add other fields to the daccon structure, this is where they 
should be initialized>

< They will need to be declared in daccon.ch (see below) >

/* user code ends here for InitializeObject */

/* user code ends here for InitializeObject */

return TRUE;\}

/* user code begins here for Other Functions */

/* user code ends here for Other Functions */

 <if, by virtue of the user changing the source file, a value object gets its 
name changed 

so that Createcon no longer has a place to insert old code. It will add an 
#ifdef UNUSED_CODE

and place it at the bottom >


\begindata{bp,268693256}
\enddata{bp,268693256}
\view{bpv,268693256,72,0,0}
\section{4.2	Appendix 2}


\subsection{4.2.1	daccon.ch}

<annotations added in angled brackets>


/* user code begins here for HeaderInfo */

/* user code ends here for HeaderInfo */

class daccon : observable [observe] \{ 

classprocedures :

        InitializeClass() returns boolean;

	FinalizeObject(struct daccon *self);

	InitializeObject(struct daccon *self) returns boolean;

/* user code begins here for classprocedures */

<advanced ATK programmers may wish to define exported methods and 

/* user code ends here for classprocedures */

overrides:

	ObservedChanged( struct observable * observed, long status );	/* user code 
begins here for overrides */

/* user code ends here for overrides */

data:

	struct value *bg;

	struct bargraphV *bgView;

	struct value *sl_0;

	struct sliderV *sl_0View;

	struct value *sl_1;

	struct sliderV *sl_1View;

/* user code begins here for classdata */

<This is where additional user parameters may be defined. The end result is 
that they will be

available as struct pointers in the daccon array>

/* user code ends here for classdata */

	struct view *v;

	struct arbiterview *arbv;

	struct daccon *next;

\};

\enddata{text,268667792}
