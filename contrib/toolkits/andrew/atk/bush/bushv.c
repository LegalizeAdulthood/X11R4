/* ********************************************************************** *\
 *         Copyright IBM Corporation 1988,1989 - All Rights Reserved      *
 *        For full copyright information see:'andrew/config/COPYRITE'     *
\* ********************************************************************** */

/* $Header $ */
/* $Source $ */

#ifndef lint
static char *rcsidbushv_c = "$Header: /afs/andrew.cmu.edu/itc/sm/releases/X.V11R4/andrew/atk/bush/RCS/bushv.c,v 1.43 89/11/03 18:05:38 gk5g Exp $";
#endif

/**  SPECIFICATION -- External Facility Suite  *********************************

TITLE	The Bush View-object

MODULE	bushv.c

VERSION	0.0

AUTHOR	TC Peters & GW Keim
	Information Technology Center, Carnegie-Mellon University 

DESCRIPTION
	This is the suite of Methods that support the Bush View-object.

    NB: The comment-symbol "===" indicates areas which are:
	    1 - Questionable
	    OR
	    2 - Arbitrary
	    OR
	    3 - Temporary Hacks
    Such curiosities need be resolved prior to Project Completion...


HISTORY
  08/21/85	Created (TCP)
  01/15/89	Convert to ATK (GW Keim)
  05/01/89	Change aptcursors20 to aptcsr20 (TCP)
  05/19/89	Changed call to suite_WantUpdate() in PerformDetail() to
		    suite_Update() (GW Keim)
  05/23/89	Changed back the suite_Update() call to a WantUpdate();
		Found a NULL pointer indirection bug in 
		FormatEntriesItem() that manifested itself through
		PerformDetail(); (GW Keim)
  05/26/89	Changed the individual ControlView item suite_Specification 
	    	delcarations to static so that Bush will compile on a VAX 
		for wdc@athena; (GW Keim)
  06/06/89	Added chdir() calls to set the current-working-directory
		to be the current root node;
		Reformated bushv_FullUdpate();
		Changed the ControlView (suite) size to be larger vertically
		in order to make the button labels more visible. 
		As well, changed the ControlView Arrangement to Matrix
		from Row;
		Added check for auto-rescan possibility in 
		PushToEntries().  (GW Keim)
  06/11/89	Added static void HandleChangeDir() to replace calls to chdir().
		HandleChangeDir() makes a call to im_ChangeDirectory(); (GW Keim)
		Tweaked the ControlView size so that no extra whitespace shows at the right
		or bottom of the suite container; (GW Keim)
  06/21/89	Added code to Push() that Pop's the user back to the nodes_level if
                they select a directory in the entries_level;
                Added code to EntriesHitHandler() that checks to make sure that we
	        are still in the entries_level when we count and print the number of 
	        selected entries; (GW Keim)
  06/21/89	Added a TitleHitHandler attribute to the ControlView that sets the
		current-working-directory for the process to be the path shown in the title;
		Added a static void ControlTitleHitHandler() function to be called upon hits
		in the ControlView title area; (GW Keim)
  07/10/89	Set CurrEntry = NULL in PopToNodes(); this was causing the ControlView
                title to erroneously be set to a filename when at the nodes_level. (GW Keim)
  07/11/89	Changed Push() to behave properly when a entries_level directory entry
                is selected.
  07/14/89	Added support for mv'ing directories from the nodes_level.  Added routines
		StartDirMove() and FinishDirMove().  
		Added instance var, MoveNode; (GW Keim)
  07/19/89	Fix for core-dump generated by the last fix (7/14) that occurred when 
	              the user mouse clicked in the treev background;
		Added PostCursor() to obviate PostWaitCursor();
		Fixed failure of second-level display to properly set the current sort-mode
		during the overlay prompt for the new sort-mode; (GW Keim)
  07/28/89	Changed PushToEntries() to implement the new and better way of associating a 
		view/ApplicationLayer pair with a particular dataobject (entry);
		Also change each occurance of AptTree to just Tree; (GW Keim)
   07/31/89	Added call to view_WantInputFocus(EntryView,EntryView) to 
		 PushToEntry(); (GW Keim)
  08/01/89	Udpated the ControlView Title in PushToEntry(); (GW Keim)
  08/02/89	Added check for a rescan to PopToEntries(); (GW Keim)
   08/21/89	Made changes to PerformSystemAction() in an attempt to fix the bug that
                         causes the bush process to hang around until all its children are dead; (GW Keim)
  08/22/89	Changed PerformExit() to destroy the bushv and, if the bushv is TopLevel,
                        the im view.  The call the exit does kill the process; (GW Keim)
  08/25/89	Fixed problem with selected state in TreeHitHandler; (GW Keim)
  09/01/89	Added support for new suite_Sort() interface to 
	             SortBy{Name,Date,Size,Suffix,Type}; (GW Keim)
   09/08/89	Added EntryFilep instance variable to handle closing of a visited file properly
	             in PopToEntries();  
	             Changed instances of suite_ItemCaptionPlacement to 
	             suite_ItemCaptionAlignment; 
	             Changed DoPrint() to use ezprint;  (GW Keim)
  09/29/89	Changed the EntriesView caption font to andytype12;
		Gave the ControlView suite 6 more vertical pixels;
		Fixed bug in PerformDestroy() that bogusly attempted to passivate destroyed
		items after the PopToEntries() call already did an auto-rescan, removing those
		items.  This caused an occasional core dump;
		Replaced a call to PopToEntries() in PushToEntry() with an assignment
		Object = entries_object upon failure to open the entry;
		Added assignment CurrEntry = NULL in PopToNodes; (GW Keim)
  10/24/89	Now create directories with mode 0777;
		Fix for bug wherein moving a directory to a point "lower" in the filestructure
		caused bogus visuals (this was a combination of a tree & bush bug; (GW Keim)
		Set CurrNode to NULL when its ancestor is moved because it's destroyed 
		in the process;
  10/25/89	Added checks in PerformEdit, PerformExec, and PerformPrint to make sure
                that in the entries_level these actions are only performed on files and
                not directories; (GW Keim)

END-SPECIFICATION  ************************************************************/

#include <stdio.h>
#include <andrewos.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <ctype.h>
#include <sys/wait.h>
#include <errno.h>
#include <rect.h>
#include <apt.h>
#include <class.h>
#include <dataobj.ih>
#include <keystate.ih>
#include <keymap.ih>
#include <filetype.ih>
#include <environ.ih>
#include <fontdesc.ih>
#include <proctbl.ih>
#include <menulist.ih>
#include <cursor.ih>
#include <im.ih>
#include <view.ih>
#include <lpair.ih>
#include <scroll.ih>
#include <suite.ih>
#include <text.ih>
#include <textv.ih>
#include <tree.ih>
#include <treev.ih>
#include <frame.ih>
#include <bush.ih>
#include <bushv.eh>

#define		by_name					    0
#define		by_size					    1
#define		by_date					    2
#define		by_suffix				    3
#define		by_type					    4

#define		nodes_object				    1
#define		entries_object				    2
#define		entry_object				    4

static char	*sorts[] = { "Name", 
			     "Size", 
			     "Date", 
			     "Suffix", 
			     "Type", 
			      NULL };


static char	*default_editor_choices[] = { "ez",
					      "emacs",
					      "gnu-emacs",
					      "zip",
					      "raster",
					      "table",
					       NULL};

static char			    msg[MAXPATHLEN * 2];
static char			    cmd[MAXPATHLEN * 2];
static char			   *argv[10];
extern int			    errno, sys_nerr;
extern char			   *sys_errlist[];

static struct keymap		   *kmap;
static struct menulist		   *menulist = NULL;

static void			    Pop(),
				    PerformExit(),
				    PerformExec(),
				    PerformPrint(),
				    PerformSort(),
				    PerformPop(),
				    PerformDetail(),
				    PerformDestroy(),
				    PerformCreate(),
				    PerformRename(),
				    PerformRescan(),
				    PerformEdit(),
				    PopToNodes(),
                                    PopToEntries(),
                                    PushToEntries(),
                                    PushToEntry(),
				    SetEditor(),
				    SwitchDirectory(),
				    Push(),
				    PassivateControls(),
				    IssueError(),
				    ToggleDebug(),
                                    HandleChangeDir();


static long			    ControlHitHandler(), 
				    TreeHitHandler(), 
				    EntriesHitHandler();

int				    SortByName(),
				    SortBySize(),
				    SortBySuffix(),
				    SortByType(),
				    SortByDate();

#define Bush			    (self->bush)
#define ControlView		    (self->control_view)
#define	EntriesView		    (self->entries_view)
#define DirTreeView		    (self->dir_tree_view)
#define EntryView		    (self->entry_view)
#define	EntryViewAppLayer	    (self->entry_view_application_layer)
#define	EntryObject		    (self->entry)
#define	EntryFilep		    (self->entry_filep)
#define NumPrevSelected		    (self->num_prev_selected)
#define LP			    (self->lp)
#define SortMode		    (self->sortmode)
#define Object			    (self->object)
#define Kmap			    (self->kmap)
#define Kstate			    (self->keyState)
#define Menulist		    (self->menulist)
#define InitNode		    (self->initial_node)
#define CurrNode		    (self->current_node)
#define	MoveNode		    (self->move_node)
#define CurrEntry		    (self->current_entry)
#define Cursor			    (self->cursor)
#define	Detail			    (self->detail)
#define TopLevelInset		    (self->top_level_inset)
#define IgnoreFullUpdate	    (self->ignore_fullupdate)
#define Debug			    (self->debug)
#define	EditorProgram		    (self->editor_program)
#define EditorChoices		    (self->editor_choices)
#define EditorIndex		    (self->editor_index)
#define Selected(entry)		    ((entry)->mode.selected)
#define DirType(entry)		    ((entry)->type.dir)
#define LinkType(entry)		    ((entry)->type.soft_link)
#define DirPerms(entry)		    ((entry)->permissions)

#define SetTreeNotificationCode(self,code) \
    tree_SetNotificationCode(bush_Tree(Bush),code)
#define SetTreeNotificationNode(self,node) \
    tree_SetNotificationNode(bush_Tree(Bush),node)
#define SetTreeNotificationData(self,node,code) \
    SetTreeNotificationNode(self,node);SetTreeNotificationCode(self,code)
#define NotifyTreeObservers(self) \
    tree_NotifyObservers(bush_Tree(Bush),NULL)

#define ClearFrameBuffer(self)		    bushv_Announce(self,"")

static suite_Specification edit[] =		{ suite_ItemCaption("Edit"), 
    suite_ItemDatum(6), 0 };
static suite_Specification exec[] =		{ suite_ItemCaption("Exec"), 
    suite_ItemDatum(6), 0 };
static suite_Specification print[] =		{ suite_ItemCaption("Print"), 
    suite_ItemDatum(7), 0 };
static suite_Specification editor[] =		{ suite_ItemCaption("Editor"), 
    suite_ItemDatum(7), 0 };
static suite_Specification sort[] =		{ suite_ItemCaption("Sort"), 
    suite_ItemDatum(3), 0 };
static suite_Specification pop[] =		{ suite_ItemCaption("Pop"), 
    suite_ItemDatum(6), 0 };
static suite_Specification detail[] =		{ suite_ItemCaption("Detail"), 
    suite_ItemDatum(3), 0 };
static suite_Specification destroy[] =	{ suite_ItemCaption("Destroy"), 
    suite_ItemDatum(7), 0 };
static suite_Specification Switch[] =		{ suite_ItemCaption("Switch"), 
    suite_ItemDatum(7), 0 };
static suite_Specification rescan[] =		{ suite_ItemCaption("ReScan"), 
    suite_ItemDatum(7), 0 };
static suite_Specification create[] =		{ suite_ItemCaption("Create"), 
    suite_ItemDatum(3), 0 };
static suite_Specification rename_it[] =	{ suite_ItemCaption("ReName"), 
    suite_ItemDatum(7), 0 };

suite_Specification control_spec[] = {
    suite_TitleCaption( "Bush: A FileSystem Browser" ),
    suite_TitlePlacement( suite_Top ),
    suite_TitleCaptionFontName( "AndySans10" ),
    suite_TitleBorderStyle( suite_Rectangle ),
    suite_Item(edit),
    suite_Item(editor),
    suite_Item(exec),
    suite_Item(print),
    suite_Item(pop),
    suite_Item(Switch),
    suite_Item(sort),
    suite_Item(detail),
    suite_Item(create),
    suite_Item(destroy),
    suite_Item(rescan),
    suite_Item(rename_it),
    suite_ItemCaptionFontName( "AndySans10b" ),
    suite_TitleBorderSize( 2 ),
    suite_GutterSize( 3 ),
    suite_BorderSize( 3 ),
    suite_ItemOrder( suite_ColumnMajor ),
    suite_Arrangement( suite_Matrix ),
    suite_SelectionMode( suite_Exclusive ),
    suite_HitHandler( ControlHitHandler ),
    NULL
};

suite_Specification entries_spec[] = {
    suite_TitleCaption( "Entries" ),
    suite_TitleBorderSize( 2 ),
    suite_TitleBorderStyle( suite_Rectangle ),
    suite_BorderStyle( suite_None ),
    suite_Arrangement( suite_List | suite_Matrix | suite_Unbalanced | suite_ColumnLine ),
    suite_HorizontalGutterSize( 3 ),
    suite_ItemOrder( suite_ColumnMajor ),
    suite_ItemCaptionFontName( "AndyType12f" ),
    suite_TitleFontName( "Andy10" ),
    suite_ItemCaptionAlignment( suite_Left | suite_Center ),
    suite_ItemBorderSize( 0 ),
    suite_ItemBorderStyle( suite_Invisible ),
    suite_VerticalGutterSize( 0 ), 
    suite_SelectionMode( suite_Inclusive ),
    suite_SortHandler( SortByName ),
    suite_Scroll( suite_Left ),
    suite_HitHandler( EntriesHitHandler ),
    suite_CursorFontName( "aptcsr20" ),
    suite_Cursor( 'c' ),
    NULL
};

treev_Specification tree_spec[] = {
    treev_NodeConnectorStyle( treev_Fold | treev_DogLeg ), 
    treev_NodeFiligree( treev_DropShadow ),
    treev_NodeHighlightStyle( treev_Invert ),
    treev_Scroll( treev_Left ),
    treev_BackgroundShade( 50 ),
    treev_Cursor( 'z' ),
    treev_CursorFontName( "aptcsr20" ),
    treev_HitHandler( TreeHitHandler ),
    NULL };

static void
AllocNameSpace( target, source )
    char	**target, *source;
{
    if(target && *target) free(*target);
    if(source && *source) strcpy(*target = malloc(strlen(source)+1),source);
    else if(!source) *target = NULL;
}

static void
PostCursor( self, type )
    struct bushv	*self;
    int			 type;
{
    struct rectangle	 r;

    bushv_GetVisualBounds(self,&r);
    cursor_SetStandard(Cursor,type);
    bushv_PostCursor(self,&r,Cursor);
}

static long
ResetSelectedState( self, suite, item, datum )
    struct bushv		*self;
    struct suite		*suite;
    struct suite_item		*item;
    unsigned			 datum;
/*  Called by static void EntriesHitHandler().
    Resets the Dir_Entry mode flag, associated with each suite_item, to 
    correspond with the items that are currently highlighted in the suite 
    (entries_object). We do this after the check for Pop conditions because we 
    need to determine the number of items previously highlighted for that check. */
{
    register struct Dir_Entry	*DirEntry = NULL;
    register long int		 status = 0;

    if(!suite || !item) return(status);
    DirEntry = (struct Dir_Entry*)suite_ItemAttribute(suite,item,suite_ItemDatum(0));
    if(!suite_ItemExposed(suite,item) || !suite_ItemHighlighted(suite,item) || 
	!suite_ItemActivated(suite,item)) 
	    Selected(DirEntry) = FALSE;
    else Selected(DirEntry) = TRUE;
    return(status);
}

static long
EntriesHitHandler( self, suite, item, object, action, x, y, numClicks )
    register struct bushv		    *self;
    register struct suite		    *suite;
    register struct suite_item		    *item;
    register long			     object;
    register enum view_MouseAction	     action;
    register long			     x, y, numClicks;
{
    register struct Dir_Entry	    *DirEntry = NULL;
    register int		     numSelected = 0, count = 0, i = 0;

    IN(EntriesHitHandler);
    ClearFrameBuffer(self);
    if((object == suite_ItemObject) && item && 
	((action == view_LeftUp) || (action == view_RightUp))) {
	if(action == view_LeftUp) {
	    CurrEntry = DirEntry = (struct Dir_Entry*) 
	      suite_ItemAttribute(EntriesView,item,suite_ItemDatum(0));
	    if(Selected(DirEntry) && (NumPrevSelected == 1)) {
		PostCursor(self,Cursor_Wait);
		Push(self);
		bushv_RetractCursor(self,Cursor);
	    }
	}
	suite_Apply(suite,ResetSelectedState,self,NULL);
	if(bush_DirEntries(Bush,CurrNode)) {
	    count = bush_DirEntriesCount(Bush,CurrNode);
	    for( i = 0 ; i < count ; i++ )
		if(bush_DirEntryMode(Bush,CurrNode,i).selected) numSelected++;
	}
	NumPrevSelected = numSelected;
	if(Object == entries_object) { /* may have Pop'ed back to nodes */
	    if((numSelected > 1) || (numSelected == 0)) 
		sprintf(msg,"%d entries currently selected",numSelected);
	    else sprintf(msg,"1 entry selected");
	    bushv_Announce(self,msg);
	}
    }
    OUT(EntriesHitHandler);
    return(0);
}

static void
StartDirMove( self, tn )
    struct bushv    *self;
    tree_type_node   tn;
{
    IN(StartDirMove);
    if(tn) {
	PostCursor(self,Cursor_Gunsight);
	sprintf(msg,"Moving directory '%s'...",bush_DirName(Bush,tn));
	bushv_Announce(self,msg);
    }
    else bushv_Announce(self,"No selected directory to move.");
    OUT(StartDirMove);
}

static int
FinishDirMove( self, tn )
    register struct bushv	    *self;
    register tree_type_node	     tn;
{
    register int		     status = 0;
    char			     finalLocation[MAXPATHLEN];

    IN(FinishDirMove);
    PostCursor(self,Cursor_Wait);
    if(!MoveNode) status = -1;
    else if(!tn) {
	sprintf(msg,"No target selected. Move operation cancelled.");
	bushv_Announce(self,msg);
	status = -1;
    }
    else if(tn == MoveNode) {
	sprintf(msg,"Cancelled.");
	bushv_Announce(self,msg);
	status = -1;
    }
    else if(tree_NodeAncestor(bush_Tree(Bush),MoveNode,tn)) {
	sprintf(msg,"You cannot move a directory to one of its children.");
	bushv_Announce(self,msg);
	status = -1;
    }
    else if(tn == bush_Parent(Bush,MoveNode)) {
	sprintf(msg,"'%s' already lives under '%s'",
		bush_DirName(Bush,MoveNode),bush_DirName(Bush,tn));
	bushv_Announce(self,msg);
	status = -1;
    }
    else {
	sprintf(msg,"Moving '%s' under '%s'",bush_DirName(Bush,MoveNode),
		bush_DirName(Bush,tn));
	bushv_Announce(self,msg);
	sprintf(finalLocation,"%s/%s",bush_DirPath(Bush,tn),
		bush_DirName(Bush,MoveNode));
	if(status = rename(bush_DirPath(Bush,MoveNode),finalLocation)) {
 	    IssueError(self,"Moving",bush_DirName(Bush,MoveNode),TRUE);
	    sprintf(msg,"Move failed.");
	    bushv_Announce(self,msg);
	}
	else {
 	    if(tree_NodeLevel(bush_Tree(Bush),CurrNode) >= 
 	       tree_NodeLevel(bush_Tree(Bush),MoveNode)) CurrNode = NULL;
	    SetTreeNotificationData(self,MoveNode,tree_NodeDestroyed);
	    NotifyTreeObservers(self);
	    tree_DestroyNode(bush_Tree(Bush),MoveNode);
	    sprintf(msg,"Move succeeded.");
	    bushv_Announce(self,msg);
	}
    }
    bushv_RetractCursor(self,Cursor);
    OUT(FinishDirMove);
    return(status);
}

static long
TreeHitHandler( self, tree_view, node, object, action, x, y, numClicks )
    register struct bushv		*self;
    register struct treev		*tree_view;
    register tree_type_node		 node;
    register long			 object;
    register enum view_MouseAction	 action;
    register long			 x, y, numClicks;
{
    register tree_type_node		old_CurrNode = NULL;
    register tree_type_node		peer = NULL;
    struct stat				stats;

    IN(TreeHitHandler);
    if(object == treev_NodeObject) {
	if(node) treev_HighlightNode(tree_view,node);
	if(action == view_RightDown) {
	    MoveNode = node;
	    StartDirMove(self,node);
	    return 0;
	}
	else if(action == view_RightUp) {
	    if(FinishDirMove(self,node)) {
		treev_HighlightNode(tree_view,CurrNode);
		MoveNode = NULL;
		return 0;
	    }
	    MoveNode = NULL;
	    bush_DirMode(Bush,node).do_rescan = TRUE;
	}
	else if(action != view_LeftUp || !node) return 0;
	ClearFrameBuffer(self);
	PostCursor(self,Cursor_Wait);
	if(stat(bush_DirPath(Bush,node),&stats)) {
	    bush_DirMode(Bush,node).stat_failed = TRUE;
	    IssueError(self,"Scanning",bush_DirName(Bush,node),TRUE);
	    bushv_RetractCursor(self,Cursor);
	    return 0;
	}
	old_CurrNode = CurrNode;
	CurrNode = node;
	if(bush_Parent(Bush,CurrNode)) 
	    peer = bush_Child(Bush,bush_Parent(Bush,CurrNode));
	else peer = CurrNode;
	if(!bush_DirMode(Bush,CurrNode).selected || (action == view_RightUp)) {
	    if(old_CurrNode) {
		bush_DirMode(Bush,old_CurrNode).selected = FALSE;
		old_CurrNode = NULL;
	    }
	    while(peer) {
		if(bush_Child(Bush,peer)) {
		    SetTreeNotificationData(self,peer,
			    tree_NodeChildrenDestroyed);
		    NotifyTreeObservers(self);
		    bush_DestroySubDirs(Bush,peer);
		    break;
		}
		peer = bush_Right(Bush,peer);
	    }
	    bush_DirMode(Bush,CurrNode).selected = TRUE;
	    if(bush_ScanRequired(Bush,CurrNode)) {
		sprintf(msg,"Scanning '%s' ...",bush_DirName(Bush,CurrNode));
		bushv_Announce(self,msg);
		im_WantUpdate(bushv_GetIM(self),self);
		bush_ScanDir(Bush,CurrNode);
		ClearFrameBuffer(self);
	    }
	    bush_BuildSubDirs(Bush,CurrNode);
	    SetTreeNotificationData(self,CurrNode,tree_NodeChildrenCreated);
	    NotifyTreeObservers(self);
	    suite_ChangeSuiteAttribute(ControlView,
				       suite_TitleCaption(bush_DirPath(Bush,CurrNode)));
	}
	else Push(self);
	bushv_RetractCursor(self,Cursor);
    }
    OUT(TreeHitHandler);
    return(0);
}

static long
ControlHitHandler( self, suite, item, object, action, x, y, numClicks )
    register struct bushv		*self;
    register struct suite		*suite;
    register struct suite_item	        *item;
    register long			 object;
    register enum view_MouseAction	 action;
    register long			 x, y, numClicks;
{
    IN(ControlHitHandler);

    ClearFrameBuffer(self);
    if((action == view_LeftUp) || (action == view_RightUp)) {
	if(object == suite_ItemObject){
	  register char			*caption = (char*)
	    suite_ItemAttribute(suite,item,suite_ItemCaption(0));

	    if(!strcmp(caption,"Edit"))	    PerformEdit(self);
	    else if(!strcmp(caption,"Exec"))    PerformExec(self);
	    else if(!strcmp(caption,"Print"))   PerformPrint(self);
	    else if(!strcmp(caption,"Sort"))    PerformSort(self);
	    else if(!strcmp(caption,"Destroy")) PerformDestroy(self);
	    else if(!strcmp(caption,"ReScan"))  PerformRescan(self);
	    else if(!strcmp(caption,"Create"))  PerformCreate(self);
	    else if(!strcmp(caption,"Exit"))    PerformExit(self);
	    else if(!strcmp(caption,"Pop"))	    PerformPop(self);
	    else if(!strcmp(caption,"Detail"))  PerformDetail(self);
	    else if(!strcmp(caption,"ReName"))  PerformRename(self);
	    else if(!strcmp(caption,"Editor"))  SetEditor(self);
	    else if(!strcmp(caption,"Switch"))  SwitchDirectory(self);
	    PassivateControls(self);
	}
	else if(object == suite_TitleObject) {
	    suite_HighlightTitle(suite);
	    PostCursor(self,Cursor_Wait);
	    HandleChangeDir(self,bush_DirPath(Bush,CurrNode));
	    sleep(1);
	    bushv_RetractCursor(self,Cursor);
	    sprintf(msg,"Working directory changed to '%s'",
		    bush_DirPath(Bush,CurrNode));
	    bushv_Announce(self,msg);
	    suite_NormalizeTitle(suite);
	}
	else if(object == suite_NoObject) {
	    PassivateControls(self);
	    if(suite_CurrentItem(suite)) 
		suite_PassivateItem(suite,suite_CurrentItem(suite));
	}	
    }
    OUT(ControlHitHandler);
    return(0);
}

static char *
FileSuffix( file_name )
    register char   *file_name;
{
    register char   *suffix;

    if(suffix = (char*)rindex(file_name,'.')) suffix++;
    else suffix = file_name + strlen(file_name);
    return(suffix);
}

static char *
FileType( file_name )
    register char	*file_name;
{
    static char		*suffixes[] = {"BAK","CKP",0};
    register char	*suffix, **suffix_ptr;

    suffix = (char*)rindex(file_name,'.');
    if(!suffix) return(file_name + strlen(file_name));
    suffix++;
    suffix_ptr = suffixes;
    while(*suffix_ptr) {
	if(!strcmp(suffix,*suffix_ptr)) {
	    *(suffix-1) = '\0';
	    return(FileSuffix(file_name));
	}
	suffix_ptr++;
    }
    return(suffix);
}

int
SortByName( self, suite, e1, e2 )
    register struct bushv	   *self;
    register struct suite	   *suite;
    register struct suite_item     *e1,*e2;
{
    register struct Dir_Entry	    *a = NULL, *b = NULL;
    register long		     status = 0;

    if(!e1 || !e2) return(0);
    a = (struct Dir_Entry*)suite_ItemAttribute(suite,e1,suite_ItemDatum(0));
    b = (struct Dir_Entry*)suite_ItemAttribute(suite,e2,suite_ItemDatum(0));
    if(a && b) { 
	status = strcmp(a->name,b->name);
	if(status < 0) return(-1);
	else if(status > 0) return(1);
    }
    return(0);
}

int
SortBySuffix( self, suite, e1, e2 )
    register struct bushv	   *self;
    register struct suite	   *suite;
    register struct suite_item     *e1,*e2;
{
    register struct Dir_Entry	    *a = NULL, *b = NULL;
    register long		     rc;


    if(!e1|| !e2) return(0);
    a = (struct Dir_Entry*)suite_ItemAttribute(suite,e1,suite_ItemDatum(0));
    b = (struct Dir_Entry*)suite_ItemAttribute(suite,e2,suite_ItemDatum(0));
    if(a && b)
	if(!(rc = strcmp(FileSuffix(a->name),FileSuffix(b->name)))) {
	    rc = strcmp(a->name,b->name);
	    if(rc > 0) return(1);
	    else if(rc < 0) return(-1);
	}
	else {
	    if(rc > 0) return(1);
	    else if(rc < 0) return(-1);
	}
    return(0);
}

int
SortBySize( self, suite, e1, e2 )
    register struct bushv	   *self;
    register struct suite	   *suite;
    register struct suite_item     *e1,*e2;
{
    register struct Dir_Entry	  *a = NULL, *b = NULL;

    if(!e1 || !e2) return(0);
    a = (struct Dir_Entry*)suite_ItemAttribute(suite,e1,suite_ItemDatum(0));
    b = (struct Dir_Entry*)suite_ItemAttribute(suite,e2,suite_ItemDatum(0));
    if(a && b) {
	if(a->size < b->size) return(1);
	else if(a->size > b->size) return(-1);
    }
    return(0);
}

int
SortByDate( self, suite, e1, e2 )
    register struct bushv	   *self;
    register struct suite	   *suite;
    register struct suite_item     *e1,*e2;
{
    register struct Dir_Entry	  *a = NULL, *b = NULL;

    if(!e1 || !e2) return(0);
    a = (struct Dir_Entry*)suite_ItemAttribute(suite,e1,suite_ItemDatum(0));
    b = (struct Dir_Entry*)suite_ItemAttribute(suite,e2,suite_ItemDatum(0));
    if(a && b) {
	if(a->time_stamp < b->time_stamp) return(1);
	if(a->time_stamp > b->time_stamp) return(-1);
    }
    return(0);
}

int
SortByType( self, suite, e1, e2 )
    register struct bushv	   *self;
    register struct suite	   *suite;
    register struct suite_item     *e1,*e2;
{
    register struct Dir_Entry	  *a = NULL, *b = NULL;
    char			   n1[MAXPATHLEN+1], n2[MAXPATHLEN+1];
    register long		   rc;

    if(!e1 || !e2) return(0);
    a = (struct Dir_Entry*)suite_ItemAttribute(suite,e1,suite_ItemDatum(0));
    b = (struct Dir_Entry*)suite_ItemAttribute(suite,e2,suite_ItemDatum(0));
    if(a && b) {
	strcpy(n1,a->name);
	strcpy(n2,b->name);
	if(!(rc = strcmp(FileType(n1),FileType(n2)))) {
	    rc = strcmp(a->name,b->name);
	    if(rc < 0) return(-1);
	    else if(rc > 0) return(1);
	}
	else {
	    if(rc < 0) return(-1);
	    else if(rc > 0) return(1);
	}
    }
    return(0);
}

boolean
bushv__InitializeClass( ClassID )
    struct classheader	    *ClassID;
{
    struct proctable_Entry  *tempProc = NULL;

    kmap = keymap_New();
    menulist = menulist_New();
    tempProc = proctable_DefineProc("bushv-exit",PerformExit, 
		&bushv_classinfo,NULL,"Exit Bush.");
    menulist_AddToML(menulist,"Quit~70",tempProc,NULL,NULL);
    tempProc = proctable_DefineProc("bushv-DEBUG",ToggleDebug, 
		&bushv_classinfo,NULL,"Toggle Bush debug flag.");
    return(TRUE);
}

static void
StripWhiteSpace( target, source )
    register char	**target, *source;
{
    register long	  i = 0, j = 0;

    AllocNameSpace(target,source);
    while(source[i]) {
	if(source[i] != ' ') (*target)[j++] = source[i];
	i++;
    }
    (*target)[j] = '\0';
}

static void
GetPreferredEditors( self )
    struct bushv	 *self;
{
    register char	 *tmp = NULL, *colon = NULL;
    char		 *myCopy = NULL;
    register int	  i = 0;

    IN(GetPreferredEditors);
    environ_SetProgramName("bush");
    if(((tmp = environ_GetProfile("editors")) ||
        (tmp = environ_GetProfile("editor"))) && *tmp) {
	    StripWhiteSpace(&myCopy,tmp);
	    if(colon = (char*)index(tmp = myCopy,':')) {
		while((colon = (char*)index(tmp,':')) && (i < MAXEDITORS)) {
		    *colon = '\0';
		    if(tmp && (*tmp != '\0')) {
			EditorChoices[i] = NULL;
			AllocNameSpace(&EditorChoices[i++],tmp);
		    }
		    tmp = colon + 1;
		}
		if(tmp && (*tmp != '\0') && (i < MAXEDITORS)) {
		    EditorChoices[i] = NULL;
		    AllocNameSpace(&EditorChoices[i],tmp);
		    EditorChoices[i+1] = NULL;
		}
		else if(i >= MAXEDITORS)
		    fprintf(stderr,"bush: too many editors in preference.\n");
	    }
	    else if(tmp && (*tmp != '\0')) {
		EditorChoices[0] = NULL;
		AllocNameSpace(&EditorChoices[0],myCopy);
		EditorChoices[i+1] = NULL;
	    }
	    if(myCopy) free(myCopy);
    }
    if(i == 0) {
	for( i = 0 ; default_editor_choices[i] && (i < MAXEDITORS); i++ ) {
	    EditorChoices[i] = NULL;
	    AllocNameSpace(&EditorChoices[i],default_editor_choices[i]);
	}
	EditorChoices[i] = NULL;
    }
    EditorIndex = 0;
    strcpy(EditorProgram,EditorChoices[0]);
    OUT(GetPreferredEditors);
}

static void
GetPreferredFont( self )
    struct bushv	*self;
{
    register char	*tmp = NULL;

    IN(GetPreferredFont);
    if((tmp = environ_GetProfile("bodyfont")) && *tmp) {
	suite_SetSuiteAttribute(ControlView,
	    suite_TitleFontName( tmp ));
	suite_SetSuiteAttribute(ControlView,suite_TitleCaptionFontHigh(0));
	suite_SetSuiteAttribute(ControlView,
	    suite_ItemCaptionFontName( tmp ));
	suite_SetSuiteAttribute(ControlView,suite_ItemCaptionFontHigh(0));
	suite_SetSuiteAttribute(EntriesView,suite_TitleFontName( tmp ));
	suite_SetSuiteAttribute(EntriesView,suite_TitleCaptionFontHigh(0));
	suite_SetSuiteAttribute(EntriesView,suite_ItemCaptionFontName( tmp ));
	suite_SetSuiteAttribute(EntriesView,suite_ItemCaptionFontHigh(0));
/*
	treev_SetAttribute(DirTreeView, treev_NodeFontName( tmp ));
*/
    }
    OUT(GetPreferredFont);
}

static void
GetPreferences( self )
    struct bushv	*self;
{
    IN(GetPreferences);
    GetPreferredEditors(self);
    GetPreferredFont(self);
    OUT(GetPreferences);
}

boolean
bushv__InitializeObject( ClassID, self )
    struct classheader	*ClassID;
    struct bushv	*self;
{

    Kmap = kmap;
    if(!(Kstate = keystate_Create(self,Kmap))) {
	fprintf(stderr,"bushv: could not create keystate.\n");
	exit(1);
    }
    Cursor = cursor_Create(self);
    cursor_SetStandard(Cursor,Cursor_Wait);
    Bush = NULL;
    CurrNode = InitNode = MoveNode = NULL;
    CurrEntry = NULL;
    EntryView = EntryViewAppLayer = NULL;
    EntryObject = NULL;
    EntryFilep = NULL;
    ControlView = suite_Create(control_spec,self);
    EntriesView = suite_Create(entries_spec,self);
    DirTreeView = treev_Create(tree_spec,self);
    LP = lpair_New();
    lpair_VTFixed(LP,(struct view*)ControlView,(struct view*)DirTreeView,90,TRUE);
    lpair_LinkTree(LP,(struct view*)self);
    Object = nodes_object;
    SortMode = 0;
    Detail = 0;
    NumPrevSelected = 0;
    Debug = 1;
    Menulist = menulist_DuplicateML(menulist,self);
    GetPreferences(self);
    bushv_SetOptions(self,aptv_SuppressControl | aptv_SuppressBorder);
    TopLevelInset = TRUE;
    IgnoreFullUpdate = FALSE;
    OUT(bushv_InitializeObject);
    return(TRUE);
}

void
bushv__FinalizeObject( ClassID, self )
    struct classheader	*ClassID;
    struct bushv	*self;
{
    IN(bushv_FinalizeObject);
    if(LP)	    lpair_Destroy(LP);
    if(ControlView) suite_Destroy(ControlView);
    if(EntriesView) suite_Destroy(EntriesView);
    if(DirTreeView) treev_Destroy(DirTreeView);
    if(EntryView)   view_Destroy(EntryView);
    if(EntryObject) dataobject_Destroy(EntryObject);
    OUT(bushv_FinalizeObject);
}

struct bushv *
bushv__Create( ClassID, object )
    struct classheader	*ClassID;
    char		 object;
{
    struct bushv	*self = NULL;

    if(self = bushv_New()) Object = object;
    OUT(bushv_Create);
    return(self);
}

void
bushv__PostMenus( self, menulist )
    struct bushv	*self;
    struct menulist	*menulist;
{
    IN(bushv_PostMenus);
    menulist_ClearChain(Menulist);
    if(menulist) menulist_ChainBeforeML(Menulist,menulist,NULL);
    super_PostMenus(self,Menulist);
    OUT(bushv_PostMenus);
}

struct view *
bushv__Hit( self, action, x, y, numberOfClicks )
    struct bushv	    *self;
    enum view_MouseAction    action;
    long		     x, y, numberOfClicks;
{
    IN(bushv_Hit);
    return(lpair_Hit(LP,action,x,y,numberOfClicks));
}

void
bushv__FullUpdate( self, Type, left, top, width, height )
    struct bushv	    *self;
    enum view_UpdateType     Type;
    long		     left, top, width, height;
{
    struct rectangle	     r;
    char		     RootPathIfInset[MAXPATHLEN];
    char		     NewTitle[MAXPATHLEN];

    IN(bushv_FullUpdate);
    if(!IgnoreFullUpdate && 
       (Type == view_LastPartialRedraw || Type == view_FullRedraw)) {
	super_FullUpdate(self,Type,left,top,width,height);
	if(!bush_RootPathName(Bush)) {
	    im_GetDirectory(RootPathIfInset);
	    bush_InitTree(Bush,RootPathIfInset);
	    CurrNode = InitNode = bush_TreeRoot(Bush);
	    bush_BuildSubDirs(Bush,bush_TreeRoot(Bush));
	    HandleChangeDir(self,bush_RootPathName(Bush));
	}
	bushv_GetVisualBounds(self,&r);
	bushv_SetTransferMode(self,graphic_WHITE);
	bushv_FillRect(self,&r,bushv_WhitePattern(self));
	lpair_InsertView(LP,(struct view*)self,&r);
	bushv_SetTransferMode(self,graphic_BLACK);
	lpair_FullUpdate(LP,Type,0,0,r.width,r.height);
	if(CurrNode || (CurrNode = treev_CurrentNode(DirTreeView))) {
	    sprintf(NewTitle,"%s%s%s",bush_DirPath(Bush,CurrNode),
		    CurrEntry ? "/" : "", CurrEntry ? CurrEntry->name : "");
	    suite_ChangeSuiteAttribute(ControlView,
		suite_TitleCaption(NewTitle));
	}
	else 
	    suite_ChangeSuiteAttribute(ControlView,"No Current Directory");
	PassivateControls(self);
	ClearFrameBuffer(self);
    }
    IgnoreFullUpdate = false;
    OUT(bushv_FullUpdate);
}

static void
DoEdit( self, path, name )
    struct bushv	*self;
    char		*path, *name; 
{
    char		 full_path[MAXPATHLEN * 2];

    IN(DoEdit);
    sprintf(full_path,"%s/%s",path,name);
    sprintf(msg,"%s '%s/%s'",EditorProgram,path,name);
    argv[0] = EditorProgram;
    argv[1] = full_path;
    argv[2] = NULL;
    PerformSystemAction(self,EditorProgram,argv,msg);
    OUT(DoEdit);
}

static void
PerformEdit( self )
    struct bushv	*self;
{
    register int	 i = 0;

    IN(PerformEdit);
    if(!CurrEntry) return;
    PostCursor(self,Cursor_Wait);
    switch(Object) {
	case nodes_object: 
	    break;
	case entries_object:
	    if(CurrNode && bush_DirEntries(Bush,CurrNode) &&
		(bush_DirEntriesCount(Bush,CurrNode) >= 0))
		    for(i=0;i<bush_DirEntriesCount(Bush,CurrNode);i++)
			if(bush_DirEntryMode(Bush,CurrNode,i).selected &&
			   !bush_DirEntryType(Bush,CurrNode,i).dir)
			    DoEdit(self,bush_DirPath(Bush,CurrNode), 
				bush_DirEntryName(Bush,CurrNode,i));
	    break;
	case entry_object:
	    DoEdit(self,bush_DirPath(Bush,CurrNode),CurrEntry->name);
	    break;
    }
    bushv_RetractCursor(self,Cursor);
    OUT(PerformEdit);
}

static void
PerformPrint( self )
    struct bushv	*self;
{
    register int	 i = 0;
    register FILE	*file = NULL;

    IN(PerformPrint);
    PostCursor(self,Cursor_Wait);
    switch(Object) {
	case nodes_object: 
	    if(file = fopen("/tmp/bush_print.PS","w")) {
		treev_Print(DirTreeView,file,"postscript","postscript",1);
		fclose(file);
		system("print -Tnative /tmp/bush_print.PS");
		sprintf(msg,"Printed '%s'",bush_RootPathName(Bush));
		bushv_Announce(self,msg);
	    }
	    else bushv_Announce(self,"Error Printing");
	    break;
	case entries_object:
	    for(i=0;i < bush_DirEntriesCount(Bush,CurrNode);i++)
		if(bush_DirEntryMode(Bush,CurrNode,i).selected && 
		   !bush_DirEntryType(Bush,CurrNode,i).dir)
		    DoPrint(self,bush_DirPath(Bush,CurrNode),
			bush_DirEntryName(Bush,CurrNode,i));
	    break;
	case entry_object:
	    DoPrint(self,bush_DirPath(Bush,CurrNode),CurrEntry->name);
	    break;
    }
    bushv_RetractCursor(self,Cursor);
    OUT(PerformPrint);
}

static
DoPrint( self, path, name )
    struct bushv	*self;
    char		*path, *name; 
{
    char		 prog[101], full_path[MAXPATHLEN * 2];

    IN(DoPrint);
    strcpy(prog,"ezprint");
    sprintf(full_path,"%s/%s",path,name);
    sprintf(msg,"Printing '%s'",full_path);
    argv[0] = prog;
    argv[1] = full_path;
    argv[2] = NULL;
    PerformSystemAction(self,prog,argv,msg);
    OUT(DoPrint);
}

static void
PerformCreate( self )
    struct bushv		    *self;
{
    register int		     f = 0;
    char			    *response = NULL;

    IN(PerformCreate);
    if(!CurrNode) return;
    switch(Object) {
	case nodes_object:
	    if(bushv_Query(self,"Directory Name: ","",&response)) return;
	    sprintf(cmd,"%s/%s",bush_DirPath(Bush,CurrNode),response);
	    if(mkdir(cmd,0777)) {
		IssueError(self,"Creating",response,TRUE);
		return;
	    }
	    else PerformRescan(self);
	    break;
	case entries_object:
	    if(bushv_Query(self,"File Name: ","",&response)) return;
	    sprintf(cmd,"%s/%s",bush_DirPath(Bush,CurrNode),response);
	    if((f = open(cmd,O_CREAT | O_EXCL, 0100 | 0200 | 0400)) < 0) {
		IssueError(self,"Creating",response,TRUE);
		return;
	    }
	    else {
		close(f);
		PerformRescan(self);
	    }
	    break;
	case entry_object:
	    break;
    }
    OUT(PerformCreate);
}

static void
IssueError( self, what, where, overlay )
    register struct bushv	*self;
    register char		*what, *where;
    boolean			 overlay;
{
    int				 result = 0;
    static char			*question[] = {"Continue",NULL};

    IN(IssueError);
    if(errno <= sys_nerr) sprintf(msg,"ERROR %s '%s': %s",what,where,sys_errlist[errno]);
    else sprintf(msg,"ERROR %s '%s': (Invalid System Error-code '%d')",what,where,errno);
    if(overlay) message_MultipleChoiceQuestion(self,100,msg,0,&result,question,NULL);
    else bushv_Announce(self,msg);
    OUT(IssueError);
}

static int
DoDestroy( self, tn, Entry, overlay )
    register struct bushv	*self;
    register tree_type_node	 tn;
    register struct Dir_Entry	*Entry;
    boolean			 overlay;
{
    register int		 status = 0;

    IN(DoDestroy);
    if(self && tn && Entry) {
	if(status = bush_DestroyEntry(Bush,tn,Entry)) 
		IssueError(self,"Destroying",Entry->name,overlay);
    }
    OUT(DoDestroy);
    return(status);
}

static void
PerformDestroy( self )
    struct bushv *self;
{
    static char			    *question[] = {"Confirm","Cancel",0};
    register int		     i = 0;
    long			     result = 0;
    int				     count = 0;
    register struct Dir_Entry	    *Dir_Entry = NULL, *current_entry = CurrEntry;
    register tree_type_node	     current_node = CurrNode, tn = NULL;
    register struct suite_item     **selected = NULL;

    IN(PerformDestroy);
    if(!current_node) return;
    switch(self->object) {
	case nodes_object:
	    if(tn = bush_Parent(Bush,current_node)) {
		for(i=0;i<bush_DirEntriesCount(Bush,tn);i++)
		    if(bush_DirEntryType(Bush,tn,i).dir  &&
			strcmp(bush_DirName(Bush,current_node),
			    bush_DirEntryName(Bush,tn,i)) == 0) {
				Dir_Entry = bush_DirEntry(Bush,tn,i);
				break;
		    }
		if(Dir_Entry) {
		    sprintf(msg,"Confirm destroying '%s'",
			bush_DirName(Bush,current_node));
		    if(message_MultipleChoiceQuestion(self,50,msg,1,
			&result,question,NULL) == -1) return;
		    else if((result == 0) && bush_DirEntries(Bush,current_node) && 
			(bush_DirEntriesCount(Bush,current_node) > 0)){
			    sprintf(msg,"'%s' has contents. Destroy Anyway?",
				bush_DirName(Bush,current_node));
			    if(message_MultipleChoiceQuestion(self,100,msg,
				1,&result,question,NULL) == -1) return;
			    if(result != 0) {
				bushv_Announce(self,"Cancelled");
				return;
			    }
		    }
		    if(result == 0) {
			PostCursor(self,Cursor_Wait);
			if(DoDestroy(self,bush_Parent(Bush,current_node),
				     Dir_Entry,TRUE)) {
			    bushv_RetractCursor(self,Cursor);
			    return;
			}
			CurrNode = bush_Parent(Bush,current_node);
			treev_HighlightNode(DirTreeView,CurrNode);
			suite_ChangeSuiteAttribute(ControlView,
				suite_TitleCaption(bush_DirPath(Bush,CurrNode)));
			bushv_RetractCursor(self,Cursor);
			PerformRescan(self);
			sprintf(msg,"Destroyed Node '%s'",Dir_Entry->name);
			bushv_Announce(self,msg);
		    }
		}
		else bushv_Announce(self,"Node Not Found in Parent");
	    }
	    else bushv_Announce(self,"May Not Destroy Root Directory");
	    break;
	case entries_object:
	    selected = suite_SelectedItems(EntriesView,&count);
	    if(count == 0) break;
	    if(count > 1)
		if(count == 2) sprintf(msg,"Destroy Both Items ?");
		else sprintf(msg,"Destroy All %d Items ?",count);
	    else {
		Dir_Entry = (struct Dir_Entry*)
			suite_ItemAttribute(EntriesView,selected[0],suite_ItemDatum(0));
		sprintf(msg,"Destroy %s '%s' ?",DirType(Dir_Entry)
			? "Node" : "",Dir_Entry->name);
	    }
    	    if(message_MultipleChoiceQuestion(self,100,msg,1,
		&result,question,NULL) == -1) return;
	    if(result == 0) {
		PostCursor(self,Cursor_Wait);
		for( i = 0 ; i < count ; i++ ) {
    		    Dir_Entry = (struct Dir_Entry*) 
			suite_ItemAttribute(EntriesView,selected[i],suite_ItemDatum(0));
		    if(!DoDestroy(self,current_node,Dir_Entry,TRUE)) {
			suite_ChangeSuiteAttribute(ControlView,
				suite_TitleCaption(bush_DirPath(Bush,CurrNode)));
			suite_PassivateItem(EntriesView,selected[i]);
			Selected(Dir_Entry) = FALSE;
		    }
		}
		bushv_RetractCursor(self,Cursor);
	    }
	    else bushv_Announce(self,"Canceled");
	    break;
	case entry_object:
	    if(current_entry) {
		selected = suite_SelectedItems(EntriesView,&count);
		if(DirType(current_entry))
		    sprintf(msg,"Destroy Directory '%s'?",current_entry->name);
		else sprintf(msg,"Destroy '%s'?",current_entry->name);
		    if(message_MultipleChoiceQuestion(self,100,msg,1,
			&result,question,NULL) == -1) return;
		if(result==0) {
		    PostCursor(self,Cursor_Wait);
		    if(!DoDestroy(self,current_node,current_entry,TRUE)) {
			CurrEntry = NULL;
			PerformPop(self);
			suite_ChangeSuiteAttribute(ControlView,
				suite_TitleCaption(bush_DirPath(Bush,CurrNode)));
		    }
		    bushv_RetractCursor(self,Cursor);
		}
	    }
	    else bushv_Announce(self,"Canceled");
	    break;
    }
    OUT(PerformDestroy);
}

static void
PerformExec( self )
    struct bushv	*self;
{
    register int	 i = 0;

    IN(PerformExec);
    if(!CurrEntry) return;
    PostCursor(self,Cursor_Wait);
    switch(Object) {
	case nodes_object: break;
	case entries_object:
	    if(CurrNode && bush_DirEntries(Bush,CurrNode) && 
		(bush_DirEntriesCount(Bush,CurrNode) >= 0))
		    for(i = 0;i < bush_DirEntriesCount(Bush,CurrNode);i++)
			if(bush_DirEntryMode(Bush,CurrNode,i).selected &&
			   !bush_DirEntryType(Bush,CurrNode,i).dir)
			    DoExecute(self,CurrNode,bush_DirEntry(Bush,CurrNode,i));
	    break;
	case entry_object:
	    DoExecute(self,CurrNode,CurrEntry);
	    break;
    }
    bushv_RetractCursor(self,Cursor);
    OUT(PerformExec);
}

static
DoExecute( self, tn, Entry )
    struct bushv	*self;
    tree_type_node	 tn; 
    struct Dir_Entry	*Entry; 
{
    char		 full_path[MAXPATHLEN * 2];

    IN(DoExecute);
    sprintf(full_path,"%s/%s",bush_DirPath(Bush,tn),Entry->name);
    sprintf(msg,"Executing '%s'",full_path);
    argv[0] = full_path;
    argv[1] = NULL;
    PerformSystemAction(self,full_path,argv,msg);
    OUT(DoExecute);
}

static int
PerformSystemAction( self, name, argv, msg )
    struct bushv	*self;
    char		*name;
    char		*argv[];
    char		*msg;
{
    bushv_Announce(self,msg);
    return(bush_PerformSystemAction(Bush,name,argv));
}

static char*
Format_Tags( tag )
    u_short	    tag;
{
    static char	    tags[11];

    strcpy(tags,"----------");
    if((tag & S_IFMT) == S_IFREG) tags[0] = '-';
    else if((tag & S_IFMT) == S_IFDIR) tags[0] = 'd';
    else if((tag & S_IFMT) == S_IFCHR) tags[0] = 'c';
    else if((tag & S_IFMT) == S_IFBLK) tags[0] = 'b';
    else if((tag & S_IFMT) == S_IFLNK) tags[0] = 'l';
#ifdef S_IFIFO
    else if((tag & S_IFMT) == S_IFIFO) tags[0] = '?';
#endif /* #ifdef S_IFIFO */
#ifdef S_IFSOCK
    else if((tag & S_IFMT) == S_IFSOCK) tags[0] = '?';
#endif /* #ifdef S_IFSOCK */
    if(tag & S_IREAD) tags[1] = 'r';
    if(tag & S_IWRITE) tags[2] = 'w';
    if(tag & S_IEXEC) tags[3] = 'x';
    if(tag & (S_IREAD >>3)) tags[4] = 'r';
    if(tag & (S_IWRITE>>3)) tags[5] = 'w';
    if(tag & (S_IEXEC >>3)) tags[6] = 'x';
    if(tag & (S_IREAD >>6)) tags[7] = 'r';
    if(tag & (S_IWRITE>>6)) tags[8] = 'w';
    if(tag & (S_IEXEC >>6)) tags[9] = 'x';
    tags[10] = '\0';
    return(tags);
}

static char*
FormatEntriesItem( self, tn, i, DirEntry )
    register struct bushv	*self;
    tree_type_node	 tn;
    int			 i;
    struct Dir_Entry	*DirEntry;
{
    static char		 entries_item[257], trailer[5];
    register char	*entries_ptr = NULL, *time_ptr = NULL;

    IN(FormatEntriesItem);
    if(tn) {
	if(bush_DirEntryType(Bush,tn,i).dir) strcpy(trailer,"/");
	else if(bush_DirEntryType(Bush,tn,i).soft_link) strcpy(trailer,"@ ->");
	else if(bush_DirEntryPerms(Bush,tn,i) & S_IEXEC) strcpy(trailer,"*");
	else trailer[0] = '\0';
	if((bush_DirDetail(Bush,tn) == 1) || ((bush_DirDetail(Bush,tn) == -1) && Detail)) {
	    time_ptr = (char*) ctime(&bush_DirEntryTimeStamp(Bush,tn,i));
	    time_ptr[24] = '\0';
	    sprintf(entries_item,"%s %2d %8s %8d %s %s%s",
	         Format_Tags(bush_DirEntryPerms(Bush,tn,i)),
	         bush_DirEntryNLinks(Bush,tn,i),bush_DirEntryOwner(Bush,tn,i),
		 bush_DirEntrySize(Bush,tn,i),time_ptr,bush_DirEntryName(Bush,tn,i),
		 trailer);
	}
	else  sprintf(entries_item,"%s%s",bush_DirEntryName(Bush,tn,i),trailer);
	entries_ptr = entries_item;
    }
    else if(DirEntry) {
	if(DirType(DirEntry)) strcpy(trailer,"/");
	else if(LinkType(DirEntry)) strcpy(trailer,"@ ->");
	else if(DirPerms(DirEntry) & S_IEXEC) strcpy(trailer,"*");
	else trailer[0] = '\0';
	if((bush_DirDetail(Bush,CurrNode) == 1) ||
	    ((bush_DirDetail(Bush,CurrNode) == -1) && Detail)) {
	    time_ptr = (char*) ctime(&DirEntry->time_stamp);
	    time_ptr[24] = '\0';
	    sprintf(entries_item,"%s %2d %8s %8d %s %s%s",
	         Format_Tags(DirEntry->permissions),
	         DirEntry->nlinks,DirEntry->owner,
		 DirEntry->size,time_ptr,DirEntry->name,
		 trailer);
	}
	else  sprintf(entries_item,"%s%s",DirEntry->name,trailer);
	entries_ptr = entries_item;
    }
    OUT(FormatEntriesItem);
    return(entries_ptr);
}

static void
ResetEntriesCaptions( self )
    struct bushv	    *self;
{
    register int	     i = 0, count = 0;
    struct suite_item	    *item = NULL;

    IN(ResetEntriesCaptions);
    suite_Reset(EntriesView,suite_ClearItems);
    if(bush_DirEntries(Bush,CurrNode) && 
	(count = bush_DirEntriesCount(Bush,CurrNode)) >= 0)
	    for( i = 0 ; i < count ; i++ ) 
		if(item = suite_CreateItem(EntriesView,
		    bush_DirEntryName(Bush,CurrNode,i),bush_DirEntry(Bush,CurrNode,i)))
			suite_SetItemAttribute(EntriesView,item,
			    suite_ItemCaption(FormatEntriesItem(self,CurrNode,i,NULL)));
    OUT(ResetEntriesCaptions);
}

static void
PerformExit( self )
    struct bushv	*self;
{
    IN(PerformExit);
    if(TopLevelInset) im_Destroy(bushv_GetIM(self));
    bushv_Destroy(self);
    _exit(0);
    OUT(PerformExit); /*HA!*/
}

static void
SwitchDirectory( self )
    struct bushv	    *self;
{
    static char		    *question[] = {"Continue",NULL};
    int			     msg_status = 0;
    long		     result = 0;
    char		    *response = NULL;
    struct stat		     stats;

    IN(SwitchDirectory);
    msg_status = bushv_QueryDirectoryName(self,"Switch To Directory: ",&response);
    if(msg_status) return;
    PostCursor(self,Cursor_Wait);
    if(stat(response,&stats)) {
	IssueError(self,"ReScanning",response,TRUE);
	bushv_RetractCursor(self,Cursor);
	return;
    }
    if((stats.st_mode & S_IFMT) != S_IFDIR) {
	sprintf(msg,"Must Change to a Directory");
	message_MultipleChoiceQuestion(self,100,msg,0,&result,question,NULL);
	sprintf(msg,"Failed to change to '%s'",response);
	bushv_Announce(self,msg);
	bushv_RetractCursor(self,Cursor);
	return;
    }
    if(Object != nodes_object) {
	PopToNodes(self);
	PostCursor(self,Cursor_Wait);
    }
    SetTreeNotificationData(self,bush_TreeRoot(Bush),tree_NodeDestroyed);
    NotifyTreeObservers(self);
    tree_DestroyNode(bush_Tree(Bush),bush_TreeRoot(Bush));
    bush_InitTree(Bush,response);
    CurrNode = InitNode = bush_TreeRoot(Bush);
    bush_BuildSubDirs(Bush,CurrNode);
    SetTreeNotificationData(self,CurrNode,tree_NodeCreated);
    NotifyTreeObservers(self);
    suite_ChangeSuiteAttribute(ControlView,
	suite_TitleCaption(bush_DirPath(Bush,CurrNode)));
    if(TopLevelInset) im_SetTitle(bushv_GetIM(self),bush_DirName(Bush,CurrNode));
    bushv_RetractCursor(self,Cursor);
    HandleChangeDir(self,bush_RootPathName(Bush));
    OUT(SwitchDirectory);
}

static void
SetEditor( self )
    struct bushv	*self;
{
    long		 result = 0;   

    IN(SetEditor);
    sprintf(msg,"Set editor to: ");
    if(message_MultipleChoiceQuestion(self,100,msg,EditorIndex,
	&result,EditorChoices,NULL) == -1) return;
    EditorIndex = result;
    strcpy(EditorProgram,EditorChoices[result]);
    sprintf(msg,"Editor set to: '%s'",EditorProgram);
    bushv_Announce(self,msg);
    OUT(SetEditor);
}

void
bushv__PostKeyState( self, kstate )
    struct bushv	*self;
    struct keystate	*kstate;
{
    IN(bushv_KeyState);
    keystate_AddBefore(Kstate,kstate);
    super_PostKeyState(self,Kstate);
    OUT(bushv_KeyState);
}

char *
FormatEntriesInfo( self, tn )
    struct bushv	*self;
    tree_type_node	 tn;
{
    static char		 entries_info[257];
    register long	 i = 0, total_bytes = 0, count = 0;

    IN(FormatEntriesInfo);
    if(tn) {
	if(bush_DirEntries(Bush,tn)) count = bush_DirEntriesCount(Bush,tn);
	for( i = 0; i < count; i++ ) total_bytes += bush_DirEntrySize(Bush,tn,i);
	sprintf(entries_info,"%d %s    %d %s    %s %s",count,
	    "Entries",total_bytes,"Bytes","Sorted by",
	     (bush_DirSortMode(Bush,tn) != -1) ? sorts[bush_DirSortMode(Bush,tn)] :
	     sorts[SortMode]);
    }
    OUT(FormatEntriesInfo);
    return(entries_info);
}

static int
(*DetermineSortHandler( self, tn ))()
    struct bushv	*self;
    tree_type_node	 tn;
{
    int		       (*sorter)(), sMode = 0;

    IN(DetermineSortHandler);
    if((sMode = bush_DirSortMode(Bush,tn)) == -1) sMode = SortMode;
    switch(sMode) {
	case by_name:    sorter = SortByName;    break;
	case by_size:    sorter = SortBySize;    break;
	case by_date:    sorter = SortByDate;    break;
	case by_suffix:  sorter = SortBySuffix;  break;
	case by_type:    sorter = SortByType;    break;
    }
    OUT(DetermineSortHandler);
    return(sorter);
}

static void
PushToEntries( self )
    struct bushv	*self;
{
    register int       (*sorter)();

    IN(PushToEntries);
    if(EntriesView) {
	sorter = DetermineSortHandler(self,CurrNode);
	suite_SetSuiteAttribute(EntriesView,suite_SortHandler(sorter));
	Object = entries_object;
	ResetEntriesCaptions(self);
	suite_SetSuiteAttribute(EntriesView,
	    suite_TitleCaption(FormatEntriesInfo(self,CurrNode)));
	lpair_SetNth(LP,1,(struct view*)EntriesView);
	if(bush_ScanRequired(Bush,CurrNode)) PerformRescan(self);
	bushv_WantInputFocus(self,self);
    }
    OUT(PushToEntries);
}

static void
PushToEntry( self )
    struct bushv	*self;
{
    char		 file_name[MAXPATHLEN];
    char		*objectName = NULL;
    long		 objectID = 0;

    IN(PushToEntry);
    PostCursor(self,Cursor_Wait);
    Object = entry_object;
    sprintf(file_name,"%s/%s",bush_DirPath(Bush,CurrNode),CurrEntry->name);
    sprintf(msg,"reading '%s'",file_name);
    bushv_Announce(self,msg);
    if(EntryFilep = fopen(file_name,"r")) {
	objectName = filetype_Lookup(EntryFilep,file_name,&objectID,NULL); 
	if(!objectName) objectName = "text";
	if(EntryView) {
	    if(view_IsAncestor(EntryViewAppLayer,self))
		  lpair_SetNth(LP,1,NULL);
	    view_DeleteApplicationLayer(EntryView,EntryViewAppLayer);
	    view_Destroy(EntryView);
	    EntryView = EntryViewAppLayer = NULL;
	    dataobject_Destroy(EntryObject);
	    EntryObject = NULL;
	}
	if(!(EntryObject = (struct dataobject*)class_NewObject(objectName)) || 
	   !(EntryView = (struct view*)class_NewObject(dataobject_ViewName(EntryObject)))) {
	    IssueError(self,"Allocating Object",objectName,TRUE);
	    Object = entries_object;
	}
	else { /*success*/
	    dataobject_Read(EntryObject,EntryFilep,objectID);
	    view_SetDataObject(EntryView,EntryObject);
	    if(!strcmp(objectName,"text") || !strcmp(objectName,"ctext"))
		text_SetReadOnly((struct text*)EntryObject,TRUE);
	    lpair_SetNth(LP,1,
		EntryViewAppLayer = view_GetApplicationLayer(EntryView));
	    view_WantInputFocus(EntryView,EntryView);
	    suite_ChangeSuiteAttribute(ControlView,suite_TitleCaption(file_name));
	}
    }
    else {
	IssueError(self,"Opening Entry",CurrEntry->name,TRUE);
	Object = entries_object;
    }
    ClearFrameBuffer(self);
    bushv_RetractCursor(self,Cursor);
    OUT(PushToEntry);
}

static void
PopToNodes( self )
    struct bushv	*self;
{
    IN(PopToNodes);
    if(DirTreeView) {
	Object = nodes_object;
	CurrEntry = NULL;
	suite_ChangeSuiteAttribute(ControlView,
		suite_TitleCaption(bush_DirPath(Bush,CurrNode)));
	lpair_SetNth(LP,1,(struct view*)DirTreeView);
	if(bush_ScanRequired(Bush,CurrNode)) PerformRescan(self);
	bushv_WantInputFocus(self,self); 
    }
    OUT(PopToNodes);
}

static void
PopToEntries( self )
    struct bushv	*self;
{
    IN(PopToEntries);
    if(EntryFilep) {
	fclose(EntryFilep);
	EntryFilep = NULL;
    }
    if(EntriesView) {
	Object = entries_object;
	lpair_SetNth(LP,1,(struct view*)EntriesView);
	suite_ChangeSuiteAttribute(ControlView,
		suite_TitleCaption(bush_DirPath(Bush,CurrNode)));
	if(bush_ScanRequired(Bush,CurrNode)) PerformRescan(self);
	bushv_WantInputFocus(self,self);
    }
    OUT(PopToEntries);
}

static long
Passivator( self, suite, item, datum )
/*
============================================================
    I set the data attribute of the ControlView items to be the OR'ed sum of
    the Object codes for which the particular item is active. If a button is
    active during both the nodes_object(1) and entries_object(2) then it's data field
    is set to (nodes_object + entries_Object) = 1 + 2 = 3. This is how I implemented
    automatic button "Passivation" in bush.  It has been proposed that this feature
    be incorporated into suite (3/29/89).
=============================================================
*/
    struct bushv	    *self;
    struct suite	    *suite;
    struct suite_item	    *item;
    unsigned		     datum;
{
    long int		     result = 0;

    if(suite && item)
	if(suite_ItemAttribute(suite,item,suite_ItemDatum(0)) & Object)
	    suite_ActivateItem(suite,item);
	else suite_PassivateItem(suite,item);
    return(result);
}

static void
PassivateControls( self )
    struct bushv    *self;
{
    IN(PassivateControls);
    suite_Apply(ControlView,Passivator,self,NULL);
    suite_Reset(ControlView,suite_Normalize);
    OUT(PassivateControls);
}

static void
Push( self )
    register struct bushv   *self;
{
    register tree_type_node  tn = NULL;
    char		    *name = NULL;

    IN(Push);
    switch(Object) {
	case nodes_object:
	    PushToEntries(self);
	    break;
	case entries_object:
	    if(DirType(CurrEntry)) {
		AllocNameSpace(&name,CurrEntry->name);
		PostCursor(self,Cursor_Wait);
		Pop(self);
		tn = bush_Child(Bush,CurrNode);
		while(tn) {
		    if(!strcmp(bush_DirName(Bush,tn),name)) 
			break;
		    else tn = bush_Right(Bush,tn);
		}
		if(tn) TreeHitHandler(self,DirTreeView,tn,
				      treev_NodeObject,view_LeftUp,0,0,0);
		else {
		    sprintf(msg,"Couldn't locate directory node '%s'.",CurrEntry->name);
		    bushv_Announce(self,msg);
		}
		if(name) free(name);
		bushv_RetractCursor(self,Cursor);
	    }
	    else PushToEntry(self);
	    break;
    }
    PassivateControls(self);
    ClearFrameBuffer(self);
    OUT(Push);
}

static void
Pop( self )
    struct bushv    *self;
{
    IN(Pop);
    switch(Object) {
	case entries_object:
	    PopToNodes(self);
	    break;
	case entry_object:
	    PopToEntries(self);
	    break;
    }
    PassivateControls(self);
    ClearFrameBuffer(self);
    OUT(Pop);
}

static void
PerformPop( self )
    struct bushv	*self;
{
    IN(PerformPop);
    PostCursor(self,Cursor_Wait);
    Pop(self);
    bushv_RetractCursor(self,Cursor);
    OUT(PerformPop);
}

static long
ToggleCaptionDetail( self, suite, item, datum )
    struct bushv	    *self;
    struct suite	    *suite;
    struct suite_item	    *item;
    unsigned		     datum;
{
    long int		     result = 0;

    IN(ToggleCaptionDetail);
    if(suite && item )
	suite_SetItemAttribute(suite,item,
	    suite_ItemCaption(FormatEntriesItem(self,NULL,0,(struct Dir_Entry*)
		suite_ItemAttribute(suite,item,suite_ItemDatum(0)))));
    OUT(ToggleCaptionDetail);
    return(result);
}

static void
SortDir( self, tn )
    struct bushv	*self;
    tree_type_node	 tn;
{
    register int       (*sorter)();

    IN(SortDir);
    sorter = DetermineSortHandler(self,tn);
    if(Object == entries_object) suite_Sort(EntriesView,0,sorter);
    suite_ChangeSuiteAttribute(EntriesView,
	suite_TitleCaption(FormatEntriesInfo(self,CurrNode)));
    OUT(SortDir);
}

static long
ResetDirDetailModes( self, tree, tn, datum )
    struct bushv	*self;
    struct tree		*tree;
    tree_type_node	 tn;
    long		 datum;
{
    register long	 status = 0;

    IN(ResetDirDetailModes);
    if(tree && tn) bush_DirDetail(Bush,tn) = -1;
    OUT(ResetDirDetailModes);
    return(status);
}

static void
PerformDetail( self )
     struct bushv   *self;
{
    int		     detail = 0;

    IN(PerformDetail);
    PostCursor(self,Cursor_Wait);
    sleep(1);
    if(Object == nodes_object) {
	Detail = !Detail;
	tree_Apply(bush_Tree(Bush),NULL,ResetDirDetailModes,self,0);
	sprintf(msg,"Global detail '%s'", Detail ? "On" : "Off" );
	bushv_Announce(self,msg);
    }
    else if(Object == entries_object) {
	if((detail = bush_DirDetail(Bush,CurrNode)) == -1) 
	    bush_DirDetail(Bush,CurrNode) = !Detail;
	else bush_DirDetail(Bush,CurrNode) = !detail;
	suite_Apply(EntriesView,ToggleCaptionDetail,self,0);
	suite_WantUpdate(EntriesView,EntriesView);
    }
    bushv_RetractCursor(self,Cursor);
    OUT(PerformDetail);
}

void
bushv__SetDataObject( self, bush )
    struct bushv	*self;
    struct bush		*bush;
{
    IN(bushv_SetDataObject);
    Bush = bush;
    treev_SetDataObject(DirTreeView,bush_Tree(Bush));
    super_SetDataObject(self,bush);
    CurrNode = InitNode = bush_TreeRoot(Bush);
    HandleChangeDir(self,bush_RootPathName(Bush));
    OUT(bushv_SetDataObject);
}

static int
SortRequested( self, tn )
    struct bushv	*self;
    tree_type_node	 tn;
{
    int			 sort = -1, result = 0, current_mode = 0;

    IN(SortRequested);
    if( Object == entries_object ) {
	IgnoreFullUpdate = true;
	if(bush_DirSortMode(Bush,CurrNode) != -1)
	    current_mode = bush_DirSortMode(Bush,CurrNode);
	else current_mode = SortMode;
    }
    else current_mode = SortMode;
    if(message_MultipleChoiceQuestion(self,100,"Sort By: ",current_mode, &result,sorts,NULL) != -1)
	    switch(result) {
		case 0:  sort = by_name;   break;
		case 1:  sort = by_size;   break;
		case 2:  sort = by_date;   break;
		case 3:  sort = by_suffix; break;
		case 4:  sort = by_type;   break;
		default: sort = -1;
	    }
    OUT(SortRequested);
    return(sort);
}

static long
ResetDirSortModes( self, tree, tn, datum )
/*  ... to the globally-implied SortMode value. */
    struct bushv    *self;
    struct tree	    *tree;
    tree_type_node   tn;
    long	     datum;
{
    long int	     status = 0;

    IN(ResetDirSortModes);
    if(tree && tn) bush_DirSortMode(Bush,tn) = -1;
    OUT(ResetDirSortModes);
    return(status);
}

static void
PerformSort( self )
    struct bushv	 *self;
{
    int			(*sorter)(), sMode = 0;

    IN(PerformSort);
    if(Object == entry_object) return;
    if((sMode = SortRequested(self,CurrNode)) != -1) {
	if(Object == nodes_object) {
	    sprintf(msg,"Sorting by '%s' ...",sorts[SortMode = sMode]);
	    bushv_Announce(self,msg);
	    sorter = DetermineSortHandler(self,CurrNode);
	    suite_SetSuiteAttribute(EntriesView,suite_SortHandler(sorter));
	    tree_Apply(bush_Tree(Bush),NULL,ResetDirSortModes,self,0);
	    bushv_Announce(self,"");
	    return;
	}
	else if(Object == entries_object) {
	    bush_DirSortMode(Bush,CurrNode) = sMode;
	    sprintf(msg,"Sorting by '%s' ...",sorts[sMode]);
	    bushv_Announce(self,msg);
	    im_ForceUpdate();
	    PostCursor(self,Cursor_Wait);
	    SortDir(self,CurrNode);
	    bushv_RetractCursor(self,Cursor);
	}
	ClearFrameBuffer(self);
    }
    bushv_Announce(self,"");
    OUT(PerformSort);
}

static void
PerformRescan( self )
    struct bushv	*self;
{
    struct stat		 stats;

    IN(PerformRescan);
    if(!CurrNode) return;
    PostCursor(self,Cursor_Wait);
    if(stat(bush_DirPath(Bush,CurrNode),&stats)) {
	bush_DirMode(Bush,CurrNode).stat_failed = TRUE;
	IssueError(self,"ReScanning",bush_DirPath(Bush,CurrNode),TRUE);
	bushv_RetractCursor(self,Cursor);
	return;
    }
    if(Object == nodes_object || Object == entries_object) {
	sprintf(msg,"Scanning Directory '%s' ...",bush_DirPath(Bush,CurrNode));
	bushv_Announce(self,msg);
	if(bush_Child(Bush,CurrNode)) {
	    SetTreeNotificationData(self,CurrNode,tree_NodeChildrenDestroyed);
	    NotifyTreeObservers(self);
	}
	bush_ScanDir(Bush,CurrNode);
	bush_BuildSubDirs(Bush,CurrNode);
	if(bush_Child(Bush,CurrNode)) {
	    SetTreeNotificationData(self,CurrNode,tree_NodeChildrenCreated);
	    NotifyTreeObservers(self);
	}
	if(Object == entries_object) {
	    ResetEntriesCaptions(self);
	    SortDir(self,CurrNode);
	}
	sprintf(msg,"Finished scanning '%s'",bush_DirPath(Bush,CurrNode));
	bushv_Announce(self,msg);
    }
    else if(Object == entry_object) PushToEntry(self);
    bushv_RetractCursor(self,Cursor);
    OUT(PerformRescan);
}

static int
ResetChildDirPaths( self, tree, tn, datum )
    struct bushv    *self;
    struct tree	    *tree;
    tree_type_node   tn;
    long	     datum;
{
    long int	     status = 0;
    char	     tmp_path[MAXPATHLEN];

    IN(ResetChildDirPaths);
    if(tn && tree_NodeLevel(bush_Tree(Bush),tn) > tree_NodeLevel(bush_Tree(Bush),CurrNode)) {
	sprintf(tmp_path,"%s/%s",(char*)datum,bush_DirName(self,tn));
	AllocNameSpace(&bush_DirPath(Bush,tn),tmp_path);
    }
    else if(tn && (CurrNode == tn)) status = 0;
    else status = -1;
    OUT(ResetChildDirPaths);
    return(status);
}


static void
PerformRename( self )
    struct bushv		    *self;
{
    int				     msg_status = 0, count = 0;
    char			    *response = NULL, tmp_path[MAXPATHLEN],
				    *tmp = NULL;
    register struct suite_item	   **selected = NULL;
    struct Dir_Entry		    *DirEntry = NULL;
    register int		     i = 0;

    IN(PerformRename);
    if(!CurrNode) return;
    switch(Object) {
	case nodes_object:
	    msg_status = bushv_Query(self,"New Name: ",
		bush_DirName(Bush,CurrNode),&response);
	    if(msg_status || !strcmp(response,bush_DirName(Bush,CurrNode))) return;
	    sprintf(msg,"Directory '%s' renamed to '",bush_DirName(Bush,CurrNode));
	    strcpy(tmp_path,bush_DirPath(Bush,CurrNode));
	    if(tmp = rindex(tmp_path,'/')) *tmp = '\0';
	    if(!bush_RenameDir(Bush,CurrNode,tmp_path,response)) {
		tree_SetNodeName(bush_Tree(Bush),CurrNode,
		    bush_DirName(Bush,CurrNode));
		SetTreeNotificationData(self,CurrNode,tree_NodeNameChanged);
		NotifyTreeObservers(self);
		strcat(msg,bush_DirName(Bush,CurrNode));
		strcat(msg,"'");
		bushv_Announce(self,msg);
		suite_ChangeSuiteAttribute(ControlView,
			suite_TitleCaption(bush_DirPath(Bush,CurrNode)));
		tree_Apply(bush_Tree(Bush),CurrNode,ResetChildDirPaths,
			self,strcpy(tmp_path,bush_DirPath(Bush,CurrNode)));
	    }
	    else IssueError(self,"Renaming",bush_DirName(Bush,CurrNode),TRUE);
	    break;
	case entries_object:
	    selected = suite_SelectedItems(EntriesView,&count);		
	    for( i = 0 ; (i < count) && selected[i] ; i++ ) {
		suite_PassivateItem(EntriesView,selected[i]);
		DirEntry = (struct Dir_Entry *)
			suite_ItemAttribute(EntriesView,selected[i],suite_ItemDatum(0));
		sprintf(msg,"Renaming '%s' to '",DirEntry->name);
		msg_status = bushv_Query(self,"New Name: ",
		    DirEntry->name,&response);
		if(msg_status || !strcmp(response,DirEntry->name)) {
		    suite_ActivateItem(EntriesView,selected[i]);
		    suite_HighlightItem(EntriesView,selected[i]);
		    continue;
		}
		if(bush_MoveEntry(Bush,CurrNode,DirEntry,response) != -1) {
		    strcat(msg,response); strcat(msg,"'");
		    bushv_Announce(self,msg);
		    suite_ActivateItem(EntriesView,selected[i]);
		    suite_HighlightItem(EntriesView,selected[i]);
		    suite_ChangeItemAttribute(EntriesView,selected[i],
			suite_ItemCaption(FormatEntriesItem(self,NULL,0,DirEntry)));
		}
		else {
		    IssueError(self,"Renaming",DirEntry->name,TRUE);
		    suite_ActivateItem(EntriesView,selected[i]);
		    suite_HighlightItem(EntriesView,selected[i]);
		}
	    }
	    break;
	case entry_object:
	    msg_status = bushv_Query(self,"New Name: ",CurrEntry->name,&response);
	    if(msg_status || !strcmp(response,CurrEntry->name)) return;
	    sprintf(msg,"'%s' renamed to '",CurrEntry->name);
	    if(bush_MoveEntry(Bush,CurrNode,CurrEntry,response) != -1) {
		strcat(msg,response); strcat(msg,"'");
		bushv_Announce(self,msg);
		sprintf(msg,"%s/%s",bush_DirPath(Bush,CurrNode),CurrEntry->name);
		suite_ChangeSuiteAttribute(ControlView,suite_TitleCaption(msg));
	    }
	    else IssueError(self,"Renaming",CurrEntry->name,TRUE);
	    break;
    }
    OUT(PerformRename);
}

static void
ToggleDebug( self, rock )
    struct bushv    *self;
    long	     rock;
{
    IN(ToggleDebug);
    Debug = !Debug;
    suite_SetDebug(EntriesView,TRUE);
    OUT(ToggleDebug);
}

struct view *
bushv__GetApplicationLayer( self )
    struct bushv    *self;
{
    IN(bushv_GetApplicationLayer);
    TopLevelInset = FALSE;
    OUT(bushv_GetApplicationLayer);
    return((struct view *)self);
}

void
bushv__ReceiveInputFocus( self )
    struct bushv    *self;
{
    IN(bushv_ReceiveInputFocus);
    bushv_PostMenus(self,NULL);
    OUT(bushv_ReceiveInputFocus);
}

static void
HandleChangeDir( self, dirName )
     register struct bushv   *self;
     register char	    *dirName;
{
    IN(HandleChangeDir);
    if(dirName && (*dirName != '\0'))
	im_ChangeDirectory(dirName);
    OUT(HandleChangeDir);
}
