/*
 * drag_n_drop.c -- demonstrate how to handle drag and drop usage in
 * OPEN LOOK. Create a base frame, canvas and text subwindow.  Install
 * an event handler for the canvas to interpret drag-and-drop actions.
 * The text subwindow is there for convenience, but you can drag and
 * drop from anywhere on the screen.  The "file manager" application
 * can be used to generate the ACTION_DRAG_LOAD event/action.  The user
 * can select text and then "drag" the selection on top of the canvas
 * window.  When this happens, the canvas' callback routine is called
 * and the event_action(event) will be set accordingly.
 */
#include <X11/Xlib.h>
#include <xview/xview.h>
#include <xview/canvas.h>
#include <xview/textsw.h>
#include <xview/seln.h>

main(argc, argv)
int     argc;
char    *argv[];
{
    Frame       frame;
    Canvas      canvas;
    void        event_handler();

    xv_init(XV_INIT_ARGS, argc, argv, NULL);

    frame = (Frame)xv_create(NULL, FRAME, NULL);
    canvas = (Canvas)xv_create(frame, CANVAS,
        XV_WIDTH,  300,
        XV_HEIGHT, 300,
        NULL);
    xv_set(canvas_paint_window(canvas),
        WIN_EVENT_PROC, event_handler,
        NULL);
    (void) xv_create(frame, TEXTSW,
        TEXTSW_CONTENTS,
            "This is a test of the emergency broadcasting system.",
        XV_HEIGHT, 300,
        XV_WIDTH,  300,
        NULL);
    window_fit(frame);

    xv_main_loop(frame);
}

/*
 * handle the drag and drop actions.  Also handle the ACTION_PASTE
 * event since it is very similar.  The action specifies how the
 * event was generated.  In all drag-and-drop cases, the contents
 * of the selection is held in the primary selection.  Use the
 * selection service routines to extract the information.
 */
void
event_handler(window, event, arg)
Xv_Window       window;
Event           *event;
Notify_arg      arg;
{
    Display *dpy = (Display *)xv_get(window, XV_DISPLAY);
    char     msg[128];

    /* not interested in action-up events */
    if (event_is_up(event))
        return;
    switch (event_action(event)) {
        case ACTION_PASTE:
        case ACTION_DRAG_LOAD:
        case ACTION_DRAG_COPY:
        case ACTION_DRAG_MOVE: {
            Seln_holder     holder;
            Seln_request   *result;
            Seln_rank       selection;
            char           *data;
            int             read_only;

            /*
             * ACTION_PASTE is generated by hitting L8, or the "paste"
             * key on the left side of the keyboard.  This assumes you
             * have cut (L10) or copied (L6) a selection first.
             */

            if (event_action(event) == ACTION_PASTE) {
                strcpy(msg, "paste from shelf: ");
                selection = SELN_SHELF;
            } else {
                sprintf(msg, "drag and drop (%s): ",
                    event_action(event) == ACTION_DRAG_MOVE ? "move" :
                    event_action(event) == ACTION_DRAG_LOAD ? "load" : "copy");
                selection = SELN_PRIMARY;
            }
            holder = seln_inquire(selection);
            result = seln_ask(&holder,
                SELN_REQ_IS_READONLY,    NULL,
                SELN_REQ_CONTENTS_ASCII, NULL,
                NULL);
            data = result->data;
            data += sizeof(Seln_attribute);

            /* testing read-only is only important if the selection
             * came from a textsw.  If so, then we need to know if
             * it is read-only to head off a drag-move since we won't
             * be able to delete the selection from that window.
             * Note, there is no way to determine the type of the xview
             * object that is holding the selection! :-(
             */

            if ((read_only = *(int *) data) == TRUE &&
                event_action(event) == ACTION_DRAG_MOVE)
                /* can't "move" text from a read-only window. use copy */
                return;
            data += sizeof(int) + sizeof(SELN_REQ_CONTENTS_ASCII);
            strcat(msg, data);
            if (event_action(event) == ACTION_DRAG_MOVE)
                /* ask holder to delete its selection for drag moves */
                seln_ask(&holder, SELN_REQ_DELETE, NULL, NULL);
            break;
        }
        default :
            /* we could go on and on with the above cases ... */
            return;
    }
    XClearWindow(dpy, xv_get(window, XV_XID));
    XDrawString(dpy, xv_get(window, XV_XID),
        DefaultGC(dpy, DefaultScreen(dpy)), 20, 20, msg, strlen(msg));
}
